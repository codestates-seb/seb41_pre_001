{
  "version": 3,
  "names": [
    "selectWord",
    "text",
    "selection",
    "length",
    "start",
    "end",
    "getSurroundingWord",
    "getBreaksNeededForEmptyLineBefore",
    "startPosition",
    "neededBreaks",
    "isInFirstLine",
    "i",
    "charCodeAt",
    "getBreaksNeededForEmptyLineAfter",
    "isInLastLine",
    "position",
    "Error",
    "isWordDelimiter",
    "c"
  ],
  "sources": [
    "../../src/utils/markdownUtils.ts"
  ],
  "sourcesContent": [
    "import { TextRange } from '../commands';\n\nexport interface TextSection {\n  text: string;\n  selection: TextRange;\n}\n\nexport function selectWord({ text, selection }: TextSection): TextRange {\n  if (text && text.length && selection.start === selection.end) {\n    // the user is pointing to a word\n    return getSurroundingWord(text, selection.start);\n  }\n  return selection;\n}\n\n/**\n *  Gets the number of line-breaks that would have to be inserted before the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the previous text\n */\nexport function getBreaksNeededForEmptyLineBefore(text = '', startPosition: number): number {\n  if (startPosition === 0) return 0;\n\n  // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  let neededBreaks = 2;\n  let isInFirstLine = true;\n  for (let i = startPosition - 1; i >= 0 && neededBreaks >= 0; i--) {\n    switch (text.charCodeAt(i)) {\n      case 32: // blank space\n        continue;\n      case 10: // line break\n        neededBreaks--;\n        isInFirstLine = false;\n        break;\n      default:\n        return neededBreaks;\n    }\n  }\n  return isInFirstLine ? 0 : neededBreaks;\n}\n\n/**\n *  Gets the number of line-breaks that would have to be inserted after the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the next text\n */\nexport function getBreaksNeededForEmptyLineAfter(text = '', startPosition: number): number {\n  if (startPosition === text.length - 1) return 0;\n\n  // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  let neededBreaks = 2;\n  let isInLastLine = true;\n  for (let i = startPosition; i < text.length && neededBreaks >= 0; i++) {\n    switch (text.charCodeAt(i)) {\n      case 32:\n        continue;\n      case 10: {\n        neededBreaks--;\n        isInLastLine = false;\n        break;\n      }\n      default:\n        return neededBreaks;\n    }\n  }\n  return isInLastLine ? 0 : neededBreaks;\n}\n\nexport function getSurroundingWord(text: string, position: number): TextRange {\n  if (!text) throw Error(\"Argument 'text' should be truthy\");\n\n  const isWordDelimiter = (c: string) => c === ' ' || c.charCodeAt(0) === 10;\n\n  // leftIndex is initialized to 0 because if selection is 0, it won't even enter the iteration\n  let start = 0;\n  // rightIndex is initialized to text.length because if selection is equal to text.length it won't even enter the interation\n  let end = text.length;\n\n  // iterate to the left\n  for (let i = position; i - 1 > -1; i--) {\n    if (isWordDelimiter(text[i - 1])) {\n      start = i;\n      break;\n    }\n  }\n\n  // iterate to the right\n  for (let i = position; i < text.length; i++) {\n    if (isWordDelimiter(text[i])) {\n      end = i;\n      break;\n    }\n  }\n\n  return { start, end };\n}\n"
  ],
  "mappings": "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"
}
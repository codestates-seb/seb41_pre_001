{"ast":null,"code":"/**\n * @typedef {import('./types.js').Rule} Rule\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Element} Element\n * @typedef {import('./types.js').Parent} Parent\n * @typedef {import('./types.js').SelectState} SelectState\n * @typedef {import('./types.js').SelectIterator} SelectIterator\n * @typedef {import('./types.js').Handler} Handler\n */\n\nimport { zwitch } from 'zwitch';\nimport { enterState } from './enter-state.js';\nimport { parent, element } from './util.js';\nconst own = {}.hasOwnProperty;\nconst handle = zwitch('nestingOperator', {\n  // @ts-expect-error: hush.\n  unknown: unknownNesting,\n  // @ts-expect-error: hush.\n  invalid: topScan,\n  // `undefined` is the top query selector.\n  handlers: {\n    // @ts-expect-error: hush.\n    null: descendant,\n    // `null` is the descendant combinator.\n    // @ts-expect-error: hush.\n    '>': child,\n    // @ts-expect-error: hush.\n    '+': adjacentSibling,\n    // @ts-expect-error: hush.\n    '~': generalSibling\n  }\n});\n\n/** @type {Handler} */\nexport function nest(query, node, index, parent, state) {\n  handle(query, node, index, parent, state);\n}\n\n// Shouldn’t be called, parser gives correct data.\n/* c8 ignore next 6 */\n/**\n * @param {{[x: string]: unknown, type: string}} query\n */\nfunction unknownNesting(query) {\n  throw new Error('Unexpected nesting `' + query.nestingOperator + '`');\n}\n\n/** @type {Handler} */\nfunction topScan(query, node, index, parent, state) {\n  // Shouldn’t happen.\n  /* c8 ignore next 3 */\n  if (parent || index === null) {\n    throw new Error('topScan is supposed to be called from the root node');\n  }\n\n  // Shouldn’t happen.\n  /* c8 ignore next 3 */\n  if (!state.iterator) {\n    throw new Error('Expected `iterator`');\n  }\n  state.iterator(query, node, index, parent, state);\n  if (!state.shallow) descendant(query, node, index, parent, state);\n}\n\n/** @type {Handler} */\nfunction descendant(query, node, index, parent, state) {\n  const previous = state.iterator;\n  state.iterator = iterator;\n  child(query, node, index, parent, state);\n\n  /** @type {SelectIterator} */\n  function iterator(query, node, index, parent, state) {\n    // Shouldn’t happen.\n    /* c8 ignore next 3 */\n    if (!previous) {\n      throw new Error('Expected `iterator`');\n    }\n    state.iterator = previous;\n    previous(query, node, index, parent, state);\n    state.iterator = iterator;\n    if (state.one && state.found) return;\n    child(query, node, index, parent, state);\n  }\n}\n\n/** @type {Handler} */\nfunction child(query, node, _1, _2, state) {\n  if (!parent(node)) return;\n  if (node.children.length === 0) return;\n  indexedSearch(query, node, state);\n}\n\n/** @type {Handler} */\nfunction adjacentSibling(query, _, index, parent, state) {\n  // Shouldn’t happen.\n  /* c8 ignore next */\n  if (!parent || index === null) return;\n  indexedSearch(query, parent, state, index + 1, true);\n}\n\n/** @type {Handler} */\nfunction generalSibling(query, _, index, parent, state) {\n  // Shouldn’t happen.\n  /* c8 ignore next */\n  if (!parent || index === null) return;\n  indexedSearch(query, parent, state, index + 1);\n}\n\n/**\n * Handles `typeIndex` and `typeCount` properties for every walker.\n *\n * @param {Rule} query\n * @param {Parent} parent\n * @param {SelectState} state\n * @param {number} [from=0]\n * @param {boolean} [firstElementOnly=false]\n */\nfunction indexedSearch(query, parent, state, from, firstElementOnly) {\n  const handle = state.index ? delay : add;\n  const children = parent.children;\n  let elements = 0;\n  let index = -1;\n  /** @type {Record<string, number>} */\n  const types = {};\n  /** @type {Array<Function>} */\n  const delayed = [];\n\n  // Start looking at `from`\n  if (from === undefined || from === null) from = 0;\n\n  // Exit if there are no further nodes.\n  if (from >= children.length) return;\n\n  // If we need to index for types, do so for all elements before `from`.\n  if (state.index) {\n    while (++index < from) {\n      const child = children[index];\n      if (element(child)) count(child.tagName);\n    }\n  }\n  index = from - 1;\n  while (++index < children.length) {\n    const child = children[index];\n    // Only check elements.\n    // Check either all elements, or only check the first sibling\n    if (element(child)) {\n      handle(child, index);\n\n      // Stop if we’re looking for one node and it’s already found.\n      if (state.one && state.found) return;\n      if (firstElementOnly) break;\n    }\n  }\n  if (state.index) {\n    index = -1;\n    while (++index < delayed.length) {\n      delayed[index]();\n      if (state.one && state.found) return;\n    }\n  }\n\n  /**\n   * @param {Element} node\n   * @param {number} childIndex\n   */\n  function delay(node, childIndex) {\n    const elementsBefore = elements;\n    const elementsByTypeBefore = own.call(types, node.tagName) ? types[node.tagName] : 0;\n    count(node.tagName);\n    delayed.push(fn);\n    function fn() {\n      // Before counting further elements:\n      state.elementIndex = elementsBefore;\n      state.typeIndex = elementsByTypeBefore;\n\n      // After counting all elements.\n      state.elementCount = elements;\n      state.typeCount = types[node.tagName];\n      add(node, childIndex);\n    }\n  }\n\n  /**\n   * @param {Element} node\n   * @param {number} childIndex\n   */\n  function add(node, childIndex) {\n    const exit = enterState(state, node);\n\n    // Shouldn’t happen.\n    /* c8 ignore next 3 */\n    if (!state.iterator) {\n      throw new Error('Expected `iterator`');\n    }\n    state.iterator(query, node, childIndex, parent, state);\n    exit();\n  }\n\n  /**\n   * @param {string} name\n   */\n  function count(name) {\n    if (!own.call(types, name)) types[name] = 0;\n    elements++;\n    types[name]++;\n  }\n}","map":{"version":3,"names":["zwitch","enterState","parent","element","own","hasOwnProperty","handle","unknown","unknownNesting","invalid","topScan","handlers","null","descendant","child","adjacentSibling","generalSibling","nest","query","node","index","state","Error","nestingOperator","iterator","shallow","previous","one","found","_1","_2","children","length","indexedSearch","_","from","firstElementOnly","delay","add","elements","types","delayed","undefined","count","tagName","childIndex","elementsBefore","elementsByTypeBefore","call","push","fn","elementIndex","typeIndex","elementCount","typeCount","exit","name"],"sources":["/home/kty/workspace/seb41_pre_001/client/node_modules/hast-util-select/lib/nest.js"],"sourcesContent":["/**\n * @typedef {import('./types.js').Rule} Rule\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Element} Element\n * @typedef {import('./types.js').Parent} Parent\n * @typedef {import('./types.js').SelectState} SelectState\n * @typedef {import('./types.js').SelectIterator} SelectIterator\n * @typedef {import('./types.js').Handler} Handler\n */\n\nimport {zwitch} from 'zwitch'\nimport {enterState} from './enter-state.js'\nimport {parent, element} from './util.js'\n\nconst own = {}.hasOwnProperty\n\nconst handle = zwitch('nestingOperator', {\n  // @ts-expect-error: hush.\n  unknown: unknownNesting,\n  // @ts-expect-error: hush.\n  invalid: topScan, // `undefined` is the top query selector.\n  handlers: {\n    // @ts-expect-error: hush.\n    null: descendant, // `null` is the descendant combinator.\n    // @ts-expect-error: hush.\n    '>': child,\n    // @ts-expect-error: hush.\n    '+': adjacentSibling,\n    // @ts-expect-error: hush.\n    '~': generalSibling\n  }\n})\n\n/** @type {Handler} */\nexport function nest(query, node, index, parent, state) {\n  handle(query, node, index, parent, state)\n}\n\n// Shouldn’t be called, parser gives correct data.\n/* c8 ignore next 6 */\n/**\n * @param {{[x: string]: unknown, type: string}} query\n */\nfunction unknownNesting(query) {\n  throw new Error('Unexpected nesting `' + query.nestingOperator + '`')\n}\n\n/** @type {Handler} */\nfunction topScan(query, node, index, parent, state) {\n  // Shouldn’t happen.\n  /* c8 ignore next 3 */\n  if (parent || index === null) {\n    throw new Error('topScan is supposed to be called from the root node')\n  }\n\n  // Shouldn’t happen.\n  /* c8 ignore next 3 */\n  if (!state.iterator) {\n    throw new Error('Expected `iterator`')\n  }\n\n  state.iterator(query, node, index, parent, state)\n  if (!state.shallow) descendant(query, node, index, parent, state)\n}\n\n/** @type {Handler} */\nfunction descendant(query, node, index, parent, state) {\n  const previous = state.iterator\n\n  state.iterator = iterator\n  child(query, node, index, parent, state)\n\n  /** @type {SelectIterator} */\n  function iterator(query, node, index, parent, state) {\n    // Shouldn’t happen.\n    /* c8 ignore next 3 */\n    if (!previous) {\n      throw new Error('Expected `iterator`')\n    }\n\n    state.iterator = previous\n    previous(query, node, index, parent, state)\n    state.iterator = iterator\n\n    if (state.one && state.found) return\n\n    child(query, node, index, parent, state)\n  }\n}\n\n/** @type {Handler} */\nfunction child(query, node, _1, _2, state) {\n  if (!parent(node)) return\n  if (node.children.length === 0) return\n  indexedSearch(query, node, state)\n}\n\n/** @type {Handler} */\nfunction adjacentSibling(query, _, index, parent, state) {\n  // Shouldn’t happen.\n  /* c8 ignore next */\n  if (!parent || index === null) return\n  indexedSearch(query, parent, state, index + 1, true)\n}\n\n/** @type {Handler} */\nfunction generalSibling(query, _, index, parent, state) {\n  // Shouldn’t happen.\n  /* c8 ignore next */\n  if (!parent || index === null) return\n  indexedSearch(query, parent, state, index + 1)\n}\n\n/**\n * Handles `typeIndex` and `typeCount` properties for every walker.\n *\n * @param {Rule} query\n * @param {Parent} parent\n * @param {SelectState} state\n * @param {number} [from=0]\n * @param {boolean} [firstElementOnly=false]\n */\nfunction indexedSearch(query, parent, state, from, firstElementOnly) {\n  const handle = state.index ? delay : add\n  const children = parent.children\n  let elements = 0\n  let index = -1\n  /** @type {Record<string, number>} */\n  const types = {}\n  /** @type {Array<Function>} */\n  const delayed = []\n\n  // Start looking at `from`\n  if (from === undefined || from === null) from = 0\n\n  // Exit if there are no further nodes.\n  if (from >= children.length) return\n\n  // If we need to index for types, do so for all elements before `from`.\n  if (state.index) {\n    while (++index < from) {\n      const child = children[index]\n      if (element(child)) count(child.tagName)\n    }\n  }\n\n  index = from - 1\n\n  while (++index < children.length) {\n    const child = children[index]\n    // Only check elements.\n    // Check either all elements, or only check the first sibling\n    if (element(child)) {\n      handle(child, index)\n\n      // Stop if we’re looking for one node and it’s already found.\n      if (state.one && state.found) return\n      if (firstElementOnly) break\n    }\n  }\n\n  if (state.index) {\n    index = -1\n\n    while (++index < delayed.length) {\n      delayed[index]()\n      if (state.one && state.found) return\n    }\n  }\n\n  /**\n   * @param {Element} node\n   * @param {number} childIndex\n   */\n  function delay(node, childIndex) {\n    const elementsBefore = elements\n    const elementsByTypeBefore = own.call(types, node.tagName)\n      ? types[node.tagName]\n      : 0\n\n    count(node.tagName)\n\n    delayed.push(fn)\n\n    function fn() {\n      // Before counting further elements:\n      state.elementIndex = elementsBefore\n      state.typeIndex = elementsByTypeBefore\n\n      // After counting all elements.\n      state.elementCount = elements\n      state.typeCount = types[node.tagName]\n\n      add(node, childIndex)\n    }\n  }\n\n  /**\n   * @param {Element} node\n   * @param {number} childIndex\n   */\n  function add(node, childIndex) {\n    const exit = enterState(state, node)\n\n    // Shouldn’t happen.\n    /* c8 ignore next 3 */\n    if (!state.iterator) {\n      throw new Error('Expected `iterator`')\n    }\n\n    state.iterator(query, node, childIndex, parent, state)\n    exit()\n  }\n\n  /**\n   * @param {string} name\n   */\n  function count(name) {\n    if (!own.call(types, name)) types[name] = 0\n    elements++\n    types[name]++\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
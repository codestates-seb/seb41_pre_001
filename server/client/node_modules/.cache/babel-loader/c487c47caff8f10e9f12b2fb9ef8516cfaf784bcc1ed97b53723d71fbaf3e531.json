{"ast":null,"code":"import _toConsumableArray from \"/home/kty/workspace/seb41_pre_001/client/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\n/**\n * @typedef {import('micromark-util-types').Encoding} Encoding\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').ParseOptions} ParseOptions\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Value} Value\n * @typedef {import('unist').Parent} UnistParent\n * @typedef {import('unist').Point} Point\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').Content} Content\n * @typedef {Root|Content} Node\n * @typedef {Extract<Node, UnistParent>} Parent\n * @typedef {import('mdast').Break} Break\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('mdast').Code} Code\n * @typedef {import('mdast').Definition} Definition\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('mdast').HTML} HTML\n * @typedef {import('mdast').Image} Image\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('mdast').Link} Link\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('mdast').List} List\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('mdast').Text} Text\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n *\n * @typedef {UnistParent & {type: 'fragment', children: Array<PhrasingContent>}} Fragment\n */\n\n/**\n * @typedef _CompileDataFields\n * @property {boolean|undefined} expectingFirstListItemValue\n * @property {boolean|undefined} flowCodeInside\n * @property {boolean|undefined} setextHeadingSlurpLineEnding\n * @property {boolean|undefined} atHardBreak\n * @property {'collapsed'|'full'} referenceType\n * @property {boolean|undefined} inReference\n * @property {'characterReferenceMarkerHexadecimal'|'characterReferenceMarkerNumeric'} characterReferenceType\n *\n * @typedef {Record<string, unknown> & Partial<_CompileDataFields>} CompileData\n *\n * @typedef {(tree: Root) => Root|void} Transform\n * @typedef {(this: CompileContext, token: Token) => void} Handle\n * @typedef {Record<string, Handle>} Handles\n *   Token types mapping to handles\n * @typedef {Record<string, Record<string, unknown>|Array<unknown>> & {canContainEols: Array<string>, transforms: Array<Transform>, enter: Handles, exit: Handles}} NormalizedExtension\n * @typedef {Partial<NormalizedExtension>} Extension\n *   An mdast extension changes how markdown tokens are turned into mdast.\n *\n * @typedef {(this: Omit<CompileContext, 'sliceSerialize'>, left: Token|undefined, right: Token) => void} OnEnterError\n * @typedef {(this: Omit<CompileContext, 'sliceSerialize'>, left: Token, right: Token) => void} OnExitError\n *\n * @typedef CompileContext\n *   mdast compiler context\n * @property {Array<Node | Fragment>} stack\n * @property {Array<[Token, OnEnterError|undefined]>} tokenStack\n * @property {(key: string, value?: unknown) => void} setData\n *   Set data into the key-value store.\n * @property {<K extends string>(key: K) => CompileData[K]} getData\n *   Get data from the key-value store.\n * @property {(this: CompileContext) => void} buffer\n *   Capture some of the output data.\n * @property {(this: CompileContext) => string} resume\n *   Stop capturing and access the output data.\n * @property {<N extends Node>(this: CompileContext, node: N, token: Token, onError?: OnEnterError) => N} enter\n *   Enter a token.\n * @property {(this: CompileContext, token: Token, onError?: OnExitError) => Node} exit\n *   Exit a token.\n * @property {TokenizeContext['sliceSerialize']} sliceSerialize\n *   Get the string value of a token.\n * @property {NormalizedExtension} config\n *   Configuration.\n *\n * @typedef {{mdastExtensions?: Array<Extension|Array<Extension>>}} FromMarkdownOptions\n * @typedef {ParseOptions & FromMarkdownOptions} Options\n */\nimport { toString } from 'mdast-util-to-string';\nimport { parse } from 'micromark/lib/parse.js';\nimport { preprocess } from 'micromark/lib/preprocess.js';\nimport { postprocess } from 'micromark/lib/postprocess.js';\nimport { decodeNumericCharacterReference } from 'micromark-util-decode-numeric-character-reference';\nimport { decodeString } from 'micromark-util-decode-string';\nimport { normalizeIdentifier } from 'micromark-util-normalize-identifier';\nimport { decodeNamedCharacterReference } from 'decode-named-character-reference';\nimport { stringifyPosition } from 'unist-util-stringify-position';\nvar own = {}.hasOwnProperty;\n/**\n * @param value Markdown to parse (`string` or `Buffer`).\n * @param [encoding] Character encoding to understand `value` as when itâ€™s a `Buffer` (`string`, default: `'utf8'`).\n * @param [options] Configuration\n */\n\nexport var fromMarkdown =\n/**\n * @type {(\n *   ((value: Value, encoding: Encoding, options?: Options) => Root) &\n *   ((value: Value, options?: Options) => Root)\n * )}\n */\n\n/**\n * @param {Value} value\n * @param {Encoding} [encoding]\n * @param {Options} [options]\n * @returns {Root}\n */\nfunction fromMarkdown(value, encoding, options) {\n  if (typeof encoding !== 'string') {\n    options = encoding;\n    encoding = undefined;\n  }\n  return compiler(options)(postprocess(parse(options).document().write(preprocess()(value, encoding, true))));\n};\n/**\n * Note this compiler only understand complete buffering, not streaming.\n *\n * @param {Options} [options]\n */\n\nfunction compiler() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  /** @type {NormalizedExtension} */\n  // @ts-expect-error: our base has all required fields, so the result will too.\n  var config = configure({\n    transforms: [],\n    canContainEols: ['emphasis', 'fragment', 'heading', 'paragraph', 'strong'],\n    enter: {\n      autolink: opener(link),\n      autolinkProtocol: onenterdata,\n      autolinkEmail: onenterdata,\n      atxHeading: opener(heading),\n      blockQuote: opener(blockQuote),\n      characterEscape: onenterdata,\n      characterReference: onenterdata,\n      codeFenced: opener(codeFlow),\n      codeFencedFenceInfo: buffer,\n      codeFencedFenceMeta: buffer,\n      codeIndented: opener(codeFlow, buffer),\n      codeText: opener(codeText, buffer),\n      codeTextData: onenterdata,\n      data: onenterdata,\n      codeFlowValue: onenterdata,\n      definition: opener(definition),\n      definitionDestinationString: buffer,\n      definitionLabelString: buffer,\n      definitionTitleString: buffer,\n      emphasis: opener(emphasis),\n      hardBreakEscape: opener(hardBreak),\n      hardBreakTrailing: opener(hardBreak),\n      htmlFlow: opener(html, buffer),\n      htmlFlowData: onenterdata,\n      htmlText: opener(html, buffer),\n      htmlTextData: onenterdata,\n      image: opener(image),\n      label: buffer,\n      link: opener(link),\n      listItem: opener(listItem),\n      listItemValue: onenterlistitemvalue,\n      listOrdered: opener(list, onenterlistordered),\n      listUnordered: opener(list),\n      paragraph: opener(paragraph),\n      reference: onenterreference,\n      referenceString: buffer,\n      resourceDestinationString: buffer,\n      resourceTitleString: buffer,\n      setextHeading: opener(heading),\n      strong: opener(strong),\n      thematicBreak: opener(thematicBreak)\n    },\n    exit: {\n      atxHeading: closer(),\n      atxHeadingSequence: onexitatxheadingsequence,\n      autolink: closer(),\n      autolinkEmail: onexitautolinkemail,\n      autolinkProtocol: onexitautolinkprotocol,\n      blockQuote: closer(),\n      characterEscapeValue: onexitdata,\n      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\n      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\n      characterReferenceValue: onexitcharacterreferencevalue,\n      codeFenced: closer(onexitcodefenced),\n      codeFencedFence: onexitcodefencedfence,\n      codeFencedFenceInfo: onexitcodefencedfenceinfo,\n      codeFencedFenceMeta: onexitcodefencedfencemeta,\n      codeFlowValue: onexitdata,\n      codeIndented: closer(onexitcodeindented),\n      codeText: closer(onexitcodetext),\n      codeTextData: onexitdata,\n      data: onexitdata,\n      definition: closer(),\n      definitionDestinationString: onexitdefinitiondestinationstring,\n      definitionLabelString: onexitdefinitionlabelstring,\n      definitionTitleString: onexitdefinitiontitlestring,\n      emphasis: closer(),\n      hardBreakEscape: closer(onexithardbreak),\n      hardBreakTrailing: closer(onexithardbreak),\n      htmlFlow: closer(onexithtmlflow),\n      htmlFlowData: onexitdata,\n      htmlText: closer(onexithtmltext),\n      htmlTextData: onexitdata,\n      image: closer(onexitimage),\n      label: onexitlabel,\n      labelText: onexitlabeltext,\n      lineEnding: onexitlineending,\n      link: closer(onexitlink),\n      listItem: closer(),\n      listOrdered: closer(),\n      listUnordered: closer(),\n      paragraph: closer(),\n      referenceString: onexitreferencestring,\n      resourceDestinationString: onexitresourcedestinationstring,\n      resourceTitleString: onexitresourcetitlestring,\n      resource: onexitresource,\n      setextHeading: closer(onexitsetextheading),\n      setextHeadingLineSequence: onexitsetextheadinglinesequence,\n      setextHeadingText: onexitsetextheadingtext,\n      strong: closer(),\n      thematicBreak: closer()\n    }\n  }, options.mdastExtensions || []);\n  /** @type {CompileData} */\n\n  var data = {};\n  return compile;\n  /**\n   * @param {Array<Event>} events\n   * @returns {Root}\n   */\n\n  function compile(events) {\n    /** @type {Root} */\n    var tree = {\n      type: 'root',\n      children: []\n    };\n    /** @type {CompileContext['stack']} */\n\n    var stack = [tree];\n    /** @type {CompileContext['tokenStack']} */\n\n    var tokenStack = [];\n    /** @type {Array<number>} */\n\n    var listStack = [];\n    /** @type {Omit<CompileContext, 'sliceSerialize'>} */\n\n    var context = {\n      stack: stack,\n      tokenStack: tokenStack,\n      config: config,\n      enter: enter,\n      exit: exit,\n      buffer: buffer,\n      resume: resume,\n      setData: setData,\n      getData: getData\n    };\n    var index = -1;\n    while (++index < events.length) {\n      // We preprocess lists to add `listItem` tokens, and to infer whether\n      // items the list itself are spread out.\n      if (events[index][1].type === 'listOrdered' || events[index][1].type === 'listUnordered') {\n        if (events[index][0] === 'enter') {\n          listStack.push(index);\n        } else {\n          var tail = listStack.pop();\n          index = prepareList(events, tail, index);\n        }\n      }\n    }\n    index = -1;\n    while (++index < events.length) {\n      var handler = config[events[index][0]];\n      if (own.call(handler, events[index][1].type)) {\n        handler[events[index][1].type].call(Object.assign({\n          sliceSerialize: events[index][2].sliceSerialize\n        }, context), events[index][1]);\n      }\n    }\n    if (tokenStack.length > 0) {\n      var _tail = tokenStack[tokenStack.length - 1];\n      var _handler = _tail[1] || defaultOnError;\n      _handler.call(context, undefined, _tail[0]);\n    } // Figure out `root` position.\n\n    tree.position = {\n      start: point(events.length > 0 ? events[0][1].start : {\n        line: 1,\n        column: 1,\n        offset: 0\n      }),\n      end: point(events.length > 0 ? events[events.length - 2][1].end : {\n        line: 1,\n        column: 1,\n        offset: 0\n      })\n    };\n    index = -1;\n    while (++index < config.transforms.length) {\n      tree = config.transforms[index](tree) || tree;\n    }\n    return tree;\n  }\n  /**\n   * @param {Array<Event>} events\n   * @param {number} start\n   * @param {number} length\n   * @returns {number}\n   */\n\n  function prepareList(events, start, length) {\n    var index = start - 1;\n    var containerBalance = -1;\n    var listSpread = false;\n    /** @type {Token|undefined} */\n\n    var listItem;\n    /** @type {number|undefined} */\n\n    var lineIndex;\n    /** @type {number|undefined} */\n\n    var firstBlankLineIndex;\n    /** @type {boolean|undefined} */\n\n    var atMarker;\n    while (++index <= length) {\n      var event = events[index];\n      if (event[1].type === 'listUnordered' || event[1].type === 'listOrdered' || event[1].type === 'blockQuote') {\n        if (event[0] === 'enter') {\n          containerBalance++;\n        } else {\n          containerBalance--;\n        }\n        atMarker = undefined;\n      } else if (event[1].type === 'lineEndingBlank') {\n        if (event[0] === 'enter') {\n          if (listItem && !atMarker && !containerBalance && !firstBlankLineIndex) {\n            firstBlankLineIndex = index;\n          }\n          atMarker = undefined;\n        }\n      } else if (event[1].type === 'linePrefix' || event[1].type === 'listItemValue' || event[1].type === 'listItemMarker' || event[1].type === 'listItemPrefix' || event[1].type === 'listItemPrefixWhitespace') {\n        // Empty.\n      } else {\n        atMarker = undefined;\n      }\n      if (!containerBalance && event[0] === 'enter' && event[1].type === 'listItemPrefix' || containerBalance === -1 && event[0] === 'exit' && (event[1].type === 'listUnordered' || event[1].type === 'listOrdered')) {\n        if (listItem) {\n          var tailIndex = index;\n          lineIndex = undefined;\n          while (tailIndex--) {\n            var tailEvent = events[tailIndex];\n            if (tailEvent[1].type === 'lineEnding' || tailEvent[1].type === 'lineEndingBlank') {\n              if (tailEvent[0] === 'exit') continue;\n              if (lineIndex) {\n                events[lineIndex][1].type = 'lineEndingBlank';\n                listSpread = true;\n              }\n              tailEvent[1].type = 'lineEnding';\n              lineIndex = tailIndex;\n            } else if (tailEvent[1].type === 'linePrefix' || tailEvent[1].type === 'blockQuotePrefix' || tailEvent[1].type === 'blockQuotePrefixWhitespace' || tailEvent[1].type === 'blockQuoteMarker' || tailEvent[1].type === 'listItemIndent') {\n              // Empty\n            } else {\n              break;\n            }\n          }\n          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {\n            // @ts-expect-error Patched.\n            listItem._spread = true;\n          } // Fix position.\n\n          listItem.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);\n          events.splice(lineIndex || index, 0, ['exit', listItem, event[2]]);\n          index++;\n          length++;\n        } // Create a new list item.\n\n        if (event[1].type === 'listItemPrefix') {\n          listItem = {\n            type: 'listItem',\n            // @ts-expect-error Patched\n            _spread: false,\n            start: Object.assign({}, event[1].start)\n          }; // @ts-expect-error: `listItem` is most definitely defined, TS...\n\n          events.splice(index, 0, ['enter', listItem, event[2]]);\n          index++;\n          length++;\n          firstBlankLineIndex = undefined;\n          atMarker = true;\n        }\n      }\n    } // @ts-expect-error Patched.\n\n    events[start][1]._spread = listSpread;\n    return length;\n  }\n  /**\n   * @type {CompileContext['setData']}\n   * @param [value]\n   */\n\n  function setData(key, value) {\n    data[key] = value;\n  }\n  /**\n   * @type {CompileContext['getData']}\n   * @template {string} K\n   * @param {K} key\n   * @returns {CompileData[K]}\n   */\n\n  function getData(key) {\n    return data[key];\n  }\n  /**\n   * @param {Point} d\n   * @returns {Point}\n   */\n\n  function point(d) {\n    return {\n      line: d.line,\n      column: d.column,\n      offset: d.offset\n    };\n  }\n  /**\n   * @param {(token: Token) => Node} create\n   * @param {Handle} [and]\n   * @returns {Handle}\n   */\n\n  function opener(create, and) {\n    return open;\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {void}\n     */\n\n    function open(token) {\n      enter.call(this, create(token), token);\n      if (and) and.call(this, token);\n    }\n  }\n  /** @type {CompileContext['buffer']} */\n\n  function buffer() {\n    this.stack.push({\n      type: 'fragment',\n      children: []\n    });\n  }\n  /**\n   * @type {CompileContext['enter']}\n   * @template {Node} N\n   * @this {CompileContext}\n   * @param {N} node\n   * @param {Token} token\n   * @param {OnEnterError} [errorHandler]\n   * @returns {N}\n   */\n\n  function enter(node, token, errorHandler) {\n    var parent = this.stack[this.stack.length - 1];\n    // @ts-expect-error: Assume `Node` can exist as a child of `parent`.\n    parent.children.push(node);\n    this.stack.push(node);\n    this.tokenStack.push([token, errorHandler]); // @ts-expect-error: `end` will be patched later.\n\n    node.position = {\n      start: point(token.start)\n    };\n    return node;\n  }\n  /**\n   * @param {Handle} [and]\n   * @returns {Handle}\n   */\n\n  function closer(and) {\n    return close;\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {void}\n     */\n\n    function close(token) {\n      if (and) and.call(this, token);\n      exit.call(this, token);\n    }\n  }\n  /**\n   * @type {CompileContext['exit']}\n   * @this {CompileContext}\n   * @param {Token} token\n   * @param {OnExitError} [onExitError]\n   * @returns {Node}\n   */\n\n  function exit(token, onExitError) {\n    var node = this.stack.pop();\n    var open = this.tokenStack.pop();\n    if (!open) {\n      throw new Error('Cannot close `' + token.type + '` (' + stringifyPosition({\n        start: token.start,\n        end: token.end\n      }) + '): itâ€™s not open');\n    } else if (open[0].type !== token.type) {\n      if (onExitError) {\n        onExitError.call(this, token, open[0]);\n      } else {\n        var handler = open[1] || defaultOnError;\n        handler.call(this, token, open[0]);\n      }\n    }\n    node.position.end = point(token.end);\n    return node;\n  }\n  /**\n   * @this {CompileContext}\n   * @returns {string}\n   */\n\n  function resume() {\n    return toString(this.stack.pop());\n  } //\n  // Handlers.\n  //\n\n  /** @type {Handle} */\n\n  function onenterlistordered() {\n    setData('expectingFirstListItemValue', true);\n  }\n  /** @type {Handle} */\n\n  function onenterlistitemvalue(token) {\n    if (getData('expectingFirstListItemValue')) {\n      var ancestor = /** @type {List} */\n      this.stack[this.stack.length - 2];\n      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);\n      setData('expectingFirstListItemValue');\n    }\n  }\n  /** @type {Handle} */\n\n  function onexitcodefencedfenceinfo() {\n    var data = this.resume();\n    var node = /** @type {Code} */\n    this.stack[this.stack.length - 1];\n    node.lang = data;\n  }\n  /** @type {Handle} */\n\n  function onexitcodefencedfencemeta() {\n    var data = this.resume();\n    var node = /** @type {Code} */\n    this.stack[this.stack.length - 1];\n    node.meta = data;\n  }\n  /** @type {Handle} */\n\n  function onexitcodefencedfence() {\n    // Exit if this is the closing fence.\n    if (getData('flowCodeInside')) return;\n    this.buffer();\n    setData('flowCodeInside', true);\n  }\n  /** @type {Handle} */\n\n  function onexitcodefenced() {\n    var data = this.resume();\n    var node = /** @type {Code} */\n    this.stack[this.stack.length - 1];\n    node.value = data.replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '');\n    setData('flowCodeInside');\n  }\n  /** @type {Handle} */\n\n  function onexitcodeindented() {\n    var data = this.resume();\n    var node = /** @type {Code} */\n    this.stack[this.stack.length - 1];\n    node.value = data.replace(/(\\r?\\n|\\r)$/g, '');\n  }\n  /** @type {Handle} */\n\n  function onexitdefinitionlabelstring(token) {\n    // Discard label, use the source content instead.\n    var label = this.resume();\n    var node = /** @type {Definition} */\n    this.stack[this.stack.length - 1];\n    node.label = label;\n    node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();\n  }\n  /** @type {Handle} */\n\n  function onexitdefinitiontitlestring() {\n    var data = this.resume();\n    var node = /** @type {Definition} */\n    this.stack[this.stack.length - 1];\n    node.title = data;\n  }\n  /** @type {Handle} */\n\n  function onexitdefinitiondestinationstring() {\n    var data = this.resume();\n    var node = /** @type {Definition} */\n    this.stack[this.stack.length - 1];\n    node.url = data;\n  }\n  /** @type {Handle} */\n\n  function onexitatxheadingsequence(token) {\n    var node = /** @type {Heading} */\n    this.stack[this.stack.length - 1];\n    if (!node.depth) {\n      var depth = this.sliceSerialize(token).length;\n      node.depth = depth;\n    }\n  }\n  /** @type {Handle} */\n\n  function onexitsetextheadingtext() {\n    setData('setextHeadingSlurpLineEnding', true);\n  }\n  /** @type {Handle} */\n\n  function onexitsetextheadinglinesequence(token) {\n    var node = /** @type {Heading} */\n    this.stack[this.stack.length - 1];\n    node.depth = this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2;\n  }\n  /** @type {Handle} */\n\n  function onexitsetextheading() {\n    setData('setextHeadingSlurpLineEnding');\n  }\n  /** @type {Handle} */\n\n  function onenterdata(token) {\n    var parent = /** @type {Parent} */\n    this.stack[this.stack.length - 1];\n    /** @type {Node} */\n\n    var tail = parent.children[parent.children.length - 1];\n    if (!tail || tail.type !== 'text') {\n      // Add a new text node.\n      tail = text(); // @ts-expect-error: weâ€™ll add `end` later.\n\n      tail.position = {\n        start: point(token.start)\n      }; // @ts-expect-error: Assume `parent` accepts `text`.\n\n      parent.children.push(tail);\n    }\n    this.stack.push(tail);\n  }\n  /** @type {Handle} */\n\n  function onexitdata(token) {\n    var tail = this.stack.pop();\n    tail.value += this.sliceSerialize(token);\n    tail.position.end = point(token.end);\n  }\n  /** @type {Handle} */\n\n  function onexitlineending(token) {\n    var context = this.stack[this.stack.length - 1];\n\n    // If weâ€™re at a hard break, include the line ending in there.\n    if (getData('atHardBreak')) {\n      var tail = context.children[context.children.length - 1];\n      tail.position.end = point(token.end);\n      setData('atHardBreak');\n      return;\n    }\n    if (!getData('setextHeadingSlurpLineEnding') && config.canContainEols.includes(context.type)) {\n      onenterdata.call(this, token);\n      onexitdata.call(this, token);\n    }\n  }\n  /** @type {Handle} */\n\n  function onexithardbreak() {\n    setData('atHardBreak', true);\n  }\n  /** @type {Handle} */\n\n  function onexithtmlflow() {\n    var data = this.resume();\n    var node = /** @type {HTML} */\n    this.stack[this.stack.length - 1];\n    node.value = data;\n  }\n  /** @type {Handle} */\n\n  function onexithtmltext() {\n    var data = this.resume();\n    var node = /** @type {HTML} */\n    this.stack[this.stack.length - 1];\n    node.value = data;\n  }\n  /** @type {Handle} */\n\n  function onexitcodetext() {\n    var data = this.resume();\n    var node = /** @type {InlineCode} */\n    this.stack[this.stack.length - 1];\n    node.value = data;\n  }\n  /** @type {Handle} */\n\n  function onexitlink() {\n    var context = /** @type {Link & {identifier: string, label: string}} */\n    this.stack[this.stack.length - 1]; // To do: clean.\n\n    if (getData('inReference')) {\n      context.type += 'Reference'; // @ts-expect-error: mutate.\n\n      context.referenceType = getData('referenceType') || 'shortcut'; // @ts-expect-error: mutate.\n\n      delete context.url;\n      delete context.title;\n    } else {\n      // @ts-expect-error: mutate.\n      delete context.identifier; // @ts-expect-error: mutate.\n\n      delete context.label;\n    }\n    setData('referenceType');\n  }\n  /** @type {Handle} */\n\n  function onexitimage() {\n    var context = /** @type {Image & {identifier: string, label: string}} */\n    this.stack[this.stack.length - 1]; // To do: clean.\n\n    if (getData('inReference')) {\n      context.type += 'Reference'; // @ts-expect-error: mutate.\n\n      context.referenceType = getData('referenceType') || 'shortcut'; // @ts-expect-error: mutate.\n\n      delete context.url;\n      delete context.title;\n    } else {\n      // @ts-expect-error: mutate.\n      delete context.identifier; // @ts-expect-error: mutate.\n\n      delete context.label;\n    }\n    setData('referenceType');\n  }\n  /** @type {Handle} */\n\n  function onexitlabeltext(token) {\n    var ancestor = /** @type {(Link|Image) & {identifier: string, label: string}} */\n    this.stack[this.stack.length - 2];\n    var string = this.sliceSerialize(token);\n    ancestor.label = decodeString(string);\n    ancestor.identifier = normalizeIdentifier(string).toLowerCase();\n  }\n  /** @type {Handle} */\n\n  function onexitlabel() {\n    var fragment = /** @type {Fragment} */\n    this.stack[this.stack.length - 1];\n    var value = this.resume();\n    var node = /** @type {(Link|Image) & {identifier: string, label: string}} */\n    this.stack[this.stack.length - 1]; // Assume a reference.\n\n    setData('inReference', true);\n    if (node.type === 'link') {\n      // @ts-expect-error: Assume static phrasing content.\n      node.children = fragment.children;\n    } else {\n      node.alt = value;\n    }\n  }\n  /** @type {Handle} */\n\n  function onexitresourcedestinationstring() {\n    var data = this.resume();\n    var node = /** @type {Link|Image} */\n    this.stack[this.stack.length - 1];\n    node.url = data;\n  }\n  /** @type {Handle} */\n\n  function onexitresourcetitlestring() {\n    var data = this.resume();\n    var node = /** @type {Link|Image} */\n    this.stack[this.stack.length - 1];\n    node.title = data;\n  }\n  /** @type {Handle} */\n\n  function onexitresource() {\n    setData('inReference');\n  }\n  /** @type {Handle} */\n\n  function onenterreference() {\n    setData('referenceType', 'collapsed');\n  }\n  /** @type {Handle} */\n\n  function onexitreferencestring(token) {\n    var label = this.resume();\n    var node = /** @type {LinkReference|ImageReference} */\n    this.stack[this.stack.length - 1];\n    node.label = label;\n    node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();\n    setData('referenceType', 'full');\n  }\n  /** @type {Handle} */\n\n  function onexitcharacterreferencemarker(token) {\n    setData('characterReferenceType', token.type);\n  }\n  /** @type {Handle} */\n\n  function onexitcharacterreferencevalue(token) {\n    var data = this.sliceSerialize(token);\n    var type = getData('characterReferenceType');\n    /** @type {string} */\n\n    var value;\n    if (type) {\n      value = decodeNumericCharacterReference(data, type === 'characterReferenceMarkerNumeric' ? 10 : 16);\n      setData('characterReferenceType');\n    } else {\n      // @ts-expect-error `decodeNamedCharacterReference` can return false for\n      // invalid named character references, but everything weâ€™ve tokenized is\n      // valid.\n      value = decodeNamedCharacterReference(data);\n    }\n    var tail = this.stack.pop();\n    tail.value += value;\n    tail.position.end = point(token.end);\n  }\n  /** @type {Handle} */\n\n  function onexitautolinkprotocol(token) {\n    onexitdata.call(this, token);\n    var node = /** @type {Link} */\n    this.stack[this.stack.length - 1];\n    node.url = this.sliceSerialize(token);\n  }\n  /** @type {Handle} */\n\n  function onexitautolinkemail(token) {\n    onexitdata.call(this, token);\n    var node = /** @type {Link} */\n    this.stack[this.stack.length - 1];\n    node.url = 'mailto:' + this.sliceSerialize(token);\n  } //\n  // Creaters.\n  //\n\n  /** @returns {Blockquote} */\n\n  function blockQuote() {\n    return {\n      type: 'blockquote',\n      children: []\n    };\n  }\n  /** @returns {Code} */\n\n  function codeFlow() {\n    return {\n      type: 'code',\n      lang: null,\n      meta: null,\n      value: ''\n    };\n  }\n  /** @returns {InlineCode} */\n\n  function codeText() {\n    return {\n      type: 'inlineCode',\n      value: ''\n    };\n  }\n  /** @returns {Definition} */\n\n  function definition() {\n    return {\n      type: 'definition',\n      identifier: '',\n      label: null,\n      title: null,\n      url: ''\n    };\n  }\n  /** @returns {Emphasis} */\n\n  function emphasis() {\n    return {\n      type: 'emphasis',\n      children: []\n    };\n  }\n  /** @returns {Heading} */\n\n  function heading() {\n    // @ts-expect-error `depth` will be set later.\n    return {\n      type: 'heading',\n      depth: undefined,\n      children: []\n    };\n  }\n  /** @returns {Break} */\n\n  function hardBreak() {\n    return {\n      type: 'break'\n    };\n  }\n  /** @returns {HTML} */\n\n  function html() {\n    return {\n      type: 'html',\n      value: ''\n    };\n  }\n  /** @returns {Image} */\n\n  function image() {\n    return {\n      type: 'image',\n      title: null,\n      url: '',\n      alt: null\n    };\n  }\n  /** @returns {Link} */\n\n  function link() {\n    return {\n      type: 'link',\n      title: null,\n      url: '',\n      children: []\n    };\n  }\n  /**\n   * @param {Token} token\n   * @returns {List}\n   */\n\n  function list(token) {\n    return {\n      type: 'list',\n      ordered: token.type === 'listOrdered',\n      start: null,\n      // @ts-expect-error Patched.\n      spread: token._spread,\n      children: []\n    };\n  }\n  /**\n   * @param {Token} token\n   * @returns {ListItem}\n   */\n\n  function listItem(token) {\n    return {\n      type: 'listItem',\n      // @ts-expect-error Patched.\n      spread: token._spread,\n      checked: null,\n      children: []\n    };\n  }\n  /** @returns {Paragraph} */\n\n  function paragraph() {\n    return {\n      type: 'paragraph',\n      children: []\n    };\n  }\n  /** @returns {Strong} */\n\n  function strong() {\n    return {\n      type: 'strong',\n      children: []\n    };\n  }\n  /** @returns {Text} */\n\n  function text() {\n    return {\n      type: 'text',\n      value: ''\n    };\n  }\n  /** @returns {ThematicBreak} */\n\n  function thematicBreak() {\n    return {\n      type: 'thematicBreak'\n    };\n  }\n}\n/**\n * @param {Extension} combined\n * @param {Array<Extension|Array<Extension>>} extensions\n * @returns {Extension}\n */\n\nfunction configure(combined, extensions) {\n  var index = -1;\n  while (++index < extensions.length) {\n    var value = extensions[index];\n    if (Array.isArray(value)) {\n      configure(combined, value);\n    } else {\n      extension(combined, value);\n    }\n  }\n  return combined;\n}\n/**\n * @param {Extension} combined\n * @param {Extension} extension\n * @returns {void}\n */\n\nfunction extension(combined, extension) {\n  /** @type {string} */\n  var key;\n  for (key in extension) {\n    if (own.call(extension, key)) {\n      var list = key === 'canContainEols' || key === 'transforms';\n      var maybe = own.call(combined, key) ? combined[key] : undefined;\n      /* c8 ignore next */\n\n      var left = maybe || (combined[key] = list ? [] : {});\n      var right = extension[key];\n      if (right) {\n        if (list) {\n          // @ts-expect-error: `left` is an array.\n          combined[key] = [].concat(_toConsumableArray(left), _toConsumableArray(right));\n        } else {\n          Object.assign(left, right);\n        }\n      }\n    }\n  }\n}\n/** @type {OnEnterError} */\n\nfunction defaultOnError(left, right) {\n  if (left) {\n    throw new Error('Cannot close `' + left.type + '` (' + stringifyPosition({\n      start: left.start,\n      end: left.end\n    }) + '): a different token (`' + right.type + '`, ' + stringifyPosition({\n      start: right.start,\n      end: right.end\n    }) + ') is open');\n  } else {\n    throw new Error('Cannot close document, a token (`' + right.type + '`, ' + stringifyPosition({\n      start: right.start,\n      end: right.end\n    }) + ') is still open');\n  }\n}","map":{"version":3,"names":["toString","parse","preprocess","postprocess","decodeNumericCharacterReference","decodeString","normalizeIdentifier","decodeNamedCharacterReference","stringifyPosition","own","hasOwnProperty","fromMarkdown","value","encoding","options","undefined","compiler","document","write","config","configure","transforms","canContainEols","enter","autolink","opener","link","autolinkProtocol","onenterdata","autolinkEmail","atxHeading","heading","blockQuote","characterEscape","characterReference","codeFenced","codeFlow","codeFencedFenceInfo","buffer","codeFencedFenceMeta","codeIndented","codeText","codeTextData","data","codeFlowValue","definition","definitionDestinationString","definitionLabelString","definitionTitleString","emphasis","hardBreakEscape","hardBreak","hardBreakTrailing","htmlFlow","html","htmlFlowData","htmlText","htmlTextData","image","label","listItem","listItemValue","onenterlistitemvalue","listOrdered","list","onenterlistordered","listUnordered","paragraph","reference","onenterreference","referenceString","resourceDestinationString","resourceTitleString","setextHeading","strong","thematicBreak","exit","closer","atxHeadingSequence","onexitatxheadingsequence","onexitautolinkemail","onexitautolinkprotocol","characterEscapeValue","onexitdata","characterReferenceMarkerHexadecimal","onexitcharacterreferencemarker","characterReferenceMarkerNumeric","characterReferenceValue","onexitcharacterreferencevalue","onexitcodefenced","codeFencedFence","onexitcodefencedfence","onexitcodefencedfenceinfo","onexitcodefencedfencemeta","onexitcodeindented","onexitcodetext","onexitdefinitiondestinationstring","onexitdefinitionlabelstring","onexitdefinitiontitlestring","onexithardbreak","onexithtmlflow","onexithtmltext","onexitimage","onexitlabel","labelText","onexitlabeltext","lineEnding","onexitlineending","onexitlink","onexitreferencestring","onexitresourcedestinationstring","onexitresourcetitlestring","resource","onexitresource","onexitsetextheading","setextHeadingLineSequence","onexitsetextheadinglinesequence","setextHeadingText","onexitsetextheadingtext","mdastExtensions","compile","events","tree","type","children","stack","tokenStack","listStack","context","resume","setData","getData","index","length","push","tail","pop","prepareList","handler","call","Object","assign","sliceSerialize","defaultOnError","position","start","point","line","column","offset","end","containerBalance","listSpread","lineIndex","firstBlankLineIndex","atMarker","event","tailIndex","tailEvent","_spread","splice","key","d","create","and","open","token","node","errorHandler","parent","close","onExitError","Error","ancestor","Number","parseInt","lang","meta","replace","identifier","toLowerCase","title","url","depth","charCodeAt","text","includes","referenceType","string","fragment","alt","ordered","spread","checked","combined","extensions","Array","isArray","extension","maybe","left","right"],"sources":["/home/kty/workspace/seb41_pre_001/client/node_modules/mdast-util-from-markdown/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Encoding} Encoding\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').ParseOptions} ParseOptions\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Value} Value\n * @typedef {import('unist').Parent} UnistParent\n * @typedef {import('unist').Point} Point\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').Content} Content\n * @typedef {Root|Content} Node\n * @typedef {Extract<Node, UnistParent>} Parent\n * @typedef {import('mdast').Break} Break\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('mdast').Code} Code\n * @typedef {import('mdast').Definition} Definition\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('mdast').HTML} HTML\n * @typedef {import('mdast').Image} Image\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('mdast').Link} Link\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('mdast').List} List\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('mdast').Text} Text\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n *\n * @typedef {UnistParent & {type: 'fragment', children: Array<PhrasingContent>}} Fragment\n */\n\n/**\n * @typedef _CompileDataFields\n * @property {boolean|undefined} expectingFirstListItemValue\n * @property {boolean|undefined} flowCodeInside\n * @property {boolean|undefined} setextHeadingSlurpLineEnding\n * @property {boolean|undefined} atHardBreak\n * @property {'collapsed'|'full'} referenceType\n * @property {boolean|undefined} inReference\n * @property {'characterReferenceMarkerHexadecimal'|'characterReferenceMarkerNumeric'} characterReferenceType\n *\n * @typedef {Record<string, unknown> & Partial<_CompileDataFields>} CompileData\n *\n * @typedef {(tree: Root) => Root|void} Transform\n * @typedef {(this: CompileContext, token: Token) => void} Handle\n * @typedef {Record<string, Handle>} Handles\n *   Token types mapping to handles\n * @typedef {Record<string, Record<string, unknown>|Array<unknown>> & {canContainEols: Array<string>, transforms: Array<Transform>, enter: Handles, exit: Handles}} NormalizedExtension\n * @typedef {Partial<NormalizedExtension>} Extension\n *   An mdast extension changes how markdown tokens are turned into mdast.\n *\n * @typedef {(this: Omit<CompileContext, 'sliceSerialize'>, left: Token|undefined, right: Token) => void} OnEnterError\n * @typedef {(this: Omit<CompileContext, 'sliceSerialize'>, left: Token, right: Token) => void} OnExitError\n *\n * @typedef CompileContext\n *   mdast compiler context\n * @property {Array<Node | Fragment>} stack\n * @property {Array<[Token, OnEnterError|undefined]>} tokenStack\n * @property {(key: string, value?: unknown) => void} setData\n *   Set data into the key-value store.\n * @property {<K extends string>(key: K) => CompileData[K]} getData\n *   Get data from the key-value store.\n * @property {(this: CompileContext) => void} buffer\n *   Capture some of the output data.\n * @property {(this: CompileContext) => string} resume\n *   Stop capturing and access the output data.\n * @property {<N extends Node>(this: CompileContext, node: N, token: Token, onError?: OnEnterError) => N} enter\n *   Enter a token.\n * @property {(this: CompileContext, token: Token, onError?: OnExitError) => Node} exit\n *   Exit a token.\n * @property {TokenizeContext['sliceSerialize']} sliceSerialize\n *   Get the string value of a token.\n * @property {NormalizedExtension} config\n *   Configuration.\n *\n * @typedef {{mdastExtensions?: Array<Extension|Array<Extension>>}} FromMarkdownOptions\n * @typedef {ParseOptions & FromMarkdownOptions} Options\n */\nimport {toString} from 'mdast-util-to-string'\nimport {parse} from 'micromark/lib/parse.js'\nimport {preprocess} from 'micromark/lib/preprocess.js'\nimport {postprocess} from 'micromark/lib/postprocess.js'\nimport {decodeNumericCharacterReference} from 'micromark-util-decode-numeric-character-reference'\nimport {decodeString} from 'micromark-util-decode-string'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {decodeNamedCharacterReference} from 'decode-named-character-reference'\nimport {stringifyPosition} from 'unist-util-stringify-position'\nconst own = {}.hasOwnProperty\n/**\n * @param value Markdown to parse (`string` or `Buffer`).\n * @param [encoding] Character encoding to understand `value` as when itâ€™s a `Buffer` (`string`, default: `'utf8'`).\n * @param [options] Configuration\n */\n\nexport const fromMarkdown =\n  /**\n   * @type {(\n   *   ((value: Value, encoding: Encoding, options?: Options) => Root) &\n   *   ((value: Value, options?: Options) => Root)\n   * )}\n   */\n\n  /**\n   * @param {Value} value\n   * @param {Encoding} [encoding]\n   * @param {Options} [options]\n   * @returns {Root}\n   */\n  function (value, encoding, options) {\n    if (typeof encoding !== 'string') {\n      options = encoding\n      encoding = undefined\n    }\n\n    return compiler(options)(\n      postprocess(\n        parse(options).document().write(preprocess()(value, encoding, true))\n      )\n    )\n  }\n/**\n * Note this compiler only understand complete buffering, not streaming.\n *\n * @param {Options} [options]\n */\n\nfunction compiler(options = {}) {\n  /** @type {NormalizedExtension} */\n  // @ts-expect-error: our base has all required fields, so the result will too.\n  const config = configure(\n    {\n      transforms: [],\n      canContainEols: [\n        'emphasis',\n        'fragment',\n        'heading',\n        'paragraph',\n        'strong'\n      ],\n      enter: {\n        autolink: opener(link),\n        autolinkProtocol: onenterdata,\n        autolinkEmail: onenterdata,\n        atxHeading: opener(heading),\n        blockQuote: opener(blockQuote),\n        characterEscape: onenterdata,\n        characterReference: onenterdata,\n        codeFenced: opener(codeFlow),\n        codeFencedFenceInfo: buffer,\n        codeFencedFenceMeta: buffer,\n        codeIndented: opener(codeFlow, buffer),\n        codeText: opener(codeText, buffer),\n        codeTextData: onenterdata,\n        data: onenterdata,\n        codeFlowValue: onenterdata,\n        definition: opener(definition),\n        definitionDestinationString: buffer,\n        definitionLabelString: buffer,\n        definitionTitleString: buffer,\n        emphasis: opener(emphasis),\n        hardBreakEscape: opener(hardBreak),\n        hardBreakTrailing: opener(hardBreak),\n        htmlFlow: opener(html, buffer),\n        htmlFlowData: onenterdata,\n        htmlText: opener(html, buffer),\n        htmlTextData: onenterdata,\n        image: opener(image),\n        label: buffer,\n        link: opener(link),\n        listItem: opener(listItem),\n        listItemValue: onenterlistitemvalue,\n        listOrdered: opener(list, onenterlistordered),\n        listUnordered: opener(list),\n        paragraph: opener(paragraph),\n        reference: onenterreference,\n        referenceString: buffer,\n        resourceDestinationString: buffer,\n        resourceTitleString: buffer,\n        setextHeading: opener(heading),\n        strong: opener(strong),\n        thematicBreak: opener(thematicBreak)\n      },\n      exit: {\n        atxHeading: closer(),\n        atxHeadingSequence: onexitatxheadingsequence,\n        autolink: closer(),\n        autolinkEmail: onexitautolinkemail,\n        autolinkProtocol: onexitautolinkprotocol,\n        blockQuote: closer(),\n        characterEscapeValue: onexitdata,\n        characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\n        characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\n        characterReferenceValue: onexitcharacterreferencevalue,\n        codeFenced: closer(onexitcodefenced),\n        codeFencedFence: onexitcodefencedfence,\n        codeFencedFenceInfo: onexitcodefencedfenceinfo,\n        codeFencedFenceMeta: onexitcodefencedfencemeta,\n        codeFlowValue: onexitdata,\n        codeIndented: closer(onexitcodeindented),\n        codeText: closer(onexitcodetext),\n        codeTextData: onexitdata,\n        data: onexitdata,\n        definition: closer(),\n        definitionDestinationString: onexitdefinitiondestinationstring,\n        definitionLabelString: onexitdefinitionlabelstring,\n        definitionTitleString: onexitdefinitiontitlestring,\n        emphasis: closer(),\n        hardBreakEscape: closer(onexithardbreak),\n        hardBreakTrailing: closer(onexithardbreak),\n        htmlFlow: closer(onexithtmlflow),\n        htmlFlowData: onexitdata,\n        htmlText: closer(onexithtmltext),\n        htmlTextData: onexitdata,\n        image: closer(onexitimage),\n        label: onexitlabel,\n        labelText: onexitlabeltext,\n        lineEnding: onexitlineending,\n        link: closer(onexitlink),\n        listItem: closer(),\n        listOrdered: closer(),\n        listUnordered: closer(),\n        paragraph: closer(),\n        referenceString: onexitreferencestring,\n        resourceDestinationString: onexitresourcedestinationstring,\n        resourceTitleString: onexitresourcetitlestring,\n        resource: onexitresource,\n        setextHeading: closer(onexitsetextheading),\n        setextHeadingLineSequence: onexitsetextheadinglinesequence,\n        setextHeadingText: onexitsetextheadingtext,\n        strong: closer(),\n        thematicBreak: closer()\n      }\n    },\n    options.mdastExtensions || []\n  )\n  /** @type {CompileData} */\n\n  const data = {}\n  return compile\n  /**\n   * @param {Array<Event>} events\n   * @returns {Root}\n   */\n\n  function compile(events) {\n    /** @type {Root} */\n    let tree = {\n      type: 'root',\n      children: []\n    }\n    /** @type {CompileContext['stack']} */\n\n    const stack = [tree]\n    /** @type {CompileContext['tokenStack']} */\n\n    const tokenStack = []\n    /** @type {Array<number>} */\n\n    const listStack = []\n    /** @type {Omit<CompileContext, 'sliceSerialize'>} */\n\n    const context = {\n      stack,\n      tokenStack,\n      config,\n      enter,\n      exit,\n      buffer,\n      resume,\n      setData,\n      getData\n    }\n    let index = -1\n\n    while (++index < events.length) {\n      // We preprocess lists to add `listItem` tokens, and to infer whether\n      // items the list itself are spread out.\n      if (\n        events[index][1].type === 'listOrdered' ||\n        events[index][1].type === 'listUnordered'\n      ) {\n        if (events[index][0] === 'enter') {\n          listStack.push(index)\n        } else {\n          const tail = listStack.pop()\n          index = prepareList(events, tail, index)\n        }\n      }\n    }\n\n    index = -1\n\n    while (++index < events.length) {\n      const handler = config[events[index][0]]\n\n      if (own.call(handler, events[index][1].type)) {\n        handler[events[index][1].type].call(\n          Object.assign(\n            {\n              sliceSerialize: events[index][2].sliceSerialize\n            },\n            context\n          ),\n          events[index][1]\n        )\n      }\n    }\n\n    if (tokenStack.length > 0) {\n      const tail = tokenStack[tokenStack.length - 1]\n      const handler = tail[1] || defaultOnError\n      handler.call(context, undefined, tail[0])\n    } // Figure out `root` position.\n\n    tree.position = {\n      start: point(\n        events.length > 0\n          ? events[0][1].start\n          : {\n              line: 1,\n              column: 1,\n              offset: 0\n            }\n      ),\n      end: point(\n        events.length > 0\n          ? events[events.length - 2][1].end\n          : {\n              line: 1,\n              column: 1,\n              offset: 0\n            }\n      )\n    }\n    index = -1\n\n    while (++index < config.transforms.length) {\n      tree = config.transforms[index](tree) || tree\n    }\n\n    return tree\n  }\n  /**\n   * @param {Array<Event>} events\n   * @param {number} start\n   * @param {number} length\n   * @returns {number}\n   */\n\n  function prepareList(events, start, length) {\n    let index = start - 1\n    let containerBalance = -1\n    let listSpread = false\n    /** @type {Token|undefined} */\n\n    let listItem\n    /** @type {number|undefined} */\n\n    let lineIndex\n    /** @type {number|undefined} */\n\n    let firstBlankLineIndex\n    /** @type {boolean|undefined} */\n\n    let atMarker\n\n    while (++index <= length) {\n      const event = events[index]\n\n      if (\n        event[1].type === 'listUnordered' ||\n        event[1].type === 'listOrdered' ||\n        event[1].type === 'blockQuote'\n      ) {\n        if (event[0] === 'enter') {\n          containerBalance++\n        } else {\n          containerBalance--\n        }\n\n        atMarker = undefined\n      } else if (event[1].type === 'lineEndingBlank') {\n        if (event[0] === 'enter') {\n          if (\n            listItem &&\n            !atMarker &&\n            !containerBalance &&\n            !firstBlankLineIndex\n          ) {\n            firstBlankLineIndex = index\n          }\n\n          atMarker = undefined\n        }\n      } else if (\n        event[1].type === 'linePrefix' ||\n        event[1].type === 'listItemValue' ||\n        event[1].type === 'listItemMarker' ||\n        event[1].type === 'listItemPrefix' ||\n        event[1].type === 'listItemPrefixWhitespace'\n      ) {\n        // Empty.\n      } else {\n        atMarker = undefined\n      }\n\n      if (\n        (!containerBalance &&\n          event[0] === 'enter' &&\n          event[1].type === 'listItemPrefix') ||\n        (containerBalance === -1 &&\n          event[0] === 'exit' &&\n          (event[1].type === 'listUnordered' ||\n            event[1].type === 'listOrdered'))\n      ) {\n        if (listItem) {\n          let tailIndex = index\n          lineIndex = undefined\n\n          while (tailIndex--) {\n            const tailEvent = events[tailIndex]\n\n            if (\n              tailEvent[1].type === 'lineEnding' ||\n              tailEvent[1].type === 'lineEndingBlank'\n            ) {\n              if (tailEvent[0] === 'exit') continue\n\n              if (lineIndex) {\n                events[lineIndex][1].type = 'lineEndingBlank'\n                listSpread = true\n              }\n\n              tailEvent[1].type = 'lineEnding'\n              lineIndex = tailIndex\n            } else if (\n              tailEvent[1].type === 'linePrefix' ||\n              tailEvent[1].type === 'blockQuotePrefix' ||\n              tailEvent[1].type === 'blockQuotePrefixWhitespace' ||\n              tailEvent[1].type === 'blockQuoteMarker' ||\n              tailEvent[1].type === 'listItemIndent'\n            ) {\n              // Empty\n            } else {\n              break\n            }\n          }\n\n          if (\n            firstBlankLineIndex &&\n            (!lineIndex || firstBlankLineIndex < lineIndex)\n          ) {\n            // @ts-expect-error Patched.\n            listItem._spread = true\n          } // Fix position.\n\n          listItem.end = Object.assign(\n            {},\n            lineIndex ? events[lineIndex][1].start : event[1].end\n          )\n          events.splice(lineIndex || index, 0, ['exit', listItem, event[2]])\n          index++\n          length++\n        } // Create a new list item.\n\n        if (event[1].type === 'listItemPrefix') {\n          listItem = {\n            type: 'listItem',\n            // @ts-expect-error Patched\n            _spread: false,\n            start: Object.assign({}, event[1].start)\n          } // @ts-expect-error: `listItem` is most definitely defined, TS...\n\n          events.splice(index, 0, ['enter', listItem, event[2]])\n          index++\n          length++\n          firstBlankLineIndex = undefined\n          atMarker = true\n        }\n      }\n    } // @ts-expect-error Patched.\n\n    events[start][1]._spread = listSpread\n    return length\n  }\n  /**\n   * @type {CompileContext['setData']}\n   * @param [value]\n   */\n\n  function setData(key, value) {\n    data[key] = value\n  }\n  /**\n   * @type {CompileContext['getData']}\n   * @template {string} K\n   * @param {K} key\n   * @returns {CompileData[K]}\n   */\n\n  function getData(key) {\n    return data[key]\n  }\n  /**\n   * @param {Point} d\n   * @returns {Point}\n   */\n\n  function point(d) {\n    return {\n      line: d.line,\n      column: d.column,\n      offset: d.offset\n    }\n  }\n  /**\n   * @param {(token: Token) => Node} create\n   * @param {Handle} [and]\n   * @returns {Handle}\n   */\n\n  function opener(create, and) {\n    return open\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {void}\n     */\n\n    function open(token) {\n      enter.call(this, create(token), token)\n      if (and) and.call(this, token)\n    }\n  }\n  /** @type {CompileContext['buffer']} */\n\n  function buffer() {\n    this.stack.push({\n      type: 'fragment',\n      children: []\n    })\n  }\n  /**\n   * @type {CompileContext['enter']}\n   * @template {Node} N\n   * @this {CompileContext}\n   * @param {N} node\n   * @param {Token} token\n   * @param {OnEnterError} [errorHandler]\n   * @returns {N}\n   */\n\n  function enter(node, token, errorHandler) {\n    const parent = this.stack[this.stack.length - 1]\n    // @ts-expect-error: Assume `Node` can exist as a child of `parent`.\n    parent.children.push(node)\n    this.stack.push(node)\n    this.tokenStack.push([token, errorHandler]) // @ts-expect-error: `end` will be patched later.\n\n    node.position = {\n      start: point(token.start)\n    }\n    return node\n  }\n  /**\n   * @param {Handle} [and]\n   * @returns {Handle}\n   */\n\n  function closer(and) {\n    return close\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {void}\n     */\n\n    function close(token) {\n      if (and) and.call(this, token)\n      exit.call(this, token)\n    }\n  }\n  /**\n   * @type {CompileContext['exit']}\n   * @this {CompileContext}\n   * @param {Token} token\n   * @param {OnExitError} [onExitError]\n   * @returns {Node}\n   */\n\n  function exit(token, onExitError) {\n    const node = this.stack.pop()\n    const open = this.tokenStack.pop()\n\n    if (!open) {\n      throw new Error(\n        'Cannot close `' +\n          token.type +\n          '` (' +\n          stringifyPosition({\n            start: token.start,\n            end: token.end\n          }) +\n          '): itâ€™s not open'\n      )\n    } else if (open[0].type !== token.type) {\n      if (onExitError) {\n        onExitError.call(this, token, open[0])\n      } else {\n        const handler = open[1] || defaultOnError\n        handler.call(this, token, open[0])\n      }\n    }\n\n    node.position.end = point(token.end)\n    return node\n  }\n  /**\n   * @this {CompileContext}\n   * @returns {string}\n   */\n\n  function resume() {\n    return toString(this.stack.pop())\n  } //\n  // Handlers.\n  //\n\n  /** @type {Handle} */\n\n  function onenterlistordered() {\n    setData('expectingFirstListItemValue', true)\n  }\n  /** @type {Handle} */\n\n  function onenterlistitemvalue(token) {\n    if (getData('expectingFirstListItemValue')) {\n      const ancestor =\n        /** @type {List} */\n        this.stack[this.stack.length - 2]\n      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10)\n      setData('expectingFirstListItemValue')\n    }\n  }\n  /** @type {Handle} */\n\n  function onexitcodefencedfenceinfo() {\n    const data = this.resume()\n    const node =\n      /** @type {Code} */\n      this.stack[this.stack.length - 1]\n    node.lang = data\n  }\n  /** @type {Handle} */\n\n  function onexitcodefencedfencemeta() {\n    const data = this.resume()\n    const node =\n      /** @type {Code} */\n      this.stack[this.stack.length - 1]\n    node.meta = data\n  }\n  /** @type {Handle} */\n\n  function onexitcodefencedfence() {\n    // Exit if this is the closing fence.\n    if (getData('flowCodeInside')) return\n    this.buffer()\n    setData('flowCodeInside', true)\n  }\n  /** @type {Handle} */\n\n  function onexitcodefenced() {\n    const data = this.resume()\n    const node =\n      /** @type {Code} */\n      this.stack[this.stack.length - 1]\n    node.value = data.replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '')\n    setData('flowCodeInside')\n  }\n  /** @type {Handle} */\n\n  function onexitcodeindented() {\n    const data = this.resume()\n    const node =\n      /** @type {Code} */\n      this.stack[this.stack.length - 1]\n    node.value = data.replace(/(\\r?\\n|\\r)$/g, '')\n  }\n  /** @type {Handle} */\n\n  function onexitdefinitionlabelstring(token) {\n    // Discard label, use the source content instead.\n    const label = this.resume()\n    const node =\n      /** @type {Definition} */\n      this.stack[this.stack.length - 1]\n    node.label = label\n    node.identifier = normalizeIdentifier(\n      this.sliceSerialize(token)\n    ).toLowerCase()\n  }\n  /** @type {Handle} */\n\n  function onexitdefinitiontitlestring() {\n    const data = this.resume()\n    const node =\n      /** @type {Definition} */\n      this.stack[this.stack.length - 1]\n    node.title = data\n  }\n  /** @type {Handle} */\n\n  function onexitdefinitiondestinationstring() {\n    const data = this.resume()\n    const node =\n      /** @type {Definition} */\n      this.stack[this.stack.length - 1]\n    node.url = data\n  }\n  /** @type {Handle} */\n\n  function onexitatxheadingsequence(token) {\n    const node =\n      /** @type {Heading} */\n      this.stack[this.stack.length - 1]\n\n    if (!node.depth) {\n      const depth = this.sliceSerialize(token).length\n      node.depth = depth\n    }\n  }\n  /** @type {Handle} */\n\n  function onexitsetextheadingtext() {\n    setData('setextHeadingSlurpLineEnding', true)\n  }\n  /** @type {Handle} */\n\n  function onexitsetextheadinglinesequence(token) {\n    const node =\n      /** @type {Heading} */\n      this.stack[this.stack.length - 1]\n    node.depth = this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2\n  }\n  /** @type {Handle} */\n\n  function onexitsetextheading() {\n    setData('setextHeadingSlurpLineEnding')\n  }\n  /** @type {Handle} */\n\n  function onenterdata(token) {\n    const parent =\n      /** @type {Parent} */\n      this.stack[this.stack.length - 1]\n    /** @type {Node} */\n\n    let tail = parent.children[parent.children.length - 1]\n\n    if (!tail || tail.type !== 'text') {\n      // Add a new text node.\n      tail = text() // @ts-expect-error: weâ€™ll add `end` later.\n\n      tail.position = {\n        start: point(token.start)\n      } // @ts-expect-error: Assume `parent` accepts `text`.\n\n      parent.children.push(tail)\n    }\n\n    this.stack.push(tail)\n  }\n  /** @type {Handle} */\n\n  function onexitdata(token) {\n    const tail = this.stack.pop()\n    tail.value += this.sliceSerialize(token)\n    tail.position.end = point(token.end)\n  }\n  /** @type {Handle} */\n\n  function onexitlineending(token) {\n    const context = this.stack[this.stack.length - 1]\n\n    // If weâ€™re at a hard break, include the line ending in there.\n    if (getData('atHardBreak')) {\n      const tail = context.children[context.children.length - 1]\n      tail.position.end = point(token.end)\n      setData('atHardBreak')\n      return\n    }\n\n    if (\n      !getData('setextHeadingSlurpLineEnding') &&\n      config.canContainEols.includes(context.type)\n    ) {\n      onenterdata.call(this, token)\n      onexitdata.call(this, token)\n    }\n  }\n  /** @type {Handle} */\n\n  function onexithardbreak() {\n    setData('atHardBreak', true)\n  }\n  /** @type {Handle} */\n\n  function onexithtmlflow() {\n    const data = this.resume()\n    const node =\n      /** @type {HTML} */\n      this.stack[this.stack.length - 1]\n    node.value = data\n  }\n  /** @type {Handle} */\n\n  function onexithtmltext() {\n    const data = this.resume()\n    const node =\n      /** @type {HTML} */\n      this.stack[this.stack.length - 1]\n    node.value = data\n  }\n  /** @type {Handle} */\n\n  function onexitcodetext() {\n    const data = this.resume()\n    const node =\n      /** @type {InlineCode} */\n      this.stack[this.stack.length - 1]\n    node.value = data\n  }\n  /** @type {Handle} */\n\n  function onexitlink() {\n    const context =\n      /** @type {Link & {identifier: string, label: string}} */\n      this.stack[this.stack.length - 1] // To do: clean.\n\n    if (getData('inReference')) {\n      context.type += 'Reference' // @ts-expect-error: mutate.\n\n      context.referenceType = getData('referenceType') || 'shortcut' // @ts-expect-error: mutate.\n\n      delete context.url\n      delete context.title\n    } else {\n      // @ts-expect-error: mutate.\n      delete context.identifier // @ts-expect-error: mutate.\n\n      delete context.label\n    }\n\n    setData('referenceType')\n  }\n  /** @type {Handle} */\n\n  function onexitimage() {\n    const context =\n      /** @type {Image & {identifier: string, label: string}} */\n      this.stack[this.stack.length - 1] // To do: clean.\n\n    if (getData('inReference')) {\n      context.type += 'Reference' // @ts-expect-error: mutate.\n\n      context.referenceType = getData('referenceType') || 'shortcut' // @ts-expect-error: mutate.\n\n      delete context.url\n      delete context.title\n    } else {\n      // @ts-expect-error: mutate.\n      delete context.identifier // @ts-expect-error: mutate.\n\n      delete context.label\n    }\n\n    setData('referenceType')\n  }\n  /** @type {Handle} */\n\n  function onexitlabeltext(token) {\n    const ancestor =\n      /** @type {(Link|Image) & {identifier: string, label: string}} */\n      this.stack[this.stack.length - 2]\n    const string = this.sliceSerialize(token)\n    ancestor.label = decodeString(string)\n    ancestor.identifier = normalizeIdentifier(string).toLowerCase()\n  }\n  /** @type {Handle} */\n\n  function onexitlabel() {\n    const fragment =\n      /** @type {Fragment} */\n      this.stack[this.stack.length - 1]\n    const value = this.resume()\n    const node =\n      /** @type {(Link|Image) & {identifier: string, label: string}} */\n      this.stack[this.stack.length - 1] // Assume a reference.\n\n    setData('inReference', true)\n\n    if (node.type === 'link') {\n      // @ts-expect-error: Assume static phrasing content.\n      node.children = fragment.children\n    } else {\n      node.alt = value\n    }\n  }\n  /** @type {Handle} */\n\n  function onexitresourcedestinationstring() {\n    const data = this.resume()\n    const node =\n      /** @type {Link|Image} */\n      this.stack[this.stack.length - 1]\n    node.url = data\n  }\n  /** @type {Handle} */\n\n  function onexitresourcetitlestring() {\n    const data = this.resume()\n    const node =\n      /** @type {Link|Image} */\n      this.stack[this.stack.length - 1]\n    node.title = data\n  }\n  /** @type {Handle} */\n\n  function onexitresource() {\n    setData('inReference')\n  }\n  /** @type {Handle} */\n\n  function onenterreference() {\n    setData('referenceType', 'collapsed')\n  }\n  /** @type {Handle} */\n\n  function onexitreferencestring(token) {\n    const label = this.resume()\n    const node =\n      /** @type {LinkReference|ImageReference} */\n      this.stack[this.stack.length - 1]\n    node.label = label\n    node.identifier = normalizeIdentifier(\n      this.sliceSerialize(token)\n    ).toLowerCase()\n    setData('referenceType', 'full')\n  }\n  /** @type {Handle} */\n\n  function onexitcharacterreferencemarker(token) {\n    setData('characterReferenceType', token.type)\n  }\n  /** @type {Handle} */\n\n  function onexitcharacterreferencevalue(token) {\n    const data = this.sliceSerialize(token)\n    const type = getData('characterReferenceType')\n    /** @type {string} */\n\n    let value\n\n    if (type) {\n      value = decodeNumericCharacterReference(\n        data,\n        type === 'characterReferenceMarkerNumeric' ? 10 : 16\n      )\n      setData('characterReferenceType')\n    } else {\n      // @ts-expect-error `decodeNamedCharacterReference` can return false for\n      // invalid named character references, but everything weâ€™ve tokenized is\n      // valid.\n      value = decodeNamedCharacterReference(data)\n    }\n\n    const tail = this.stack.pop()\n    tail.value += value\n    tail.position.end = point(token.end)\n  }\n  /** @type {Handle} */\n\n  function onexitautolinkprotocol(token) {\n    onexitdata.call(this, token)\n    const node =\n      /** @type {Link} */\n      this.stack[this.stack.length - 1]\n    node.url = this.sliceSerialize(token)\n  }\n  /** @type {Handle} */\n\n  function onexitautolinkemail(token) {\n    onexitdata.call(this, token)\n    const node =\n      /** @type {Link} */\n      this.stack[this.stack.length - 1]\n    node.url = 'mailto:' + this.sliceSerialize(token)\n  } //\n  // Creaters.\n  //\n\n  /** @returns {Blockquote} */\n\n  function blockQuote() {\n    return {\n      type: 'blockquote',\n      children: []\n    }\n  }\n  /** @returns {Code} */\n\n  function codeFlow() {\n    return {\n      type: 'code',\n      lang: null,\n      meta: null,\n      value: ''\n    }\n  }\n  /** @returns {InlineCode} */\n\n  function codeText() {\n    return {\n      type: 'inlineCode',\n      value: ''\n    }\n  }\n  /** @returns {Definition} */\n\n  function definition() {\n    return {\n      type: 'definition',\n      identifier: '',\n      label: null,\n      title: null,\n      url: ''\n    }\n  }\n  /** @returns {Emphasis} */\n\n  function emphasis() {\n    return {\n      type: 'emphasis',\n      children: []\n    }\n  }\n  /** @returns {Heading} */\n\n  function heading() {\n    // @ts-expect-error `depth` will be set later.\n    return {\n      type: 'heading',\n      depth: undefined,\n      children: []\n    }\n  }\n  /** @returns {Break} */\n\n  function hardBreak() {\n    return {\n      type: 'break'\n    }\n  }\n  /** @returns {HTML} */\n\n  function html() {\n    return {\n      type: 'html',\n      value: ''\n    }\n  }\n  /** @returns {Image} */\n\n  function image() {\n    return {\n      type: 'image',\n      title: null,\n      url: '',\n      alt: null\n    }\n  }\n  /** @returns {Link} */\n\n  function link() {\n    return {\n      type: 'link',\n      title: null,\n      url: '',\n      children: []\n    }\n  }\n  /**\n   * @param {Token} token\n   * @returns {List}\n   */\n\n  function list(token) {\n    return {\n      type: 'list',\n      ordered: token.type === 'listOrdered',\n      start: null,\n      // @ts-expect-error Patched.\n      spread: token._spread,\n      children: []\n    }\n  }\n  /**\n   * @param {Token} token\n   * @returns {ListItem}\n   */\n\n  function listItem(token) {\n    return {\n      type: 'listItem',\n      // @ts-expect-error Patched.\n      spread: token._spread,\n      checked: null,\n      children: []\n    }\n  }\n  /** @returns {Paragraph} */\n\n  function paragraph() {\n    return {\n      type: 'paragraph',\n      children: []\n    }\n  }\n  /** @returns {Strong} */\n\n  function strong() {\n    return {\n      type: 'strong',\n      children: []\n    }\n  }\n  /** @returns {Text} */\n\n  function text() {\n    return {\n      type: 'text',\n      value: ''\n    }\n  }\n  /** @returns {ThematicBreak} */\n\n  function thematicBreak() {\n    return {\n      type: 'thematicBreak'\n    }\n  }\n}\n/**\n * @param {Extension} combined\n * @param {Array<Extension|Array<Extension>>} extensions\n * @returns {Extension}\n */\n\nfunction configure(combined, extensions) {\n  let index = -1\n\n  while (++index < extensions.length) {\n    const value = extensions[index]\n\n    if (Array.isArray(value)) {\n      configure(combined, value)\n    } else {\n      extension(combined, value)\n    }\n  }\n\n  return combined\n}\n/**\n * @param {Extension} combined\n * @param {Extension} extension\n * @returns {void}\n */\n\nfunction extension(combined, extension) {\n  /** @type {string} */\n  let key\n\n  for (key in extension) {\n    if (own.call(extension, key)) {\n      const list = key === 'canContainEols' || key === 'transforms'\n      const maybe = own.call(combined, key) ? combined[key] : undefined\n      /* c8 ignore next */\n\n      const left = maybe || (combined[key] = list ? [] : {})\n      const right = extension[key]\n\n      if (right) {\n        if (list) {\n          // @ts-expect-error: `left` is an array.\n          combined[key] = [...left, ...right]\n        } else {\n          Object.assign(left, right)\n        }\n      }\n    }\n  }\n}\n/** @type {OnEnterError} */\n\nfunction defaultOnError(left, right) {\n  if (left) {\n    throw new Error(\n      'Cannot close `' +\n        left.type +\n        '` (' +\n        stringifyPosition({\n          start: left.start,\n          end: left.end\n        }) +\n        '): a different token (`' +\n        right.type +\n        '`, ' +\n        stringifyPosition({\n          start: right.start,\n          end: right.end\n        }) +\n        ') is open'\n    )\n  } else {\n    throw new Error(\n      'Cannot close document, a token (`' +\n        right.type +\n        '`, ' +\n        stringifyPosition({\n          start: right.start,\n          end: right.end\n        }) +\n        ') is still open'\n    )\n  }\n}\n"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQA,QAAQ,QAAO,sBAAsB;AAC7C,SAAQC,KAAK,QAAO,wBAAwB;AAC5C,SAAQC,UAAU,QAAO,6BAA6B;AACtD,SAAQC,WAAW,QAAO,8BAA8B;AACxD,SAAQC,+BAA+B,QAAO,mDAAmD;AACjG,SAAQC,YAAY,QAAO,8BAA8B;AACzD,SAAQC,mBAAmB,QAAO,qCAAqC;AACvE,SAAQC,6BAA6B,QAAO,kCAAkC;AAC9E,SAAQC,iBAAiB,QAAO,+BAA+B;AAC/D,IAAMC,GAAG,GAAG,CAAC,CAAC,CAACC,cAAc;AAC7B;AACA;AACA;AACA;AACA;;AAEA,OAAO,IAAMC,YAAY;AACvB;AACF;AACA;AACA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;AACE,SAdWA,YAAY,CAcbC,KAAK,EAAEC,QAAQ,EAAEC,OAAO,EAAE;EAClC,IAAI,OAAOD,QAAQ,KAAK,QAAQ,EAAE;IAChCC,OAAO,GAAGD,QAAQ;IAClBA,QAAQ,GAAGE,SAAS;EACtB;EAEA,OAAOC,QAAQ,CAACF,OAAO,CAAC,CACtBX,WAAW,CACTF,KAAK,CAACa,OAAO,CAAC,CAACG,QAAQ,EAAE,CAACC,KAAK,CAAChB,UAAU,EAAE,CAACU,KAAK,EAAEC,QAAQ,EAAE,IAAI,CAAC,CAAC,CACrE,CACF;AACH,CAAC;AACH;AACA;AACA;AACA;AACA;;AAEA,SAASG,QAAQ,GAAe;EAAA,IAAdF,OAAO,uEAAG,CAAC,CAAC;EAC5B;EACA;EACA,IAAMK,MAAM,GAAGC,SAAS,CACtB;IACEC,UAAU,EAAE,EAAE;IACdC,cAAc,EAAE,CACd,UAAU,EACV,UAAU,EACV,SAAS,EACT,WAAW,EACX,QAAQ,CACT;IACDC,KAAK,EAAE;MACLC,QAAQ,EAAEC,MAAM,CAACC,IAAI,CAAC;MACtBC,gBAAgB,EAAEC,WAAW;MAC7BC,aAAa,EAAED,WAAW;MAC1BE,UAAU,EAAEL,MAAM,CAACM,OAAO,CAAC;MAC3BC,UAAU,EAAEP,MAAM,CAACO,UAAU,CAAC;MAC9BC,eAAe,EAAEL,WAAW;MAC5BM,kBAAkB,EAAEN,WAAW;MAC/BO,UAAU,EAAEV,MAAM,CAACW,QAAQ,CAAC;MAC5BC,mBAAmB,EAAEC,MAAM;MAC3BC,mBAAmB,EAAED,MAAM;MAC3BE,YAAY,EAAEf,MAAM,CAACW,QAAQ,EAAEE,MAAM,CAAC;MACtCG,QAAQ,EAAEhB,MAAM,CAACgB,QAAQ,EAAEH,MAAM,CAAC;MAClCI,YAAY,EAAEd,WAAW;MACzBe,IAAI,EAAEf,WAAW;MACjBgB,aAAa,EAAEhB,WAAW;MAC1BiB,UAAU,EAAEpB,MAAM,CAACoB,UAAU,CAAC;MAC9BC,2BAA2B,EAAER,MAAM;MACnCS,qBAAqB,EAAET,MAAM;MAC7BU,qBAAqB,EAAEV,MAAM;MAC7BW,QAAQ,EAAExB,MAAM,CAACwB,QAAQ,CAAC;MAC1BC,eAAe,EAAEzB,MAAM,CAAC0B,SAAS,CAAC;MAClCC,iBAAiB,EAAE3B,MAAM,CAAC0B,SAAS,CAAC;MACpCE,QAAQ,EAAE5B,MAAM,CAAC6B,IAAI,EAAEhB,MAAM,CAAC;MAC9BiB,YAAY,EAAE3B,WAAW;MACzB4B,QAAQ,EAAE/B,MAAM,CAAC6B,IAAI,EAAEhB,MAAM,CAAC;MAC9BmB,YAAY,EAAE7B,WAAW;MACzB8B,KAAK,EAAEjC,MAAM,CAACiC,KAAK,CAAC;MACpBC,KAAK,EAAErB,MAAM;MACbZ,IAAI,EAAED,MAAM,CAACC,IAAI,CAAC;MAClBkC,QAAQ,EAAEnC,MAAM,CAACmC,QAAQ,CAAC;MAC1BC,aAAa,EAAEC,oBAAoB;MACnCC,WAAW,EAAEtC,MAAM,CAACuC,IAAI,EAAEC,kBAAkB,CAAC;MAC7CC,aAAa,EAAEzC,MAAM,CAACuC,IAAI,CAAC;MAC3BG,SAAS,EAAE1C,MAAM,CAAC0C,SAAS,CAAC;MAC5BC,SAAS,EAAEC,gBAAgB;MAC3BC,eAAe,EAAEhC,MAAM;MACvBiC,yBAAyB,EAAEjC,MAAM;MACjCkC,mBAAmB,EAAElC,MAAM;MAC3BmC,aAAa,EAAEhD,MAAM,CAACM,OAAO,CAAC;MAC9B2C,MAAM,EAAEjD,MAAM,CAACiD,MAAM,CAAC;MACtBC,aAAa,EAAElD,MAAM,CAACkD,aAAa;IACrC,CAAC;IACDC,IAAI,EAAE;MACJ9C,UAAU,EAAE+C,MAAM,EAAE;MACpBC,kBAAkB,EAAEC,wBAAwB;MAC5CvD,QAAQ,EAAEqD,MAAM,EAAE;MAClBhD,aAAa,EAAEmD,mBAAmB;MAClCrD,gBAAgB,EAAEsD,sBAAsB;MACxCjD,UAAU,EAAE6C,MAAM,EAAE;MACpBK,oBAAoB,EAAEC,UAAU;MAChCC,mCAAmC,EAAEC,8BAA8B;MACnEC,+BAA+B,EAAED,8BAA8B;MAC/DE,uBAAuB,EAAEC,6BAA6B;MACtDrD,UAAU,EAAE0C,MAAM,CAACY,gBAAgB,CAAC;MACpCC,eAAe,EAAEC,qBAAqB;MACtCtD,mBAAmB,EAAEuD,yBAAyB;MAC9CrD,mBAAmB,EAAEsD,yBAAyB;MAC9CjD,aAAa,EAAEuC,UAAU;MACzB3C,YAAY,EAAEqC,MAAM,CAACiB,kBAAkB,CAAC;MACxCrD,QAAQ,EAAEoC,MAAM,CAACkB,cAAc,CAAC;MAChCrD,YAAY,EAAEyC,UAAU;MACxBxC,IAAI,EAAEwC,UAAU;MAChBtC,UAAU,EAAEgC,MAAM,EAAE;MACpB/B,2BAA2B,EAAEkD,iCAAiC;MAC9DjD,qBAAqB,EAAEkD,2BAA2B;MAClDjD,qBAAqB,EAAEkD,2BAA2B;MAClDjD,QAAQ,EAAE4B,MAAM,EAAE;MAClB3B,eAAe,EAAE2B,MAAM,CAACsB,eAAe,CAAC;MACxC/C,iBAAiB,EAAEyB,MAAM,CAACsB,eAAe,CAAC;MAC1C9C,QAAQ,EAAEwB,MAAM,CAACuB,cAAc,CAAC;MAChC7C,YAAY,EAAE4B,UAAU;MACxB3B,QAAQ,EAAEqB,MAAM,CAACwB,cAAc,CAAC;MAChC5C,YAAY,EAAE0B,UAAU;MACxBzB,KAAK,EAAEmB,MAAM,CAACyB,WAAW,CAAC;MAC1B3C,KAAK,EAAE4C,WAAW;MAClBC,SAAS,EAAEC,eAAe;MAC1BC,UAAU,EAAEC,gBAAgB;MAC5BjF,IAAI,EAAEmD,MAAM,CAAC+B,UAAU,CAAC;MACxBhD,QAAQ,EAAEiB,MAAM,EAAE;MAClBd,WAAW,EAAEc,MAAM,EAAE;MACrBX,aAAa,EAAEW,MAAM,EAAE;MACvBV,SAAS,EAAEU,MAAM,EAAE;MACnBP,eAAe,EAAEuC,qBAAqB;MACtCtC,yBAAyB,EAAEuC,+BAA+B;MAC1DtC,mBAAmB,EAAEuC,yBAAyB;MAC9CC,QAAQ,EAAEC,cAAc;MACxBxC,aAAa,EAAEI,MAAM,CAACqC,mBAAmB,CAAC;MAC1CC,yBAAyB,EAAEC,+BAA+B;MAC1DC,iBAAiB,EAAEC,uBAAuB;MAC1C5C,MAAM,EAAEG,MAAM,EAAE;MAChBF,aAAa,EAAEE,MAAM;IACvB;EACF,CAAC,EACD/D,OAAO,CAACyG,eAAe,IAAI,EAAE,CAC9B;EACD;;EAEA,IAAM5E,IAAI,GAAG,CAAC,CAAC;EACf,OAAO6E,OAAO;EACd;AACF;AACA;AACA;;EAEE,SAASA,OAAO,CAACC,MAAM,EAAE;IACvB;IACA,IAAIC,IAAI,GAAG;MACTC,IAAI,EAAE,MAAM;MACZC,QAAQ,EAAE;IACZ,CAAC;IACD;;IAEA,IAAMC,KAAK,GAAG,CAACH,IAAI,CAAC;IACpB;;IAEA,IAAMI,UAAU,GAAG,EAAE;IACrB;;IAEA,IAAMC,SAAS,GAAG,EAAE;IACpB;;IAEA,IAAMC,OAAO,GAAG;MACdH,KAAK,EAALA,KAAK;MACLC,UAAU,EAAVA,UAAU;MACV3G,MAAM,EAANA,MAAM;MACNI,KAAK,EAALA,KAAK;MACLqD,IAAI,EAAJA,IAAI;MACJtC,MAAM,EAANA,MAAM;MACN2F,MAAM,EAANA,MAAM;MACNC,OAAO,EAAPA,OAAO;MACPC,OAAO,EAAPA;IACF,CAAC;IACD,IAAIC,KAAK,GAAG,CAAC,CAAC;IAEd,OAAO,EAAEA,KAAK,GAAGX,MAAM,CAACY,MAAM,EAAE;MAC9B;MACA;MACA,IACEZ,MAAM,CAACW,KAAK,CAAC,CAAC,CAAC,CAAC,CAACT,IAAI,KAAK,aAAa,IACvCF,MAAM,CAACW,KAAK,CAAC,CAAC,CAAC,CAAC,CAACT,IAAI,KAAK,eAAe,EACzC;QACA,IAAIF,MAAM,CAACW,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,OAAO,EAAE;UAChCL,SAAS,CAACO,IAAI,CAACF,KAAK,CAAC;QACvB,CAAC,MAAM;UACL,IAAMG,IAAI,GAAGR,SAAS,CAACS,GAAG,EAAE;UAC5BJ,KAAK,GAAGK,WAAW,CAAChB,MAAM,EAAEc,IAAI,EAAEH,KAAK,CAAC;QAC1C;MACF;IACF;IAEAA,KAAK,GAAG,CAAC,CAAC;IAEV,OAAO,EAAEA,KAAK,GAAGX,MAAM,CAACY,MAAM,EAAE;MAC9B,IAAMK,OAAO,GAAGvH,MAAM,CAACsG,MAAM,CAACW,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;MAExC,IAAI3H,GAAG,CAACkI,IAAI,CAACD,OAAO,EAAEjB,MAAM,CAACW,KAAK,CAAC,CAAC,CAAC,CAAC,CAACT,IAAI,CAAC,EAAE;QAC5Ce,OAAO,CAACjB,MAAM,CAACW,KAAK,CAAC,CAAC,CAAC,CAAC,CAACT,IAAI,CAAC,CAACgB,IAAI,CACjCC,MAAM,CAACC,MAAM,CACX;UACEC,cAAc,EAAErB,MAAM,CAACW,KAAK,CAAC,CAAC,CAAC,CAAC,CAACU;QACnC,CAAC,EACDd,OAAO,CACR,EACDP,MAAM,CAACW,KAAK,CAAC,CAAC,CAAC,CAAC,CACjB;MACH;IACF;IAEA,IAAIN,UAAU,CAACO,MAAM,GAAG,CAAC,EAAE;MACzB,IAAME,KAAI,GAAGT,UAAU,CAACA,UAAU,CAACO,MAAM,GAAG,CAAC,CAAC;MAC9C,IAAMK,QAAO,GAAGH,KAAI,CAAC,CAAC,CAAC,IAAIQ,cAAc;MACzCL,QAAO,CAACC,IAAI,CAACX,OAAO,EAAEjH,SAAS,EAAEwH,KAAI,CAAC,CAAC,CAAC,CAAC;IAC3C,CAAC,CAAC;;IAEFb,IAAI,CAACsB,QAAQ,GAAG;MACdC,KAAK,EAAEC,KAAK,CACVzB,MAAM,CAACY,MAAM,GAAG,CAAC,GACbZ,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAACwB,KAAK,GAClB;QACEE,IAAI,EAAE,CAAC;QACPC,MAAM,EAAE,CAAC;QACTC,MAAM,EAAE;MACV,CAAC,CACN;MACDC,GAAG,EAAEJ,KAAK,CACRzB,MAAM,CAACY,MAAM,GAAG,CAAC,GACbZ,MAAM,CAACA,MAAM,CAACY,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAACiB,GAAG,GAChC;QACEH,IAAI,EAAE,CAAC;QACPC,MAAM,EAAE,CAAC;QACTC,MAAM,EAAE;MACV,CAAC;IAET,CAAC;IACDjB,KAAK,GAAG,CAAC,CAAC;IAEV,OAAO,EAAEA,KAAK,GAAGjH,MAAM,CAACE,UAAU,CAACgH,MAAM,EAAE;MACzCX,IAAI,GAAGvG,MAAM,CAACE,UAAU,CAAC+G,KAAK,CAAC,CAACV,IAAI,CAAC,IAAIA,IAAI;IAC/C;IAEA,OAAOA,IAAI;EACb;EACA;AACF;AACA;AACA;AACA;AACA;;EAEE,SAASe,WAAW,CAAChB,MAAM,EAAEwB,KAAK,EAAEZ,MAAM,EAAE;IAC1C,IAAID,KAAK,GAAGa,KAAK,GAAG,CAAC;IACrB,IAAIM,gBAAgB,GAAG,CAAC,CAAC;IACzB,IAAIC,UAAU,GAAG,KAAK;IACtB;;IAEA,IAAI5F,QAAQ;IACZ;;IAEA,IAAI6F,SAAS;IACb;;IAEA,IAAIC,mBAAmB;IACvB;;IAEA,IAAIC,QAAQ;IAEZ,OAAO,EAAEvB,KAAK,IAAIC,MAAM,EAAE;MACxB,IAAMuB,KAAK,GAAGnC,MAAM,CAACW,KAAK,CAAC;MAE3B,IACEwB,KAAK,CAAC,CAAC,CAAC,CAACjC,IAAI,KAAK,eAAe,IACjCiC,KAAK,CAAC,CAAC,CAAC,CAACjC,IAAI,KAAK,aAAa,IAC/BiC,KAAK,CAAC,CAAC,CAAC,CAACjC,IAAI,KAAK,YAAY,EAC9B;QACA,IAAIiC,KAAK,CAAC,CAAC,CAAC,KAAK,OAAO,EAAE;UACxBL,gBAAgB,EAAE;QACpB,CAAC,MAAM;UACLA,gBAAgB,EAAE;QACpB;QAEAI,QAAQ,GAAG5I,SAAS;MACtB,CAAC,MAAM,IAAI6I,KAAK,CAAC,CAAC,CAAC,CAACjC,IAAI,KAAK,iBAAiB,EAAE;QAC9C,IAAIiC,KAAK,CAAC,CAAC,CAAC,KAAK,OAAO,EAAE;UACxB,IACEhG,QAAQ,IACR,CAAC+F,QAAQ,IACT,CAACJ,gBAAgB,IACjB,CAACG,mBAAmB,EACpB;YACAA,mBAAmB,GAAGtB,KAAK;UAC7B;UAEAuB,QAAQ,GAAG5I,SAAS;QACtB;MACF,CAAC,MAAM,IACL6I,KAAK,CAAC,CAAC,CAAC,CAACjC,IAAI,KAAK,YAAY,IAC9BiC,KAAK,CAAC,CAAC,CAAC,CAACjC,IAAI,KAAK,eAAe,IACjCiC,KAAK,CAAC,CAAC,CAAC,CAACjC,IAAI,KAAK,gBAAgB,IAClCiC,KAAK,CAAC,CAAC,CAAC,CAACjC,IAAI,KAAK,gBAAgB,IAClCiC,KAAK,CAAC,CAAC,CAAC,CAACjC,IAAI,KAAK,0BAA0B,EAC5C;QACA;MAAA,CACD,MAAM;QACLgC,QAAQ,GAAG5I,SAAS;MACtB;MAEA,IACG,CAACwI,gBAAgB,IAChBK,KAAK,CAAC,CAAC,CAAC,KAAK,OAAO,IACpBA,KAAK,CAAC,CAAC,CAAC,CAACjC,IAAI,KAAK,gBAAgB,IACnC4B,gBAAgB,KAAK,CAAC,CAAC,IACtBK,KAAK,CAAC,CAAC,CAAC,KAAK,MAAM,KAClBA,KAAK,CAAC,CAAC,CAAC,CAACjC,IAAI,KAAK,eAAe,IAChCiC,KAAK,CAAC,CAAC,CAAC,CAACjC,IAAI,KAAK,aAAa,CAAE,EACrC;QACA,IAAI/D,QAAQ,EAAE;UACZ,IAAIiG,SAAS,GAAGzB,KAAK;UACrBqB,SAAS,GAAG1I,SAAS;UAErB,OAAO8I,SAAS,EAAE,EAAE;YAClB,IAAMC,SAAS,GAAGrC,MAAM,CAACoC,SAAS,CAAC;YAEnC,IACEC,SAAS,CAAC,CAAC,CAAC,CAACnC,IAAI,KAAK,YAAY,IAClCmC,SAAS,CAAC,CAAC,CAAC,CAACnC,IAAI,KAAK,iBAAiB,EACvC;cACA,IAAImC,SAAS,CAAC,CAAC,CAAC,KAAK,MAAM,EAAE;cAE7B,IAAIL,SAAS,EAAE;gBACbhC,MAAM,CAACgC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC9B,IAAI,GAAG,iBAAiB;gBAC7C6B,UAAU,GAAG,IAAI;cACnB;cAEAM,SAAS,CAAC,CAAC,CAAC,CAACnC,IAAI,GAAG,YAAY;cAChC8B,SAAS,GAAGI,SAAS;YACvB,CAAC,MAAM,IACLC,SAAS,CAAC,CAAC,CAAC,CAACnC,IAAI,KAAK,YAAY,IAClCmC,SAAS,CAAC,CAAC,CAAC,CAACnC,IAAI,KAAK,kBAAkB,IACxCmC,SAAS,CAAC,CAAC,CAAC,CAACnC,IAAI,KAAK,4BAA4B,IAClDmC,SAAS,CAAC,CAAC,CAAC,CAACnC,IAAI,KAAK,kBAAkB,IACxCmC,SAAS,CAAC,CAAC,CAAC,CAACnC,IAAI,KAAK,gBAAgB,EACtC;cACA;YAAA,CACD,MAAM;cACL;YACF;UACF;UAEA,IACE+B,mBAAmB,KAClB,CAACD,SAAS,IAAIC,mBAAmB,GAAGD,SAAS,CAAC,EAC/C;YACA;YACA7F,QAAQ,CAACmG,OAAO,GAAG,IAAI;UACzB,CAAC,CAAC;;UAEFnG,QAAQ,CAAC0F,GAAG,GAAGV,MAAM,CAACC,MAAM,CAC1B,CAAC,CAAC,EACFY,SAAS,GAAGhC,MAAM,CAACgC,SAAS,CAAC,CAAC,CAAC,CAAC,CAACR,KAAK,GAAGW,KAAK,CAAC,CAAC,CAAC,CAACN,GAAG,CACtD;UACD7B,MAAM,CAACuC,MAAM,CAACP,SAAS,IAAIrB,KAAK,EAAE,CAAC,EAAE,CAAC,MAAM,EAAExE,QAAQ,EAAEgG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;UAClExB,KAAK,EAAE;UACPC,MAAM,EAAE;QACV,CAAC,CAAC;;QAEF,IAAIuB,KAAK,CAAC,CAAC,CAAC,CAACjC,IAAI,KAAK,gBAAgB,EAAE;UACtC/D,QAAQ,GAAG;YACT+D,IAAI,EAAE,UAAU;YAChB;YACAoC,OAAO,EAAE,KAAK;YACdd,KAAK,EAAEL,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEe,KAAK,CAAC,CAAC,CAAC,CAACX,KAAK;UACzC,CAAC,EAAC;;UAEFxB,MAAM,CAACuC,MAAM,CAAC5B,KAAK,EAAE,CAAC,EAAE,CAAC,OAAO,EAAExE,QAAQ,EAAEgG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;UACtDxB,KAAK,EAAE;UACPC,MAAM,EAAE;UACRqB,mBAAmB,GAAG3I,SAAS;UAC/B4I,QAAQ,GAAG,IAAI;QACjB;MACF;IACF,CAAC,CAAC;;IAEFlC,MAAM,CAACwB,KAAK,CAAC,CAAC,CAAC,CAAC,CAACc,OAAO,GAAGP,UAAU;IACrC,OAAOnB,MAAM;EACf;EACA;AACF;AACA;AACA;;EAEE,SAASH,OAAO,CAAC+B,GAAG,EAAErJ,KAAK,EAAE;IAC3B+B,IAAI,CAACsH,GAAG,CAAC,GAAGrJ,KAAK;EACnB;EACA;AACF;AACA;AACA;AACA;AACA;;EAEE,SAASuH,OAAO,CAAC8B,GAAG,EAAE;IACpB,OAAOtH,IAAI,CAACsH,GAAG,CAAC;EAClB;EACA;AACF;AACA;AACA;;EAEE,SAASf,KAAK,CAACgB,CAAC,EAAE;IAChB,OAAO;MACLf,IAAI,EAAEe,CAAC,CAACf,IAAI;MACZC,MAAM,EAAEc,CAAC,CAACd,MAAM;MAChBC,MAAM,EAAEa,CAAC,CAACb;IACZ,CAAC;EACH;EACA;AACF;AACA;AACA;AACA;;EAEE,SAAS5H,MAAM,CAAC0I,MAAM,EAAEC,GAAG,EAAE;IAC3B,OAAOC,IAAI;IACX;AACJ;AACA;AACA;AACA;;IAEI,SAASA,IAAI,CAACC,KAAK,EAAE;MACnB/I,KAAK,CAACoH,IAAI,CAAC,IAAI,EAAEwB,MAAM,CAACG,KAAK,CAAC,EAAEA,KAAK,CAAC;MACtC,IAAIF,GAAG,EAAEA,GAAG,CAACzB,IAAI,CAAC,IAAI,EAAE2B,KAAK,CAAC;IAChC;EACF;EACA;;EAEA,SAAShI,MAAM,GAAG;IAChB,IAAI,CAACuF,KAAK,CAACS,IAAI,CAAC;MACdX,IAAI,EAAE,UAAU;MAChBC,QAAQ,EAAE;IACZ,CAAC,CAAC;EACJ;EACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE,SAASrG,KAAK,CAACgJ,IAAI,EAAED,KAAK,EAAEE,YAAY,EAAE;IACxC,IAAMC,MAAM,GAAG,IAAI,CAAC5C,KAAK,CAAC,IAAI,CAACA,KAAK,CAACQ,MAAM,GAAG,CAAC,CAAC;IAChD;IACAoC,MAAM,CAAC7C,QAAQ,CAACU,IAAI,CAACiC,IAAI,CAAC;IAC1B,IAAI,CAAC1C,KAAK,CAACS,IAAI,CAACiC,IAAI,CAAC;IACrB,IAAI,CAACzC,UAAU,CAACQ,IAAI,CAAC,CAACgC,KAAK,EAAEE,YAAY,CAAC,CAAC,EAAC;;IAE5CD,IAAI,CAACvB,QAAQ,GAAG;MACdC,KAAK,EAAEC,KAAK,CAACoB,KAAK,CAACrB,KAAK;IAC1B,CAAC;IACD,OAAOsB,IAAI;EACb;EACA;AACF;AACA;AACA;;EAEE,SAAS1F,MAAM,CAACuF,GAAG,EAAE;IACnB,OAAOM,KAAK;IACZ;AACJ;AACA;AACA;AACA;;IAEI,SAASA,KAAK,CAACJ,KAAK,EAAE;MACpB,IAAIF,GAAG,EAAEA,GAAG,CAACzB,IAAI,CAAC,IAAI,EAAE2B,KAAK,CAAC;MAC9B1F,IAAI,CAAC+D,IAAI,CAAC,IAAI,EAAE2B,KAAK,CAAC;IACxB;EACF;EACA;AACF;AACA;AACA;AACA;AACA;AACA;;EAEE,SAAS1F,IAAI,CAAC0F,KAAK,EAAEK,WAAW,EAAE;IAChC,IAAMJ,IAAI,GAAG,IAAI,CAAC1C,KAAK,CAACW,GAAG,EAAE;IAC7B,IAAM6B,IAAI,GAAG,IAAI,CAACvC,UAAU,CAACU,GAAG,EAAE;IAElC,IAAI,CAAC6B,IAAI,EAAE;MACT,MAAM,IAAIO,KAAK,CACb,gBAAgB,GACdN,KAAK,CAAC3C,IAAI,GACV,KAAK,GACLnH,iBAAiB,CAAC;QAChByI,KAAK,EAAEqB,KAAK,CAACrB,KAAK;QAClBK,GAAG,EAAEgB,KAAK,CAAChB;MACb,CAAC,CAAC,GACF,kBAAkB,CACrB;IACH,CAAC,MAAM,IAAIe,IAAI,CAAC,CAAC,CAAC,CAAC1C,IAAI,KAAK2C,KAAK,CAAC3C,IAAI,EAAE;MACtC,IAAIgD,WAAW,EAAE;QACfA,WAAW,CAAChC,IAAI,CAAC,IAAI,EAAE2B,KAAK,EAAED,IAAI,CAAC,CAAC,CAAC,CAAC;MACxC,CAAC,MAAM;QACL,IAAM3B,OAAO,GAAG2B,IAAI,CAAC,CAAC,CAAC,IAAItB,cAAc;QACzCL,OAAO,CAACC,IAAI,CAAC,IAAI,EAAE2B,KAAK,EAAED,IAAI,CAAC,CAAC,CAAC,CAAC;MACpC;IACF;IAEAE,IAAI,CAACvB,QAAQ,CAACM,GAAG,GAAGJ,KAAK,CAACoB,KAAK,CAAChB,GAAG,CAAC;IACpC,OAAOiB,IAAI;EACb;EACA;AACF;AACA;AACA;;EAEE,SAAStC,MAAM,GAAG;IAChB,OAAOjI,QAAQ,CAAC,IAAI,CAAC6H,KAAK,CAACW,GAAG,EAAE,CAAC;EACnC,CAAC,CAAC;EACF;EACA;;EAEA;;EAEA,SAASvE,kBAAkB,GAAG;IAC5BiE,OAAO,CAAC,6BAA6B,EAAE,IAAI,CAAC;EAC9C;EACA;;EAEA,SAASpE,oBAAoB,CAACwG,KAAK,EAAE;IACnC,IAAInC,OAAO,CAAC,6BAA6B,CAAC,EAAE;MAC1C,IAAM0C,QAAQ,GACZ;MACA,IAAI,CAAChD,KAAK,CAAC,IAAI,CAACA,KAAK,CAACQ,MAAM,GAAG,CAAC,CAAC;MACnCwC,QAAQ,CAAC5B,KAAK,GAAG6B,MAAM,CAACC,QAAQ,CAAC,IAAI,CAACjC,cAAc,CAACwB,KAAK,CAAC,EAAE,EAAE,CAAC;MAChEpC,OAAO,CAAC,6BAA6B,CAAC;IACxC;EACF;EACA;;EAEA,SAAStC,yBAAyB,GAAG;IACnC,IAAMjD,IAAI,GAAG,IAAI,CAACsF,MAAM,EAAE;IAC1B,IAAMsC,IAAI,GACR;IACA,IAAI,CAAC1C,KAAK,CAAC,IAAI,CAACA,KAAK,CAACQ,MAAM,GAAG,CAAC,CAAC;IACnCkC,IAAI,CAACS,IAAI,GAAGrI,IAAI;EAClB;EACA;;EAEA,SAASkD,yBAAyB,GAAG;IACnC,IAAMlD,IAAI,GAAG,IAAI,CAACsF,MAAM,EAAE;IAC1B,IAAMsC,IAAI,GACR;IACA,IAAI,CAAC1C,KAAK,CAAC,IAAI,CAACA,KAAK,CAACQ,MAAM,GAAG,CAAC,CAAC;IACnCkC,IAAI,CAACU,IAAI,GAAGtI,IAAI;EAClB;EACA;;EAEA,SAASgD,qBAAqB,GAAG;IAC/B;IACA,IAAIwC,OAAO,CAAC,gBAAgB,CAAC,EAAE;IAC/B,IAAI,CAAC7F,MAAM,EAAE;IACb4F,OAAO,CAAC,gBAAgB,EAAE,IAAI,CAAC;EACjC;EACA;;EAEA,SAASzC,gBAAgB,GAAG;IAC1B,IAAM9C,IAAI,GAAG,IAAI,CAACsF,MAAM,EAAE;IAC1B,IAAMsC,IAAI,GACR;IACA,IAAI,CAAC1C,KAAK,CAAC,IAAI,CAACA,KAAK,CAACQ,MAAM,GAAG,CAAC,CAAC;IACnCkC,IAAI,CAAC3J,KAAK,GAAG+B,IAAI,CAACuI,OAAO,CAAC,0BAA0B,EAAE,EAAE,CAAC;IACzDhD,OAAO,CAAC,gBAAgB,CAAC;EAC3B;EACA;;EAEA,SAASpC,kBAAkB,GAAG;IAC5B,IAAMnD,IAAI,GAAG,IAAI,CAACsF,MAAM,EAAE;IAC1B,IAAMsC,IAAI,GACR;IACA,IAAI,CAAC1C,KAAK,CAAC,IAAI,CAACA,KAAK,CAACQ,MAAM,GAAG,CAAC,CAAC;IACnCkC,IAAI,CAAC3J,KAAK,GAAG+B,IAAI,CAACuI,OAAO,CAAC,cAAc,EAAE,EAAE,CAAC;EAC/C;EACA;;EAEA,SAASjF,2BAA2B,CAACqE,KAAK,EAAE;IAC1C;IACA,IAAM3G,KAAK,GAAG,IAAI,CAACsE,MAAM,EAAE;IAC3B,IAAMsC,IAAI,GACR;IACA,IAAI,CAAC1C,KAAK,CAAC,IAAI,CAACA,KAAK,CAACQ,MAAM,GAAG,CAAC,CAAC;IACnCkC,IAAI,CAAC5G,KAAK,GAAGA,KAAK;IAClB4G,IAAI,CAACY,UAAU,GAAG7K,mBAAmB,CACnC,IAAI,CAACwI,cAAc,CAACwB,KAAK,CAAC,CAC3B,CAACc,WAAW,EAAE;EACjB;EACA;;EAEA,SAASlF,2BAA2B,GAAG;IACrC,IAAMvD,IAAI,GAAG,IAAI,CAACsF,MAAM,EAAE;IAC1B,IAAMsC,IAAI,GACR;IACA,IAAI,CAAC1C,KAAK,CAAC,IAAI,CAACA,KAAK,CAACQ,MAAM,GAAG,CAAC,CAAC;IACnCkC,IAAI,CAACc,KAAK,GAAG1I,IAAI;EACnB;EACA;;EAEA,SAASqD,iCAAiC,GAAG;IAC3C,IAAMrD,IAAI,GAAG,IAAI,CAACsF,MAAM,EAAE;IAC1B,IAAMsC,IAAI,GACR;IACA,IAAI,CAAC1C,KAAK,CAAC,IAAI,CAACA,KAAK,CAACQ,MAAM,GAAG,CAAC,CAAC;IACnCkC,IAAI,CAACe,GAAG,GAAG3I,IAAI;EACjB;EACA;;EAEA,SAASoC,wBAAwB,CAACuF,KAAK,EAAE;IACvC,IAAMC,IAAI,GACR;IACA,IAAI,CAAC1C,KAAK,CAAC,IAAI,CAACA,KAAK,CAACQ,MAAM,GAAG,CAAC,CAAC;IAEnC,IAAI,CAACkC,IAAI,CAACgB,KAAK,EAAE;MACf,IAAMA,KAAK,GAAG,IAAI,CAACzC,cAAc,CAACwB,KAAK,CAAC,CAACjC,MAAM;MAC/CkC,IAAI,CAACgB,KAAK,GAAGA,KAAK;IACpB;EACF;EACA;;EAEA,SAASjE,uBAAuB,GAAG;IACjCY,OAAO,CAAC,8BAA8B,EAAE,IAAI,CAAC;EAC/C;EACA;;EAEA,SAASd,+BAA+B,CAACkD,KAAK,EAAE;IAC9C,IAAMC,IAAI,GACR;IACA,IAAI,CAAC1C,KAAK,CAAC,IAAI,CAACA,KAAK,CAACQ,MAAM,GAAG,CAAC,CAAC;IACnCkC,IAAI,CAACgB,KAAK,GAAG,IAAI,CAACzC,cAAc,CAACwB,KAAK,CAAC,CAACkB,UAAU,CAAC,CAAC,CAAC,KAAK,EAAE,GAAG,CAAC,GAAG,CAAC;EACtE;EACA;;EAEA,SAAStE,mBAAmB,GAAG;IAC7BgB,OAAO,CAAC,8BAA8B,CAAC;EACzC;EACA;;EAEA,SAAStG,WAAW,CAAC0I,KAAK,EAAE;IAC1B,IAAMG,MAAM,GACV;IACA,IAAI,CAAC5C,KAAK,CAAC,IAAI,CAACA,KAAK,CAACQ,MAAM,GAAG,CAAC,CAAC;IACnC;;IAEA,IAAIE,IAAI,GAAGkC,MAAM,CAAC7C,QAAQ,CAAC6C,MAAM,CAAC7C,QAAQ,CAACS,MAAM,GAAG,CAAC,CAAC;IAEtD,IAAI,CAACE,IAAI,IAAIA,IAAI,CAACZ,IAAI,KAAK,MAAM,EAAE;MACjC;MACAY,IAAI,GAAGkD,IAAI,EAAE,EAAC;;MAEdlD,IAAI,CAACS,QAAQ,GAAG;QACdC,KAAK,EAAEC,KAAK,CAACoB,KAAK,CAACrB,KAAK;MAC1B,CAAC,EAAC;;MAEFwB,MAAM,CAAC7C,QAAQ,CAACU,IAAI,CAACC,IAAI,CAAC;IAC5B;IAEA,IAAI,CAACV,KAAK,CAACS,IAAI,CAACC,IAAI,CAAC;EACvB;EACA;;EAEA,SAASpD,UAAU,CAACmF,KAAK,EAAE;IACzB,IAAM/B,IAAI,GAAG,IAAI,CAACV,KAAK,CAACW,GAAG,EAAE;IAC7BD,IAAI,CAAC3H,KAAK,IAAI,IAAI,CAACkI,cAAc,CAACwB,KAAK,CAAC;IACxC/B,IAAI,CAACS,QAAQ,CAACM,GAAG,GAAGJ,KAAK,CAACoB,KAAK,CAAChB,GAAG,CAAC;EACtC;EACA;;EAEA,SAAS3C,gBAAgB,CAAC2D,KAAK,EAAE;IAC/B,IAAMtC,OAAO,GAAG,IAAI,CAACH,KAAK,CAAC,IAAI,CAACA,KAAK,CAACQ,MAAM,GAAG,CAAC,CAAC;;IAEjD;IACA,IAAIF,OAAO,CAAC,aAAa,CAAC,EAAE;MAC1B,IAAMI,IAAI,GAAGP,OAAO,CAACJ,QAAQ,CAACI,OAAO,CAACJ,QAAQ,CAACS,MAAM,GAAG,CAAC,CAAC;MAC1DE,IAAI,CAACS,QAAQ,CAACM,GAAG,GAAGJ,KAAK,CAACoB,KAAK,CAAChB,GAAG,CAAC;MACpCpB,OAAO,CAAC,aAAa,CAAC;MACtB;IACF;IAEA,IACE,CAACC,OAAO,CAAC,8BAA8B,CAAC,IACxChH,MAAM,CAACG,cAAc,CAACoK,QAAQ,CAAC1D,OAAO,CAACL,IAAI,CAAC,EAC5C;MACA/F,WAAW,CAAC+G,IAAI,CAAC,IAAI,EAAE2B,KAAK,CAAC;MAC7BnF,UAAU,CAACwD,IAAI,CAAC,IAAI,EAAE2B,KAAK,CAAC;IAC9B;EACF;EACA;;EAEA,SAASnE,eAAe,GAAG;IACzB+B,OAAO,CAAC,aAAa,EAAE,IAAI,CAAC;EAC9B;EACA;;EAEA,SAAS9B,cAAc,GAAG;IACxB,IAAMzD,IAAI,GAAG,IAAI,CAACsF,MAAM,EAAE;IAC1B,IAAMsC,IAAI,GACR;IACA,IAAI,CAAC1C,KAAK,CAAC,IAAI,CAACA,KAAK,CAACQ,MAAM,GAAG,CAAC,CAAC;IACnCkC,IAAI,CAAC3J,KAAK,GAAG+B,IAAI;EACnB;EACA;;EAEA,SAAS0D,cAAc,GAAG;IACxB,IAAM1D,IAAI,GAAG,IAAI,CAACsF,MAAM,EAAE;IAC1B,IAAMsC,IAAI,GACR;IACA,IAAI,CAAC1C,KAAK,CAAC,IAAI,CAACA,KAAK,CAACQ,MAAM,GAAG,CAAC,CAAC;IACnCkC,IAAI,CAAC3J,KAAK,GAAG+B,IAAI;EACnB;EACA;;EAEA,SAASoD,cAAc,GAAG;IACxB,IAAMpD,IAAI,GAAG,IAAI,CAACsF,MAAM,EAAE;IAC1B,IAAMsC,IAAI,GACR;IACA,IAAI,CAAC1C,KAAK,CAAC,IAAI,CAACA,KAAK,CAACQ,MAAM,GAAG,CAAC,CAAC;IACnCkC,IAAI,CAAC3J,KAAK,GAAG+B,IAAI;EACnB;EACA;;EAEA,SAASiE,UAAU,GAAG;IACpB,IAAMoB,OAAO,GACX;IACA,IAAI,CAACH,KAAK,CAAC,IAAI,CAACA,KAAK,CAACQ,MAAM,GAAG,CAAC,CAAC,EAAC;;IAEpC,IAAIF,OAAO,CAAC,aAAa,CAAC,EAAE;MAC1BH,OAAO,CAACL,IAAI,IAAI,WAAW,EAAC;;MAE5BK,OAAO,CAAC2D,aAAa,GAAGxD,OAAO,CAAC,eAAe,CAAC,IAAI,UAAU,EAAC;;MAE/D,OAAOH,OAAO,CAACsD,GAAG;MAClB,OAAOtD,OAAO,CAACqD,KAAK;IACtB,CAAC,MAAM;MACL;MACA,OAAOrD,OAAO,CAACmD,UAAU,EAAC;;MAE1B,OAAOnD,OAAO,CAACrE,KAAK;IACtB;IAEAuE,OAAO,CAAC,eAAe,CAAC;EAC1B;EACA;;EAEA,SAAS5B,WAAW,GAAG;IACrB,IAAM0B,OAAO,GACX;IACA,IAAI,CAACH,KAAK,CAAC,IAAI,CAACA,KAAK,CAACQ,MAAM,GAAG,CAAC,CAAC,EAAC;;IAEpC,IAAIF,OAAO,CAAC,aAAa,CAAC,EAAE;MAC1BH,OAAO,CAACL,IAAI,IAAI,WAAW,EAAC;;MAE5BK,OAAO,CAAC2D,aAAa,GAAGxD,OAAO,CAAC,eAAe,CAAC,IAAI,UAAU,EAAC;;MAE/D,OAAOH,OAAO,CAACsD,GAAG;MAClB,OAAOtD,OAAO,CAACqD,KAAK;IACtB,CAAC,MAAM;MACL;MACA,OAAOrD,OAAO,CAACmD,UAAU,EAAC;;MAE1B,OAAOnD,OAAO,CAACrE,KAAK;IACtB;IAEAuE,OAAO,CAAC,eAAe,CAAC;EAC1B;EACA;;EAEA,SAASzB,eAAe,CAAC6D,KAAK,EAAE;IAC9B,IAAMO,QAAQ,GACZ;IACA,IAAI,CAAChD,KAAK,CAAC,IAAI,CAACA,KAAK,CAACQ,MAAM,GAAG,CAAC,CAAC;IACnC,IAAMuD,MAAM,GAAG,IAAI,CAAC9C,cAAc,CAACwB,KAAK,CAAC;IACzCO,QAAQ,CAAClH,KAAK,GAAGtD,YAAY,CAACuL,MAAM,CAAC;IACrCf,QAAQ,CAACM,UAAU,GAAG7K,mBAAmB,CAACsL,MAAM,CAAC,CAACR,WAAW,EAAE;EACjE;EACA;;EAEA,SAAS7E,WAAW,GAAG;IACrB,IAAMsF,QAAQ,GACZ;IACA,IAAI,CAAChE,KAAK,CAAC,IAAI,CAACA,KAAK,CAACQ,MAAM,GAAG,CAAC,CAAC;IACnC,IAAMzH,KAAK,GAAG,IAAI,CAACqH,MAAM,EAAE;IAC3B,IAAMsC,IAAI,GACR;IACA,IAAI,CAAC1C,KAAK,CAAC,IAAI,CAACA,KAAK,CAACQ,MAAM,GAAG,CAAC,CAAC,EAAC;;IAEpCH,OAAO,CAAC,aAAa,EAAE,IAAI,CAAC;IAE5B,IAAIqC,IAAI,CAAC5C,IAAI,KAAK,MAAM,EAAE;MACxB;MACA4C,IAAI,CAAC3C,QAAQ,GAAGiE,QAAQ,CAACjE,QAAQ;IACnC,CAAC,MAAM;MACL2C,IAAI,CAACuB,GAAG,GAAGlL,KAAK;IAClB;EACF;EACA;;EAEA,SAASkG,+BAA+B,GAAG;IACzC,IAAMnE,IAAI,GAAG,IAAI,CAACsF,MAAM,EAAE;IAC1B,IAAMsC,IAAI,GACR;IACA,IAAI,CAAC1C,KAAK,CAAC,IAAI,CAACA,KAAK,CAACQ,MAAM,GAAG,CAAC,CAAC;IACnCkC,IAAI,CAACe,GAAG,GAAG3I,IAAI;EACjB;EACA;;EAEA,SAASoE,yBAAyB,GAAG;IACnC,IAAMpE,IAAI,GAAG,IAAI,CAACsF,MAAM,EAAE;IAC1B,IAAMsC,IAAI,GACR;IACA,IAAI,CAAC1C,KAAK,CAAC,IAAI,CAACA,KAAK,CAACQ,MAAM,GAAG,CAAC,CAAC;IACnCkC,IAAI,CAACc,KAAK,GAAG1I,IAAI;EACnB;EACA;;EAEA,SAASsE,cAAc,GAAG;IACxBiB,OAAO,CAAC,aAAa,CAAC;EACxB;EACA;;EAEA,SAAS7D,gBAAgB,GAAG;IAC1B6D,OAAO,CAAC,eAAe,EAAE,WAAW,CAAC;EACvC;EACA;;EAEA,SAASrB,qBAAqB,CAACyD,KAAK,EAAE;IACpC,IAAM3G,KAAK,GAAG,IAAI,CAACsE,MAAM,EAAE;IAC3B,IAAMsC,IAAI,GACR;IACA,IAAI,CAAC1C,KAAK,CAAC,IAAI,CAACA,KAAK,CAACQ,MAAM,GAAG,CAAC,CAAC;IACnCkC,IAAI,CAAC5G,KAAK,GAAGA,KAAK;IAClB4G,IAAI,CAACY,UAAU,GAAG7K,mBAAmB,CACnC,IAAI,CAACwI,cAAc,CAACwB,KAAK,CAAC,CAC3B,CAACc,WAAW,EAAE;IACflD,OAAO,CAAC,eAAe,EAAE,MAAM,CAAC;EAClC;EACA;;EAEA,SAAS7C,8BAA8B,CAACiF,KAAK,EAAE;IAC7CpC,OAAO,CAAC,wBAAwB,EAAEoC,KAAK,CAAC3C,IAAI,CAAC;EAC/C;EACA;;EAEA,SAASnC,6BAA6B,CAAC8E,KAAK,EAAE;IAC5C,IAAM3H,IAAI,GAAG,IAAI,CAACmG,cAAc,CAACwB,KAAK,CAAC;IACvC,IAAM3C,IAAI,GAAGQ,OAAO,CAAC,wBAAwB,CAAC;IAC9C;;IAEA,IAAIvH,KAAK;IAET,IAAI+G,IAAI,EAAE;MACR/G,KAAK,GAAGR,+BAA+B,CACrCuC,IAAI,EACJgF,IAAI,KAAK,iCAAiC,GAAG,EAAE,GAAG,EAAE,CACrD;MACDO,OAAO,CAAC,wBAAwB,CAAC;IACnC,CAAC,MAAM;MACL;MACA;MACA;MACAtH,KAAK,GAAGL,6BAA6B,CAACoC,IAAI,CAAC;IAC7C;IAEA,IAAM4F,IAAI,GAAG,IAAI,CAACV,KAAK,CAACW,GAAG,EAAE;IAC7BD,IAAI,CAAC3H,KAAK,IAAIA,KAAK;IACnB2H,IAAI,CAACS,QAAQ,CAACM,GAAG,GAAGJ,KAAK,CAACoB,KAAK,CAAChB,GAAG,CAAC;EACtC;EACA;;EAEA,SAASrE,sBAAsB,CAACqF,KAAK,EAAE;IACrCnF,UAAU,CAACwD,IAAI,CAAC,IAAI,EAAE2B,KAAK,CAAC;IAC5B,IAAMC,IAAI,GACR;IACA,IAAI,CAAC1C,KAAK,CAAC,IAAI,CAACA,KAAK,CAACQ,MAAM,GAAG,CAAC,CAAC;IACnCkC,IAAI,CAACe,GAAG,GAAG,IAAI,CAACxC,cAAc,CAACwB,KAAK,CAAC;EACvC;EACA;;EAEA,SAAStF,mBAAmB,CAACsF,KAAK,EAAE;IAClCnF,UAAU,CAACwD,IAAI,CAAC,IAAI,EAAE2B,KAAK,CAAC;IAC5B,IAAMC,IAAI,GACR;IACA,IAAI,CAAC1C,KAAK,CAAC,IAAI,CAACA,KAAK,CAACQ,MAAM,GAAG,CAAC,CAAC;IACnCkC,IAAI,CAACe,GAAG,GAAG,SAAS,GAAG,IAAI,CAACxC,cAAc,CAACwB,KAAK,CAAC;EACnD,CAAC,CAAC;EACF;EACA;;EAEA;;EAEA,SAAStI,UAAU,GAAG;IACpB,OAAO;MACL2F,IAAI,EAAE,YAAY;MAClBC,QAAQ,EAAE;IACZ,CAAC;EACH;EACA;;EAEA,SAASxF,QAAQ,GAAG;IAClB,OAAO;MACLuF,IAAI,EAAE,MAAM;MACZqD,IAAI,EAAE,IAAI;MACVC,IAAI,EAAE,IAAI;MACVrK,KAAK,EAAE;IACT,CAAC;EACH;EACA;;EAEA,SAAS6B,QAAQ,GAAG;IAClB,OAAO;MACLkF,IAAI,EAAE,YAAY;MAClB/G,KAAK,EAAE;IACT,CAAC;EACH;EACA;;EAEA,SAASiC,UAAU,GAAG;IACpB,OAAO;MACL8E,IAAI,EAAE,YAAY;MAClBwD,UAAU,EAAE,EAAE;MACdxH,KAAK,EAAE,IAAI;MACX0H,KAAK,EAAE,IAAI;MACXC,GAAG,EAAE;IACP,CAAC;EACH;EACA;;EAEA,SAASrI,QAAQ,GAAG;IAClB,OAAO;MACL0E,IAAI,EAAE,UAAU;MAChBC,QAAQ,EAAE;IACZ,CAAC;EACH;EACA;;EAEA,SAAS7F,OAAO,GAAG;IACjB;IACA,OAAO;MACL4F,IAAI,EAAE,SAAS;MACf4D,KAAK,EAAExK,SAAS;MAChB6G,QAAQ,EAAE;IACZ,CAAC;EACH;EACA;;EAEA,SAASzE,SAAS,GAAG;IACnB,OAAO;MACLwE,IAAI,EAAE;IACR,CAAC;EACH;EACA;;EAEA,SAASrE,IAAI,GAAG;IACd,OAAO;MACLqE,IAAI,EAAE,MAAM;MACZ/G,KAAK,EAAE;IACT,CAAC;EACH;EACA;;EAEA,SAAS8C,KAAK,GAAG;IACf,OAAO;MACLiE,IAAI,EAAE,OAAO;MACb0D,KAAK,EAAE,IAAI;MACXC,GAAG,EAAE,EAAE;MACPQ,GAAG,EAAE;IACP,CAAC;EACH;EACA;;EAEA,SAASpK,IAAI,GAAG;IACd,OAAO;MACLiG,IAAI,EAAE,MAAM;MACZ0D,KAAK,EAAE,IAAI;MACXC,GAAG,EAAE,EAAE;MACP1D,QAAQ,EAAE;IACZ,CAAC;EACH;EACA;AACF;AACA;AACA;;EAEE,SAAS5D,IAAI,CAACsG,KAAK,EAAE;IACnB,OAAO;MACL3C,IAAI,EAAE,MAAM;MACZoE,OAAO,EAAEzB,KAAK,CAAC3C,IAAI,KAAK,aAAa;MACrCsB,KAAK,EAAE,IAAI;MACX;MACA+C,MAAM,EAAE1B,KAAK,CAACP,OAAO;MACrBnC,QAAQ,EAAE;IACZ,CAAC;EACH;EACA;AACF;AACA;AACA;;EAEE,SAAShE,QAAQ,CAAC0G,KAAK,EAAE;IACvB,OAAO;MACL3C,IAAI,EAAE,UAAU;MAChB;MACAqE,MAAM,EAAE1B,KAAK,CAACP,OAAO;MACrBkC,OAAO,EAAE,IAAI;MACbrE,QAAQ,EAAE;IACZ,CAAC;EACH;EACA;;EAEA,SAASzD,SAAS,GAAG;IACnB,OAAO;MACLwD,IAAI,EAAE,WAAW;MACjBC,QAAQ,EAAE;IACZ,CAAC;EACH;EACA;;EAEA,SAASlD,MAAM,GAAG;IAChB,OAAO;MACLiD,IAAI,EAAE,QAAQ;MACdC,QAAQ,EAAE;IACZ,CAAC;EACH;EACA;;EAEA,SAAS6D,IAAI,GAAG;IACd,OAAO;MACL9D,IAAI,EAAE,MAAM;MACZ/G,KAAK,EAAE;IACT,CAAC;EACH;EACA;;EAEA,SAAS+D,aAAa,GAAG;IACvB,OAAO;MACLgD,IAAI,EAAE;IACR,CAAC;EACH;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASvG,SAAS,CAAC8K,QAAQ,EAAEC,UAAU,EAAE;EACvC,IAAI/D,KAAK,GAAG,CAAC,CAAC;EAEd,OAAO,EAAEA,KAAK,GAAG+D,UAAU,CAAC9D,MAAM,EAAE;IAClC,IAAMzH,KAAK,GAAGuL,UAAU,CAAC/D,KAAK,CAAC;IAE/B,IAAIgE,KAAK,CAACC,OAAO,CAACzL,KAAK,CAAC,EAAE;MACxBQ,SAAS,CAAC8K,QAAQ,EAAEtL,KAAK,CAAC;IAC5B,CAAC,MAAM;MACL0L,SAAS,CAACJ,QAAQ,EAAEtL,KAAK,CAAC;IAC5B;EACF;EAEA,OAAOsL,QAAQ;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASI,SAAS,CAACJ,QAAQ,EAAEI,SAAS,EAAE;EACtC;EACA,IAAIrC,GAAG;EAEP,KAAKA,GAAG,IAAIqC,SAAS,EAAE;IACrB,IAAI7L,GAAG,CAACkI,IAAI,CAAC2D,SAAS,EAAErC,GAAG,CAAC,EAAE;MAC5B,IAAMjG,IAAI,GAAGiG,GAAG,KAAK,gBAAgB,IAAIA,GAAG,KAAK,YAAY;MAC7D,IAAMsC,KAAK,GAAG9L,GAAG,CAACkI,IAAI,CAACuD,QAAQ,EAAEjC,GAAG,CAAC,GAAGiC,QAAQ,CAACjC,GAAG,CAAC,GAAGlJ,SAAS;MACjE;;MAEA,IAAMyL,IAAI,GAAGD,KAAK,KAAKL,QAAQ,CAACjC,GAAG,CAAC,GAAGjG,IAAI,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;MACtD,IAAMyI,KAAK,GAAGH,SAAS,CAACrC,GAAG,CAAC;MAE5B,IAAIwC,KAAK,EAAE;QACT,IAAIzI,IAAI,EAAE;UACR;UACAkI,QAAQ,CAACjC,GAAG,CAAC,gCAAOuC,IAAI,sBAAKC,KAAK,EAAC;QACrC,CAAC,MAAM;UACL7D,MAAM,CAACC,MAAM,CAAC2D,IAAI,EAAEC,KAAK,CAAC;QAC5B;MACF;IACF;EACF;AACF;AACA;;AAEA,SAAS1D,cAAc,CAACyD,IAAI,EAAEC,KAAK,EAAE;EACnC,IAAID,IAAI,EAAE;IACR,MAAM,IAAI5B,KAAK,CACb,gBAAgB,GACd4B,IAAI,CAAC7E,IAAI,GACT,KAAK,GACLnH,iBAAiB,CAAC;MAChByI,KAAK,EAAEuD,IAAI,CAACvD,KAAK;MACjBK,GAAG,EAAEkD,IAAI,CAAClD;IACZ,CAAC,CAAC,GACF,yBAAyB,GACzBmD,KAAK,CAAC9E,IAAI,GACV,KAAK,GACLnH,iBAAiB,CAAC;MAChByI,KAAK,EAAEwD,KAAK,CAACxD,KAAK;MAClBK,GAAG,EAAEmD,KAAK,CAACnD;IACb,CAAC,CAAC,GACF,WAAW,CACd;EACH,CAAC,MAAM;IACL,MAAM,IAAIsB,KAAK,CACb,mCAAmC,GACjC6B,KAAK,CAAC9E,IAAI,GACV,KAAK,GACLnH,iBAAiB,CAAC;MAChByI,KAAK,EAAEwD,KAAK,CAACxD,KAAK;MAClBK,GAAG,EAAEmD,KAAK,CAACnD;IACb,CAAC,CAAC,GACF,iBAAiB,CACpB;EACH;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}
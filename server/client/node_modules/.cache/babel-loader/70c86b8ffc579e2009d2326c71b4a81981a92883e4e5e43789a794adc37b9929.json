{"ast":null,"code":"export function selectWord(_ref) {\n  var text = _ref.text,\n    selection = _ref.selection;\n  if (text && text.length && selection.start === selection.end) {\n    // the user is pointing to a word\n    return getSurroundingWord(text, selection.start);\n  }\n  return selection;\n}\n\n/**\n *  Gets the number of line-breaks that would have to be inserted before the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the previous text\n */\nexport function getBreaksNeededForEmptyLineBefore(text, startPosition) {\n  if (text === void 0) {\n    text = '';\n  }\n  if (startPosition === 0) return 0;\n\n  // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  var neededBreaks = 2;\n  var isInFirstLine = true;\n  for (var i = startPosition - 1; i >= 0 && neededBreaks >= 0; i--) {\n    switch (text.charCodeAt(i)) {\n      case 32:\n        // blank space\n        continue;\n      case 10:\n        // line break\n        neededBreaks--;\n        isInFirstLine = false;\n        break;\n      default:\n        return neededBreaks;\n    }\n  }\n  return isInFirstLine ? 0 : neededBreaks;\n}\n\n/**\n *  Gets the number of line-breaks that would have to be inserted after the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the next text\n */\nexport function getBreaksNeededForEmptyLineAfter(text, startPosition) {\n  if (text === void 0) {\n    text = '';\n  }\n  if (startPosition === text.length - 1) return 0;\n\n  // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  var neededBreaks = 2;\n  var isInLastLine = true;\n  for (var i = startPosition; i < text.length && neededBreaks >= 0; i++) {\n    switch (text.charCodeAt(i)) {\n      case 32:\n        continue;\n      case 10:\n        {\n          neededBreaks--;\n          isInLastLine = false;\n          break;\n        }\n      default:\n        return neededBreaks;\n    }\n  }\n  return isInLastLine ? 0 : neededBreaks;\n}\nexport function getSurroundingWord(text, position) {\n  if (!text) throw Error(\"Argument 'text' should be truthy\");\n  var isWordDelimiter = function isWordDelimiter(c) {\n    return c === ' ' || c.charCodeAt(0) === 10;\n  };\n\n  // leftIndex is initialized to 0 because if selection is 0, it won't even enter the iteration\n  var start = 0;\n  // rightIndex is initialized to text.length because if selection is equal to text.length it won't even enter the interation\n  var end = text.length;\n\n  // iterate to the left\n  for (var i = position; i - 1 > -1; i--) {\n    if (isWordDelimiter(text[i - 1])) {\n      start = i;\n      break;\n    }\n  }\n\n  // iterate to the right\n  for (var _i = position; _i < text.length; _i++) {\n    if (isWordDelimiter(text[_i])) {\n      end = _i;\n      break;\n    }\n  }\n  return {\n    start: start,\n    end: end\n  };\n}","map":{"version":3,"mappings":"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","names":["selectWord","text","_ref","selection","length","start","end","getSurroundingWord","getBreaksNeededForEmptyLineBefore","startPosition","neededBreaks","isInFirstLine","i","charCodeAt","getBreaksNeededForEmptyLineAfter","isInLastLine","position","Error","isWordDelimiter","c"],"sources":["/home/kty/workspace/seb41_pre_001/client/node_modules/@uiw/react-md-editor/src/utils/markdownUtils.ts"],"sourcesContent":["import { TextRange } from '../commands';\n\nexport interface TextSection {\n  text: string;\n  selection: TextRange;\n}\n\nexport function selectWord({ text, selection }: TextSection): TextRange {\n  if (text && text.length && selection.start === selection.end) {\n    // the user is pointing to a word\n    return getSurroundingWord(text, selection.start);\n  }\n  return selection;\n}\n\n/**\n *  Gets the number of line-breaks that would have to be inserted before the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the previous text\n */\nexport function getBreaksNeededForEmptyLineBefore(text = '', startPosition: number): number {\n  if (startPosition === 0) return 0;\n\n  // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  let neededBreaks = 2;\n  let isInFirstLine = true;\n  for (let i = startPosition - 1; i >= 0 && neededBreaks >= 0; i--) {\n    switch (text.charCodeAt(i)) {\n      case 32: // blank space\n        continue;\n      case 10: // line break\n        neededBreaks--;\n        isInFirstLine = false;\n        break;\n      default:\n        return neededBreaks;\n    }\n  }\n  return isInFirstLine ? 0 : neededBreaks;\n}\n\n/**\n *  Gets the number of line-breaks that would have to be inserted after the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the next text\n */\nexport function getBreaksNeededForEmptyLineAfter(text = '', startPosition: number): number {\n  if (startPosition === text.length - 1) return 0;\n\n  // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  let neededBreaks = 2;\n  let isInLastLine = true;\n  for (let i = startPosition; i < text.length && neededBreaks >= 0; i++) {\n    switch (text.charCodeAt(i)) {\n      case 32:\n        continue;\n      case 10: {\n        neededBreaks--;\n        isInLastLine = false;\n        break;\n      }\n      default:\n        return neededBreaks;\n    }\n  }\n  return isInLastLine ? 0 : neededBreaks;\n}\n\nexport function getSurroundingWord(text: string, position: number): TextRange {\n  if (!text) throw Error(\"Argument 'text' should be truthy\");\n\n  const isWordDelimiter = (c: string) => c === ' ' || c.charCodeAt(0) === 10;\n\n  // leftIndex is initialized to 0 because if selection is 0, it won't even enter the iteration\n  let start = 0;\n  // rightIndex is initialized to text.length because if selection is equal to text.length it won't even enter the interation\n  let end = text.length;\n\n  // iterate to the left\n  for (let i = position; i - 1 > -1; i--) {\n    if (isWordDelimiter(text[i - 1])) {\n      start = i;\n      break;\n    }\n  }\n\n  // iterate to the right\n  for (let i = position; i < text.length; i++) {\n    if (isWordDelimiter(text[i])) {\n      end = i;\n      break;\n    }\n  }\n\n  return { start, end };\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
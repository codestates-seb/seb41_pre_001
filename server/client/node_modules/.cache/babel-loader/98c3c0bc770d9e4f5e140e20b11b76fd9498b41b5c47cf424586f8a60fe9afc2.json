{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport { asciiAlpha, asciiAlphanumeric, asciiControl, asciiDigit, markdownLineEndingOrSpace, markdownLineEnding, unicodePunctuation, unicodeWhitespace } from 'micromark-util-character';\nvar www = {\n  tokenize: tokenizeWww,\n  partial: true\n};\nvar domain = {\n  tokenize: tokenizeDomain,\n  partial: true\n};\nvar path = {\n  tokenize: tokenizePath,\n  partial: true\n};\nvar punctuation = {\n  tokenize: tokenizePunctuation,\n  partial: true\n};\nvar namedCharacterReference = {\n  tokenize: tokenizeNamedCharacterReference,\n  partial: true\n};\nvar wwwAutolink = {\n  tokenize: tokenizeWwwAutolink,\n  previous: previousWww\n};\nvar httpAutolink = {\n  tokenize: tokenizeHttpAutolink,\n  previous: previousHttp\n};\nvar emailAutolink = {\n  tokenize: tokenizeEmailAutolink,\n  previous: previousEmail\n};\n/** @type {ConstructRecord} */\n\nvar text = {};\n/** @type {Extension} */\n\nexport var gfmAutolinkLiteral = {\n  text: text\n};\nvar code = 48; // Add alphanumerics.\n\nwhile (code < 123) {\n  text[code] = emailAutolink;\n  code++;\n  if (code === 58) code = 65;else if (code === 91) code = 97;\n}\ntext[43] = emailAutolink;\ntext[45] = emailAutolink;\ntext[46] = emailAutolink;\ntext[95] = emailAutolink;\ntext[72] = [emailAutolink, httpAutolink];\ntext[104] = [emailAutolink, httpAutolink];\ntext[87] = [emailAutolink, wwwAutolink];\ntext[119] = [emailAutolink, wwwAutolink];\n/** @type {Tokenizer} */\n\nfunction tokenizeEmailAutolink(effects, ok, nok) {\n  var self = this;\n  /** @type {boolean} */\n\n  var hasDot;\n  /** @type {boolean|undefined} */\n\n  var hasDigitInLastSegment;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if (!gfmAtext(code) || !previousEmail(self.previous) || previousUnbalanced(self.events)) {\n      return nok(code);\n    }\n    effects.enter('literalAutolink');\n    effects.enter('literalAutolinkEmail');\n    return atext(code);\n  }\n  /** @type {State} */\n\n  function atext(code) {\n    if (gfmAtext(code)) {\n      effects.consume(code);\n      return atext;\n    }\n    if (code === 64) {\n      effects.consume(code);\n      return label;\n    }\n    return nok(code);\n  }\n  /** @type {State} */\n\n  function label(code) {\n    if (code === 46) {\n      return effects.check(punctuation, done, dotContinuation)(code);\n    }\n    if (code === 45 || code === 95) {\n      return effects.check(punctuation, nok, dashOrUnderscoreContinuation)(code);\n    }\n    if (asciiAlphanumeric(code)) {\n      if (!hasDigitInLastSegment && asciiDigit(code)) {\n        hasDigitInLastSegment = true;\n      }\n      effects.consume(code);\n      return label;\n    }\n    return done(code);\n  }\n  /** @type {State} */\n\n  function dotContinuation(code) {\n    effects.consume(code);\n    hasDot = true;\n    hasDigitInLastSegment = undefined;\n    return label;\n  }\n  /** @type {State} */\n\n  function dashOrUnderscoreContinuation(code) {\n    effects.consume(code);\n    return afterDashOrUnderscore;\n  }\n  /** @type {State} */\n\n  function afterDashOrUnderscore(code) {\n    if (code === 46) {\n      return effects.check(punctuation, nok, dotContinuation)(code);\n    }\n    return label(code);\n  }\n  /** @type {State} */\n\n  function done(code) {\n    if (hasDot && !hasDigitInLastSegment) {\n      effects.exit('literalAutolinkEmail');\n      effects.exit('literalAutolink');\n      return ok(code);\n    }\n    return nok(code);\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeWwwAutolink(effects, ok, nok) {\n  var self = this;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if (code !== 87 && code !== 119 || !previousWww(self.previous) || previousUnbalanced(self.events)) {\n      return nok(code);\n    }\n    effects.enter('literalAutolink');\n    effects.enter('literalAutolinkWww'); // For `www.` we check instead of attempt, because when it matches, GH\n    // treats it as part of a domain (yes, it says a valid domain must come\n    // after `www.`, but that’s not how it’s implemented by them).\n\n    return effects.check(www, effects.attempt(domain, effects.attempt(path, done), nok), nok)(code);\n  }\n  /** @type {State} */\n\n  function done(code) {\n    effects.exit('literalAutolinkWww');\n    effects.exit('literalAutolink');\n    return ok(code);\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeHttpAutolink(effects, ok, nok) {\n  var self = this;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if (code !== 72 && code !== 104 || !previousHttp(self.previous) || previousUnbalanced(self.events)) {\n      return nok(code);\n    }\n    effects.enter('literalAutolink');\n    effects.enter('literalAutolinkHttp');\n    effects.consume(code);\n    return t1;\n  }\n  /** @type {State} */\n\n  function t1(code) {\n    if (code === 84 || code === 116) {\n      effects.consume(code);\n      return t2;\n    }\n    return nok(code);\n  }\n  /** @type {State} */\n\n  function t2(code) {\n    if (code === 84 || code === 116) {\n      effects.consume(code);\n      return p;\n    }\n    return nok(code);\n  }\n  /** @type {State} */\n\n  function p(code) {\n    if (code === 80 || code === 112) {\n      effects.consume(code);\n      return s;\n    }\n    return nok(code);\n  }\n  /** @type {State} */\n\n  function s(code) {\n    if (code === 83 || code === 115) {\n      effects.consume(code);\n      return colon;\n    }\n    return colon(code);\n  }\n  /** @type {State} */\n\n  function colon(code) {\n    if (code === 58) {\n      effects.consume(code);\n      return slash1;\n    }\n    return nok(code);\n  }\n  /** @type {State} */\n\n  function slash1(code) {\n    if (code === 47) {\n      effects.consume(code);\n      return slash2;\n    }\n    return nok(code);\n  }\n  /** @type {State} */\n\n  function slash2(code) {\n    if (code === 47) {\n      effects.consume(code);\n      return after;\n    }\n    return nok(code);\n  }\n  /** @type {State} */\n\n  function after(code) {\n    return code === null || asciiControl(code) || unicodeWhitespace(code) || unicodePunctuation(code) ? nok(code) : effects.attempt(domain, effects.attempt(path, done), nok)(code);\n  }\n  /** @type {State} */\n\n  function done(code) {\n    effects.exit('literalAutolinkHttp');\n    effects.exit('literalAutolink');\n    return ok(code);\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeWww(effects, ok, nok) {\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.consume(code);\n    return w2;\n  }\n  /** @type {State} */\n\n  function w2(code) {\n    if (code === 87 || code === 119) {\n      effects.consume(code);\n      return w3;\n    }\n    return nok(code);\n  }\n  /** @type {State} */\n\n  function w3(code) {\n    if (code === 87 || code === 119) {\n      effects.consume(code);\n      return dot;\n    }\n    return nok(code);\n  }\n  /** @type {State} */\n\n  function dot(code) {\n    if (code === 46) {\n      effects.consume(code);\n      return after;\n    }\n    return nok(code);\n  }\n  /** @type {State} */\n\n  function after(code) {\n    return code === null || markdownLineEnding(code) ? nok(code) : ok(code);\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeDomain(effects, ok, nok) {\n  /** @type {boolean|undefined} */\n  var hasUnderscoreInLastSegment;\n  /** @type {boolean|undefined} */\n\n  var hasUnderscoreInLastLastSegment;\n  return domain;\n  /** @type {State} */\n\n  function domain(code) {\n    if (code === 38) {\n      return effects.check(namedCharacterReference, done, punctuationContinuation)(code);\n    }\n    if (code === 46 || code === 95) {\n      return effects.check(punctuation, done, punctuationContinuation)(code);\n    } // GH documents that only alphanumerics (other than `-`, `.`, and `_`) can\n    // occur, which sounds like ASCII only, but they also support `www.點看.com`,\n    // so that’s Unicode.\n    // Instead of some new production for Unicode alphanumerics, markdown\n    // already has that for Unicode punctuation and whitespace, so use those.\n\n    if (code === null || asciiControl(code) || unicodeWhitespace(code) || code !== 45 && unicodePunctuation(code)) {\n      return done(code);\n    }\n    effects.consume(code);\n    return domain;\n  }\n  /** @type {State} */\n\n  function punctuationContinuation(code) {\n    if (code === 46) {\n      hasUnderscoreInLastLastSegment = hasUnderscoreInLastSegment;\n      hasUnderscoreInLastSegment = undefined;\n      effects.consume(code);\n      return domain;\n    }\n    if (code === 95) hasUnderscoreInLastSegment = true;\n    effects.consume(code);\n    return domain;\n  }\n  /** @type {State} */\n\n  function done(code) {\n    if (!hasUnderscoreInLastLastSegment && !hasUnderscoreInLastSegment) {\n      return ok(code);\n    }\n    return nok(code);\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizePath(effects, ok) {\n  var balance = 0;\n  return inPath;\n  /** @type {State} */\n\n  function inPath(code) {\n    if (code === 38) {\n      return effects.check(namedCharacterReference, ok, continuedPunctuation)(code);\n    }\n    if (code === 40) {\n      balance++;\n    }\n    if (code === 41) {\n      return effects.check(punctuation, parenAtPathEnd, continuedPunctuation)(code);\n    }\n    if (pathEnd(code)) {\n      return ok(code);\n    }\n    if (trailingPunctuation(code)) {\n      return effects.check(punctuation, ok, continuedPunctuation)(code);\n    }\n    effects.consume(code);\n    return inPath;\n  }\n  /** @type {State} */\n\n  function continuedPunctuation(code) {\n    effects.consume(code);\n    return inPath;\n  }\n  /** @type {State} */\n\n  function parenAtPathEnd(code) {\n    balance--;\n    return balance < 0 ? ok(code) : continuedPunctuation(code);\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeNamedCharacterReference(effects, ok, nok) {\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.consume(code);\n    return inside;\n  }\n  /** @type {State} */\n\n  function inside(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code);\n      return inside;\n    }\n    if (code === 59) {\n      effects.consume(code);\n      return after;\n    }\n    return nok(code);\n  }\n  /** @type {State} */\n\n  function after(code) {\n    // If the named character reference is followed by the end of the path, it’s\n    // not continued punctuation.\n    return pathEnd(code) ? ok(code) : nok(code);\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizePunctuation(effects, ok, nok) {\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.consume(code);\n    return after;\n  }\n  /** @type {State} */\n\n  function after(code) {\n    // Check the next.\n    if (trailingPunctuation(code)) {\n      effects.consume(code);\n      return after;\n    } // If the punctuation marker is followed by the end of the path, it’s not\n    // continued punctuation.\n\n    return pathEnd(code) ? ok(code) : nok(code);\n  }\n}\n/**\n * @param {Code} code\n * @returns {boolean}\n */\n\nfunction trailingPunctuation(code) {\n  return code === 33 || code === 34 || code === 39 || code === 41 || code === 42 || code === 44 || code === 46 || code === 58 || code === 59 || code === 60 || code === 63 || code === 95 || code === 126;\n}\n/**\n * @param {Code} code\n * @returns {boolean}\n */\n\nfunction pathEnd(code) {\n  return code === null || code === 60 || markdownLineEndingOrSpace(code);\n}\n/**\n * @param {Code} code\n * @returns {boolean}\n */\n\nfunction gfmAtext(code) {\n  return code === 43 || code === 45 || code === 46 || code === 95 || asciiAlphanumeric(code);\n}\n/** @type {Previous} */\n\nfunction previousWww(code) {\n  return code === null || code === 40 || code === 42 || code === 95 || code === 126 || markdownLineEndingOrSpace(code);\n}\n/** @type {Previous} */\n\nfunction previousHttp(code) {\n  return code === null || !asciiAlpha(code);\n}\n/** @type {Previous} */\n\nfunction previousEmail(code) {\n  return code !== 47 && previousHttp(code);\n}\n/**\n * @param {Array<Event>} events\n * @returns {boolean}\n */\n\nfunction previousUnbalanced(events) {\n  var index = events.length;\n  var result = false;\n  while (index--) {\n    var token = events[index][1];\n    if ((token.type === 'labelLink' || token.type === 'labelImage') && !token._balanced) {\n      result = true;\n      break;\n    } // @ts-expect-error If we’ve seen this token, and it was marked as not\n    // having any unbalanced bracket before it, we can exit.\n\n    if (token._gfmAutolinkLiteralWalkedInto) {\n      result = false;\n      break;\n    }\n  }\n  if (events.length > 0 && !result) {\n    // @ts-expect-error Mark the last token as “walked into” w/o finding\n    // anything.\n    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;\n  }\n  return result;\n}","map":{"version":3,"names":["asciiAlpha","asciiAlphanumeric","asciiControl","asciiDigit","markdownLineEndingOrSpace","markdownLineEnding","unicodePunctuation","unicodeWhitespace","www","tokenize","tokenizeWww","partial","domain","tokenizeDomain","path","tokenizePath","punctuation","tokenizePunctuation","namedCharacterReference","tokenizeNamedCharacterReference","wwwAutolink","tokenizeWwwAutolink","previous","previousWww","httpAutolink","tokenizeHttpAutolink","previousHttp","emailAutolink","tokenizeEmailAutolink","previousEmail","text","gfmAutolinkLiteral","code","effects","ok","nok","self","hasDot","hasDigitInLastSegment","start","gfmAtext","previousUnbalanced","events","enter","atext","consume","label","check","done","dotContinuation","dashOrUnderscoreContinuation","undefined","afterDashOrUnderscore","exit","attempt","t1","t2","p","s","colon","slash1","slash2","after","w2","w3","dot","hasUnderscoreInLastSegment","hasUnderscoreInLastLastSegment","punctuationContinuation","balance","inPath","continuedPunctuation","parenAtPathEnd","pathEnd","trailingPunctuation","inside","index","length","result","token","type","_balanced","_gfmAutolinkLiteralWalkedInto"],"sources":["/home/kty/workspace/seb41_pre_001/client/node_modules/micromark-extension-gfm-autolink-literal/lib/syntax.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {\n  asciiAlpha,\n  asciiAlphanumeric,\n  asciiControl,\n  asciiDigit,\n  markdownLineEndingOrSpace,\n  markdownLineEnding,\n  unicodePunctuation,\n  unicodeWhitespace\n} from 'micromark-util-character'\nconst www = {\n  tokenize: tokenizeWww,\n  partial: true\n}\nconst domain = {\n  tokenize: tokenizeDomain,\n  partial: true\n}\nconst path = {\n  tokenize: tokenizePath,\n  partial: true\n}\nconst punctuation = {\n  tokenize: tokenizePunctuation,\n  partial: true\n}\nconst namedCharacterReference = {\n  tokenize: tokenizeNamedCharacterReference,\n  partial: true\n}\nconst wwwAutolink = {\n  tokenize: tokenizeWwwAutolink,\n  previous: previousWww\n}\nconst httpAutolink = {\n  tokenize: tokenizeHttpAutolink,\n  previous: previousHttp\n}\nconst emailAutolink = {\n  tokenize: tokenizeEmailAutolink,\n  previous: previousEmail\n}\n/** @type {ConstructRecord} */\n\nconst text = {}\n/** @type {Extension} */\n\nexport const gfmAutolinkLiteral = {\n  text\n}\nlet code = 48 // Add alphanumerics.\n\nwhile (code < 123) {\n  text[code] = emailAutolink\n  code++\n  if (code === 58) code = 65\n  else if (code === 91) code = 97\n}\n\ntext[43] = emailAutolink\ntext[45] = emailAutolink\ntext[46] = emailAutolink\ntext[95] = emailAutolink\ntext[72] = [emailAutolink, httpAutolink]\ntext[104] = [emailAutolink, httpAutolink]\ntext[87] = [emailAutolink, wwwAutolink]\ntext[119] = [emailAutolink, wwwAutolink]\n/** @type {Tokenizer} */\n\nfunction tokenizeEmailAutolink(effects, ok, nok) {\n  const self = this\n  /** @type {boolean} */\n\n  let hasDot\n  /** @type {boolean|undefined} */\n\n  let hasDigitInLastSegment\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (\n      !gfmAtext(code) ||\n      !previousEmail(self.previous) ||\n      previousUnbalanced(self.events)\n    ) {\n      return nok(code)\n    }\n\n    effects.enter('literalAutolink')\n    effects.enter('literalAutolinkEmail')\n    return atext(code)\n  }\n  /** @type {State} */\n\n  function atext(code) {\n    if (gfmAtext(code)) {\n      effects.consume(code)\n      return atext\n    }\n\n    if (code === 64) {\n      effects.consume(code)\n      return label\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function label(code) {\n    if (code === 46) {\n      return effects.check(punctuation, done, dotContinuation)(code)\n    }\n\n    if (code === 45 || code === 95) {\n      return effects.check(punctuation, nok, dashOrUnderscoreContinuation)(code)\n    }\n\n    if (asciiAlphanumeric(code)) {\n      if (!hasDigitInLastSegment && asciiDigit(code)) {\n        hasDigitInLastSegment = true\n      }\n\n      effects.consume(code)\n      return label\n    }\n\n    return done(code)\n  }\n  /** @type {State} */\n\n  function dotContinuation(code) {\n    effects.consume(code)\n    hasDot = true\n    hasDigitInLastSegment = undefined\n    return label\n  }\n  /** @type {State} */\n\n  function dashOrUnderscoreContinuation(code) {\n    effects.consume(code)\n    return afterDashOrUnderscore\n  }\n  /** @type {State} */\n\n  function afterDashOrUnderscore(code) {\n    if (code === 46) {\n      return effects.check(punctuation, nok, dotContinuation)(code)\n    }\n\n    return label(code)\n  }\n  /** @type {State} */\n\n  function done(code) {\n    if (hasDot && !hasDigitInLastSegment) {\n      effects.exit('literalAutolinkEmail')\n      effects.exit('literalAutolink')\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeWwwAutolink(effects, ok, nok) {\n  const self = this\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (\n      (code !== 87 && code !== 119) ||\n      !previousWww(self.previous) ||\n      previousUnbalanced(self.events)\n    ) {\n      return nok(code)\n    }\n\n    effects.enter('literalAutolink')\n    effects.enter('literalAutolinkWww') // For `www.` we check instead of attempt, because when it matches, GH\n    // treats it as part of a domain (yes, it says a valid domain must come\n    // after `www.`, but that’s not how it’s implemented by them).\n\n    return effects.check(\n      www,\n      effects.attempt(domain, effects.attempt(path, done), nok),\n      nok\n    )(code)\n  }\n  /** @type {State} */\n\n  function done(code) {\n    effects.exit('literalAutolinkWww')\n    effects.exit('literalAutolink')\n    return ok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeHttpAutolink(effects, ok, nok) {\n  const self = this\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (\n      (code !== 72 && code !== 104) ||\n      !previousHttp(self.previous) ||\n      previousUnbalanced(self.events)\n    ) {\n      return nok(code)\n    }\n\n    effects.enter('literalAutolink')\n    effects.enter('literalAutolinkHttp')\n    effects.consume(code)\n    return t1\n  }\n  /** @type {State} */\n\n  function t1(code) {\n    if (code === 84 || code === 116) {\n      effects.consume(code)\n      return t2\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function t2(code) {\n    if (code === 84 || code === 116) {\n      effects.consume(code)\n      return p\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function p(code) {\n    if (code === 80 || code === 112) {\n      effects.consume(code)\n      return s\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function s(code) {\n    if (code === 83 || code === 115) {\n      effects.consume(code)\n      return colon\n    }\n\n    return colon(code)\n  }\n  /** @type {State} */\n\n  function colon(code) {\n    if (code === 58) {\n      effects.consume(code)\n      return slash1\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function slash1(code) {\n    if (code === 47) {\n      effects.consume(code)\n      return slash2\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function slash2(code) {\n    if (code === 47) {\n      effects.consume(code)\n      return after\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function after(code) {\n    return code === null ||\n      asciiControl(code) ||\n      unicodeWhitespace(code) ||\n      unicodePunctuation(code)\n      ? nok(code)\n      : effects.attempt(domain, effects.attempt(path, done), nok)(code)\n  }\n  /** @type {State} */\n\n  function done(code) {\n    effects.exit('literalAutolinkHttp')\n    effects.exit('literalAutolink')\n    return ok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeWww(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.consume(code)\n    return w2\n  }\n  /** @type {State} */\n\n  function w2(code) {\n    if (code === 87 || code === 119) {\n      effects.consume(code)\n      return w3\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function w3(code) {\n    if (code === 87 || code === 119) {\n      effects.consume(code)\n      return dot\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function dot(code) {\n    if (code === 46) {\n      effects.consume(code)\n      return after\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function after(code) {\n    return code === null || markdownLineEnding(code) ? nok(code) : ok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeDomain(effects, ok, nok) {\n  /** @type {boolean|undefined} */\n  let hasUnderscoreInLastSegment\n  /** @type {boolean|undefined} */\n\n  let hasUnderscoreInLastLastSegment\n  return domain\n  /** @type {State} */\n\n  function domain(code) {\n    if (code === 38) {\n      return effects.check(\n        namedCharacterReference,\n        done,\n        punctuationContinuation\n      )(code)\n    }\n\n    if (code === 46 || code === 95) {\n      return effects.check(punctuation, done, punctuationContinuation)(code)\n    } // GH documents that only alphanumerics (other than `-`, `.`, and `_`) can\n    // occur, which sounds like ASCII only, but they also support `www.點看.com`,\n    // so that’s Unicode.\n    // Instead of some new production for Unicode alphanumerics, markdown\n    // already has that for Unicode punctuation and whitespace, so use those.\n\n    if (\n      code === null ||\n      asciiControl(code) ||\n      unicodeWhitespace(code) ||\n      (code !== 45 && unicodePunctuation(code))\n    ) {\n      return done(code)\n    }\n\n    effects.consume(code)\n    return domain\n  }\n  /** @type {State} */\n\n  function punctuationContinuation(code) {\n    if (code === 46) {\n      hasUnderscoreInLastLastSegment = hasUnderscoreInLastSegment\n      hasUnderscoreInLastSegment = undefined\n      effects.consume(code)\n      return domain\n    }\n\n    if (code === 95) hasUnderscoreInLastSegment = true\n    effects.consume(code)\n    return domain\n  }\n  /** @type {State} */\n\n  function done(code) {\n    if (!hasUnderscoreInLastLastSegment && !hasUnderscoreInLastSegment) {\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizePath(effects, ok) {\n  let balance = 0\n  return inPath\n  /** @type {State} */\n\n  function inPath(code) {\n    if (code === 38) {\n      return effects.check(\n        namedCharacterReference,\n        ok,\n        continuedPunctuation\n      )(code)\n    }\n\n    if (code === 40) {\n      balance++\n    }\n\n    if (code === 41) {\n      return effects.check(\n        punctuation,\n        parenAtPathEnd,\n        continuedPunctuation\n      )(code)\n    }\n\n    if (pathEnd(code)) {\n      return ok(code)\n    }\n\n    if (trailingPunctuation(code)) {\n      return effects.check(punctuation, ok, continuedPunctuation)(code)\n    }\n\n    effects.consume(code)\n    return inPath\n  }\n  /** @type {State} */\n\n  function continuedPunctuation(code) {\n    effects.consume(code)\n    return inPath\n  }\n  /** @type {State} */\n\n  function parenAtPathEnd(code) {\n    balance--\n    return balance < 0 ? ok(code) : continuedPunctuation(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeNamedCharacterReference(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.consume(code)\n    return inside\n  }\n  /** @type {State} */\n\n  function inside(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return inside\n    }\n\n    if (code === 59) {\n      effects.consume(code)\n      return after\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function after(code) {\n    // If the named character reference is followed by the end of the path, it’s\n    // not continued punctuation.\n    return pathEnd(code) ? ok(code) : nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizePunctuation(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.consume(code)\n    return after\n  }\n  /** @type {State} */\n\n  function after(code) {\n    // Check the next.\n    if (trailingPunctuation(code)) {\n      effects.consume(code)\n      return after\n    } // If the punctuation marker is followed by the end of the path, it’s not\n    // continued punctuation.\n\n    return pathEnd(code) ? ok(code) : nok(code)\n  }\n}\n/**\n * @param {Code} code\n * @returns {boolean}\n */\n\nfunction trailingPunctuation(code) {\n  return (\n    code === 33 ||\n    code === 34 ||\n    code === 39 ||\n    code === 41 ||\n    code === 42 ||\n    code === 44 ||\n    code === 46 ||\n    code === 58 ||\n    code === 59 ||\n    code === 60 ||\n    code === 63 ||\n    code === 95 ||\n    code === 126\n  )\n}\n/**\n * @param {Code} code\n * @returns {boolean}\n */\n\nfunction pathEnd(code) {\n  return code === null || code === 60 || markdownLineEndingOrSpace(code)\n}\n/**\n * @param {Code} code\n * @returns {boolean}\n */\n\nfunction gfmAtext(code) {\n  return (\n    code === 43 ||\n    code === 45 ||\n    code === 46 ||\n    code === 95 ||\n    asciiAlphanumeric(code)\n  )\n}\n/** @type {Previous} */\n\nfunction previousWww(code) {\n  return (\n    code === null ||\n    code === 40 ||\n    code === 42 ||\n    code === 95 ||\n    code === 126 ||\n    markdownLineEndingOrSpace(code)\n  )\n}\n/** @type {Previous} */\n\nfunction previousHttp(code) {\n  return code === null || !asciiAlpha(code)\n}\n/** @type {Previous} */\n\nfunction previousEmail(code) {\n  return code !== 47 && previousHttp(code)\n}\n/**\n * @param {Array<Event>} events\n * @returns {boolean}\n */\n\nfunction previousUnbalanced(events) {\n  let index = events.length\n  let result = false\n\n  while (index--) {\n    const token = events[index][1]\n\n    if (\n      (token.type === 'labelLink' || token.type === 'labelImage') &&\n      !token._balanced\n    ) {\n      result = true\n      break\n    } // @ts-expect-error If we’ve seen this token, and it was marked as not\n    // having any unbalanced bracket before it, we can exit.\n\n    if (token._gfmAutolinkLiteralWalkedInto) {\n      result = false\n      break\n    }\n  }\n\n  if (events.length > 0 && !result) {\n    // @ts-expect-error Mark the last token as “walked into” w/o finding\n    // anything.\n    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true\n  }\n\n  return result\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n */\n\n/**\n * @typedef {'left'|'center'|'right'|'none'} Align\n */\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding, markdownLineEndingOrSpace, markdownSpace } from 'micromark-util-character';\n\n/** @type {Extension} */\nexport var gfmTable = {\n  flow: {\n    null: {\n      tokenize: tokenizeTable,\n      resolve: resolveTable\n    }\n  }\n};\nvar nextPrefixedOrBlank = {\n  tokenize: tokenizeNextPrefixedOrBlank,\n  partial: true\n};\n/** @type {Resolver} */\n\nfunction resolveTable(events, context) {\n  var index = -1;\n  /** @type {boolean|undefined} */\n\n  var inHead;\n  /** @type {boolean|undefined} */\n\n  var inDelimiterRow;\n  /** @type {boolean|undefined} */\n\n  var inRow;\n  /** @type {number|undefined} */\n\n  var contentStart;\n  /** @type {number|undefined} */\n\n  var contentEnd;\n  /** @type {number|undefined} */\n\n  var cellStart;\n  /** @type {boolean|undefined} */\n\n  var seenCellInRow;\n  while (++index < events.length) {\n    var token = events[index][1];\n    if (inRow) {\n      if (token.type === 'temporaryTableCellContent') {\n        contentStart = contentStart || index;\n        contentEnd = index;\n      }\n      if (\n      // Combine separate content parts into one.\n      (token.type === 'tableCellDivider' || token.type === 'tableRow') && contentEnd) {\n        var content = {\n          type: 'tableContent',\n          start: events[contentStart][1].start,\n          end: events[contentEnd][1].end\n        };\n        /** @type {Token} */\n\n        var text = {\n          type: 'chunkText',\n          start: content.start,\n          end: content.end,\n          // @ts-expect-error It’s fine.\n          contentType: 'text'\n        };\n        events.splice(contentStart, contentEnd - contentStart + 1, ['enter', content, context], ['enter', text, context], ['exit', text, context], ['exit', content, context]);\n        index -= contentEnd - contentStart - 3;\n        contentStart = undefined;\n        contentEnd = undefined;\n      }\n    }\n    if (events[index][0] === 'exit' && cellStart !== undefined && cellStart + (seenCellInRow ? 0 : 1) < index && (token.type === 'tableCellDivider' || token.type === 'tableRow' && (cellStart + 3 < index || events[cellStart][1].type !== 'whitespace'))) {\n      var cell = {\n        type: inDelimiterRow ? 'tableDelimiter' : inHead ? 'tableHeader' : 'tableData',\n        start: events[cellStart][1].start,\n        end: events[index][1].end\n      };\n      events.splice(index + (token.type === 'tableCellDivider' ? 1 : 0), 0, ['exit', cell, context]);\n      events.splice(cellStart, 0, ['enter', cell, context]);\n      index += 2;\n      cellStart = index + 1;\n      seenCellInRow = true;\n    }\n    if (token.type === 'tableRow') {\n      inRow = events[index][0] === 'enter';\n      if (inRow) {\n        cellStart = index + 1;\n        seenCellInRow = false;\n      }\n    }\n    if (token.type === 'tableDelimiterRow') {\n      inDelimiterRow = events[index][0] === 'enter';\n      if (inDelimiterRow) {\n        cellStart = index + 1;\n        seenCellInRow = false;\n      }\n    }\n    if (token.type === 'tableHead') {\n      inHead = events[index][0] === 'enter';\n    }\n  }\n  return events;\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeTable(effects, ok, nok) {\n  var self = this;\n  /** @type {Array<Align>} */\n\n  var align = [];\n  var tableHeaderCount = 0;\n  /** @type {boolean|undefined} */\n\n  var seenDelimiter;\n  /** @type {boolean|undefined} */\n\n  var hasDash;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    // @ts-expect-error Custom.\n    effects.enter('table')._align = align;\n    effects.enter('tableHead');\n    effects.enter('tableRow'); // If we start with a pipe, we open a cell marker.\n\n    if (code === 124) {\n      return cellDividerHead(code);\n    }\n    tableHeaderCount++;\n    effects.enter('temporaryTableCellContent'); // Can’t be space or eols at the start of a construct, so we’re in a cell.\n\n    return inCellContentHead(code);\n  }\n  /** @type {State} */\n\n  function cellDividerHead(code) {\n    effects.enter('tableCellDivider');\n    effects.consume(code);\n    effects.exit('tableCellDivider');\n    seenDelimiter = true;\n    return cellBreakHead;\n  }\n  /** @type {State} */\n\n  function cellBreakHead(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return atRowEndHead(code);\n    }\n    if (markdownSpace(code)) {\n      effects.enter('whitespace');\n      effects.consume(code);\n      return inWhitespaceHead;\n    }\n    if (seenDelimiter) {\n      seenDelimiter = undefined;\n      tableHeaderCount++;\n    }\n    if (code === 124) {\n      return cellDividerHead(code);\n    } // Anything else is cell content.\n\n    effects.enter('temporaryTableCellContent');\n    return inCellContentHead(code);\n  }\n  /** @type {State} */\n\n  function inWhitespaceHead(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return inWhitespaceHead;\n    }\n    effects.exit('whitespace');\n    return cellBreakHead(code);\n  }\n  /** @type {State} */\n\n  function inCellContentHead(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {\n      effects.exit('temporaryTableCellContent');\n      return cellBreakHead(code);\n    }\n    effects.consume(code);\n    return code === 92 ? inCellContentEscapeHead : inCellContentHead;\n  }\n  /** @type {State} */\n\n  function inCellContentEscapeHead(code) {\n    if (code === 92 || code === 124) {\n      effects.consume(code);\n      return inCellContentHead;\n    } // Anything else.\n\n    return inCellContentHead(code);\n  }\n  /** @type {State} */\n\n  function atRowEndHead(code) {\n    if (code === null) {\n      return nok(code);\n    }\n    effects.exit('tableRow');\n    effects.exit('tableHead');\n    var originalInterrupt = self.interrupt;\n    self.interrupt = true;\n    return effects.attempt({\n      tokenize: tokenizeRowEnd,\n      partial: true\n    }, function (code) {\n      self.interrupt = originalInterrupt;\n      effects.enter('tableDelimiterRow');\n      return atDelimiterRowBreak(code);\n    }, function (code) {\n      self.interrupt = originalInterrupt;\n      return nok(code);\n    })(code);\n  }\n  /** @type {State} */\n\n  function atDelimiterRowBreak(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return rowEndDelimiter(code);\n    }\n    if (markdownSpace(code)) {\n      effects.enter('whitespace');\n      effects.consume(code);\n      return inWhitespaceDelimiter;\n    }\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller');\n      effects.consume(code);\n      hasDash = true;\n      align.push('none');\n      return inFillerDelimiter;\n    }\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment');\n      effects.consume(code);\n      effects.exit('tableDelimiterAlignment');\n      align.push('left');\n      return afterLeftAlignment;\n    } // If we start with a pipe, we open a cell marker.\n\n    if (code === 124) {\n      effects.enter('tableCellDivider');\n      effects.consume(code);\n      effects.exit('tableCellDivider');\n      return atDelimiterRowBreak;\n    }\n    return nok(code);\n  }\n  /** @type {State} */\n\n  function inWhitespaceDelimiter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return inWhitespaceDelimiter;\n    }\n    effects.exit('whitespace');\n    return atDelimiterRowBreak(code);\n  }\n  /** @type {State} */\n\n  function inFillerDelimiter(code) {\n    if (code === 45) {\n      effects.consume(code);\n      return inFillerDelimiter;\n    }\n    effects.exit('tableDelimiterFiller');\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment');\n      effects.consume(code);\n      effects.exit('tableDelimiterAlignment');\n      align[align.length - 1] = align[align.length - 1] === 'left' ? 'center' : 'right';\n      return afterRightAlignment;\n    }\n    return atDelimiterRowBreak(code);\n  }\n  /** @type {State} */\n\n  function afterLeftAlignment(code) {\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller');\n      effects.consume(code);\n      hasDash = true;\n      return inFillerDelimiter;\n    } // Anything else is not ok.\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n  function afterRightAlignment(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return rowEndDelimiter(code);\n    }\n    if (markdownSpace(code)) {\n      effects.enter('whitespace');\n      effects.consume(code);\n      return inWhitespaceDelimiter;\n    } // `|`\n\n    if (code === 124) {\n      effects.enter('tableCellDivider');\n      effects.consume(code);\n      effects.exit('tableCellDivider');\n      return atDelimiterRowBreak;\n    }\n    return nok(code);\n  }\n  /** @type {State} */\n\n  function rowEndDelimiter(code) {\n    effects.exit('tableDelimiterRow'); // Exit if there was no dash at all, or if the header cell count is not the\n    // delimiter cell count.\n\n    if (!hasDash || tableHeaderCount !== align.length) {\n      return nok(code);\n    }\n    if (code === null) {\n      return tableClose(code);\n    }\n    return effects.check(nextPrefixedOrBlank, tableClose, effects.attempt({\n      tokenize: tokenizeRowEnd,\n      partial: true\n    }, factorySpace(effects, bodyStart, 'linePrefix', 4), tableClose))(code);\n  }\n  /** @type {State} */\n\n  function tableClose(code) {\n    effects.exit('table');\n    return ok(code);\n  }\n  /** @type {State} */\n\n  function bodyStart(code) {\n    effects.enter('tableBody');\n    return rowStartBody(code);\n  }\n  /** @type {State} */\n\n  function rowStartBody(code) {\n    effects.enter('tableRow'); // If we start with a pipe, we open a cell marker.\n\n    if (code === 124) {\n      return cellDividerBody(code);\n    }\n    effects.enter('temporaryTableCellContent'); // Can’t be space or eols at the start of a construct, so we’re in a cell.\n\n    return inCellContentBody(code);\n  }\n  /** @type {State} */\n\n  function cellDividerBody(code) {\n    effects.enter('tableCellDivider');\n    effects.consume(code);\n    effects.exit('tableCellDivider');\n    return cellBreakBody;\n  }\n  /** @type {State} */\n\n  function cellBreakBody(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return atRowEndBody(code);\n    }\n    if (markdownSpace(code)) {\n      effects.enter('whitespace');\n      effects.consume(code);\n      return inWhitespaceBody;\n    } // `|`\n\n    if (code === 124) {\n      return cellDividerBody(code);\n    } // Anything else is cell content.\n\n    effects.enter('temporaryTableCellContent');\n    return inCellContentBody(code);\n  }\n  /** @type {State} */\n\n  function inWhitespaceBody(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return inWhitespaceBody;\n    }\n    effects.exit('whitespace');\n    return cellBreakBody(code);\n  }\n  /** @type {State} */\n\n  function inCellContentBody(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {\n      effects.exit('temporaryTableCellContent');\n      return cellBreakBody(code);\n    }\n    effects.consume(code);\n    return code === 92 ? inCellContentEscapeBody : inCellContentBody;\n  }\n  /** @type {State} */\n\n  function inCellContentEscapeBody(code) {\n    if (code === 92 || code === 124) {\n      effects.consume(code);\n      return inCellContentBody;\n    } // Anything else.\n\n    return inCellContentBody(code);\n  }\n  /** @type {State} */\n\n  function atRowEndBody(code) {\n    effects.exit('tableRow');\n    if (code === null) {\n      return tableBodyClose(code);\n    }\n    return effects.check(nextPrefixedOrBlank, tableBodyClose, effects.attempt({\n      tokenize: tokenizeRowEnd,\n      partial: true\n    }, factorySpace(effects, rowStartBody, 'linePrefix', 4), tableBodyClose))(code);\n  }\n  /** @type {State} */\n\n  function tableBodyClose(code) {\n    effects.exit('tableBody');\n    return tableClose(code);\n  }\n  /** @type {Tokenizer} */\n\n  function tokenizeRowEnd(effects, ok, nok) {\n    return start;\n    /** @type {State} */\n\n    function start(code) {\n      effects.enter('lineEnding');\n      effects.consume(code);\n      effects.exit('lineEnding');\n      return factorySpace(effects, prefixed, 'linePrefix');\n    }\n    /** @type {State} */\n\n    function prefixed(code) {\n      // Blank or interrupting line.\n      if (self.parser.lazy[self.now().line] || code === null || markdownLineEnding(code)) {\n        return nok(code);\n      }\n      var tail = self.events[self.events.length - 1]; // Indented code can interrupt delimiter and body rows.\n\n      if (!self.parser.constructs.disable.null.includes('codeIndented') && tail && tail[1].type === 'linePrefix' && tail[2].sliceSerialize(tail[1], true).length >= 4) {\n        return nok(code);\n      }\n      self._gfmTableDynamicInterruptHack = true;\n      return effects.check(self.parser.constructs.flow, function (code) {\n        self._gfmTableDynamicInterruptHack = false;\n        return nok(code);\n      }, function (code) {\n        self._gfmTableDynamicInterruptHack = false;\n        return ok(code);\n      })(code);\n    }\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeNextPrefixedOrBlank(effects, ok, nok) {\n  var size = 0;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    // This is a check, so we don’t care about tokens, but we open a bogus one\n    // so we’re valid.\n    effects.enter('check'); // EOL.\n\n    effects.consume(code);\n    return whitespace;\n  }\n  /** @type {State} */\n\n  function whitespace(code) {\n    if (code === -1 || code === 32) {\n      effects.consume(code);\n      size++;\n      return size === 4 ? ok : whitespace;\n    } // EOF or whitespace\n\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      return ok(code);\n    } // Anything else.\n\n    return nok(code);\n  }\n}","map":{"version":3,"names":["factorySpace","markdownLineEnding","markdownLineEndingOrSpace","markdownSpace","gfmTable","flow","null","tokenize","tokenizeTable","resolve","resolveTable","nextPrefixedOrBlank","tokenizeNextPrefixedOrBlank","partial","events","context","index","inHead","inDelimiterRow","inRow","contentStart","contentEnd","cellStart","seenCellInRow","length","token","type","content","start","end","text","contentType","splice","undefined","cell","effects","ok","nok","self","align","tableHeaderCount","seenDelimiter","hasDash","code","enter","_align","cellDividerHead","inCellContentHead","consume","exit","cellBreakHead","atRowEndHead","inWhitespaceHead","inCellContentEscapeHead","originalInterrupt","interrupt","attempt","tokenizeRowEnd","atDelimiterRowBreak","rowEndDelimiter","inWhitespaceDelimiter","push","inFillerDelimiter","afterLeftAlignment","afterRightAlignment","tableClose","check","bodyStart","rowStartBody","cellDividerBody","inCellContentBody","cellBreakBody","atRowEndBody","inWhitespaceBody","inCellContentEscapeBody","tableBodyClose","prefixed","parser","lazy","now","line","tail","constructs","disable","includes","sliceSerialize","_gfmTableDynamicInterruptHack","size","whitespace"],"sources":["/home/kty/workspace/seb41_pre_001/client/node_modules/micromark-extension-gfm-table/lib/syntax.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n */\n\n/**\n * @typedef {'left'|'center'|'right'|'none'} Align\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\n\n/** @type {Extension} */\nexport const gfmTable = {\n  flow: {\n    null: {\n      tokenize: tokenizeTable,\n      resolve: resolveTable\n    }\n  }\n}\nconst nextPrefixedOrBlank = {\n  tokenize: tokenizeNextPrefixedOrBlank,\n  partial: true\n}\n/** @type {Resolver} */\n\nfunction resolveTable(events, context) {\n  let index = -1\n  /** @type {boolean|undefined} */\n\n  let inHead\n  /** @type {boolean|undefined} */\n\n  let inDelimiterRow\n  /** @type {boolean|undefined} */\n\n  let inRow\n  /** @type {number|undefined} */\n\n  let contentStart\n  /** @type {number|undefined} */\n\n  let contentEnd\n  /** @type {number|undefined} */\n\n  let cellStart\n  /** @type {boolean|undefined} */\n\n  let seenCellInRow\n\n  while (++index < events.length) {\n    const token = events[index][1]\n\n    if (inRow) {\n      if (token.type === 'temporaryTableCellContent') {\n        contentStart = contentStart || index\n        contentEnd = index\n      }\n\n      if (\n        // Combine separate content parts into one.\n        (token.type === 'tableCellDivider' || token.type === 'tableRow') &&\n        contentEnd\n      ) {\n        const content = {\n          type: 'tableContent',\n          start: events[contentStart][1].start,\n          end: events[contentEnd][1].end\n        }\n        /** @type {Token} */\n\n        const text = {\n          type: 'chunkText',\n          start: content.start,\n          end: content.end,\n          // @ts-expect-error It’s fine.\n          contentType: 'text'\n        }\n        events.splice(\n          contentStart,\n          contentEnd - contentStart + 1,\n          ['enter', content, context],\n          ['enter', text, context],\n          ['exit', text, context],\n          ['exit', content, context]\n        )\n        index -= contentEnd - contentStart - 3\n        contentStart = undefined\n        contentEnd = undefined\n      }\n    }\n\n    if (\n      events[index][0] === 'exit' &&\n      cellStart !== undefined &&\n      cellStart + (seenCellInRow ? 0 : 1) < index &&\n      (token.type === 'tableCellDivider' ||\n        (token.type === 'tableRow' &&\n          (cellStart + 3 < index ||\n            events[cellStart][1].type !== 'whitespace')))\n    ) {\n      const cell = {\n        type: inDelimiterRow\n          ? 'tableDelimiter'\n          : inHead\n          ? 'tableHeader'\n          : 'tableData',\n        start: events[cellStart][1].start,\n        end: events[index][1].end\n      }\n      events.splice(index + (token.type === 'tableCellDivider' ? 1 : 0), 0, [\n        'exit',\n        cell,\n        context\n      ])\n      events.splice(cellStart, 0, ['enter', cell, context])\n      index += 2\n      cellStart = index + 1\n      seenCellInRow = true\n    }\n\n    if (token.type === 'tableRow') {\n      inRow = events[index][0] === 'enter'\n\n      if (inRow) {\n        cellStart = index + 1\n        seenCellInRow = false\n      }\n    }\n\n    if (token.type === 'tableDelimiterRow') {\n      inDelimiterRow = events[index][0] === 'enter'\n\n      if (inDelimiterRow) {\n        cellStart = index + 1\n        seenCellInRow = false\n      }\n    }\n\n    if (token.type === 'tableHead') {\n      inHead = events[index][0] === 'enter'\n    }\n  }\n\n  return events\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeTable(effects, ok, nok) {\n  const self = this\n  /** @type {Array<Align>} */\n\n  const align = []\n  let tableHeaderCount = 0\n  /** @type {boolean|undefined} */\n\n  let seenDelimiter\n  /** @type {boolean|undefined} */\n\n  let hasDash\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    // @ts-expect-error Custom.\n    effects.enter('table')._align = align\n    effects.enter('tableHead')\n    effects.enter('tableRow') // If we start with a pipe, we open a cell marker.\n\n    if (code === 124) {\n      return cellDividerHead(code)\n    }\n\n    tableHeaderCount++\n    effects.enter('temporaryTableCellContent') // Can’t be space or eols at the start of a construct, so we’re in a cell.\n\n    return inCellContentHead(code)\n  }\n  /** @type {State} */\n\n  function cellDividerHead(code) {\n    effects.enter('tableCellDivider')\n    effects.consume(code)\n    effects.exit('tableCellDivider')\n    seenDelimiter = true\n    return cellBreakHead\n  }\n  /** @type {State} */\n\n  function cellBreakHead(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return atRowEndHead(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceHead\n    }\n\n    if (seenDelimiter) {\n      seenDelimiter = undefined\n      tableHeaderCount++\n    }\n\n    if (code === 124) {\n      return cellDividerHead(code)\n    } // Anything else is cell content.\n\n    effects.enter('temporaryTableCellContent')\n    return inCellContentHead(code)\n  }\n  /** @type {State} */\n\n  function inWhitespaceHead(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return inWhitespaceHead\n    }\n\n    effects.exit('whitespace')\n    return cellBreakHead(code)\n  }\n  /** @type {State} */\n\n  function inCellContentHead(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {\n      effects.exit('temporaryTableCellContent')\n      return cellBreakHead(code)\n    }\n\n    effects.consume(code)\n    return code === 92 ? inCellContentEscapeHead : inCellContentHead\n  }\n  /** @type {State} */\n\n  function inCellContentEscapeHead(code) {\n    if (code === 92 || code === 124) {\n      effects.consume(code)\n      return inCellContentHead\n    } // Anything else.\n\n    return inCellContentHead(code)\n  }\n  /** @type {State} */\n\n  function atRowEndHead(code) {\n    if (code === null) {\n      return nok(code)\n    }\n\n    effects.exit('tableRow')\n    effects.exit('tableHead')\n    const originalInterrupt = self.interrupt\n    self.interrupt = true\n    return effects.attempt(\n      {\n        tokenize: tokenizeRowEnd,\n        partial: true\n      },\n      function (code) {\n        self.interrupt = originalInterrupt\n        effects.enter('tableDelimiterRow')\n        return atDelimiterRowBreak(code)\n      },\n      function (code) {\n        self.interrupt = originalInterrupt\n        return nok(code)\n      }\n    )(code)\n  }\n  /** @type {State} */\n\n  function atDelimiterRowBreak(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return rowEndDelimiter(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller')\n      effects.consume(code)\n      hasDash = true\n      align.push('none')\n      return inFillerDelimiter\n    }\n\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment')\n      effects.consume(code)\n      effects.exit('tableDelimiterAlignment')\n      align.push('left')\n      return afterLeftAlignment\n    } // If we start with a pipe, we open a cell marker.\n\n    if (code === 124) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return atDelimiterRowBreak\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function inWhitespaceDelimiter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    effects.exit('whitespace')\n    return atDelimiterRowBreak(code)\n  }\n  /** @type {State} */\n\n  function inFillerDelimiter(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return inFillerDelimiter\n    }\n\n    effects.exit('tableDelimiterFiller')\n\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment')\n      effects.consume(code)\n      effects.exit('tableDelimiterAlignment')\n      align[align.length - 1] =\n        align[align.length - 1] === 'left' ? 'center' : 'right'\n      return afterRightAlignment\n    }\n\n    return atDelimiterRowBreak(code)\n  }\n  /** @type {State} */\n\n  function afterLeftAlignment(code) {\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller')\n      effects.consume(code)\n      hasDash = true\n      return inFillerDelimiter\n    } // Anything else is not ok.\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function afterRightAlignment(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return rowEndDelimiter(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    } // `|`\n\n    if (code === 124) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return atDelimiterRowBreak\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function rowEndDelimiter(code) {\n    effects.exit('tableDelimiterRow') // Exit if there was no dash at all, or if the header cell count is not the\n    // delimiter cell count.\n\n    if (!hasDash || tableHeaderCount !== align.length) {\n      return nok(code)\n    }\n\n    if (code === null) {\n      return tableClose(code)\n    }\n\n    return effects.check(\n      nextPrefixedOrBlank,\n      tableClose,\n      effects.attempt(\n        {\n          tokenize: tokenizeRowEnd,\n          partial: true\n        },\n        factorySpace(effects, bodyStart, 'linePrefix', 4),\n        tableClose\n      )\n    )(code)\n  }\n  /** @type {State} */\n\n  function tableClose(code) {\n    effects.exit('table')\n    return ok(code)\n  }\n  /** @type {State} */\n\n  function bodyStart(code) {\n    effects.enter('tableBody')\n    return rowStartBody(code)\n  }\n  /** @type {State} */\n\n  function rowStartBody(code) {\n    effects.enter('tableRow') // If we start with a pipe, we open a cell marker.\n\n    if (code === 124) {\n      return cellDividerBody(code)\n    }\n\n    effects.enter('temporaryTableCellContent') // Can’t be space or eols at the start of a construct, so we’re in a cell.\n\n    return inCellContentBody(code)\n  }\n  /** @type {State} */\n\n  function cellDividerBody(code) {\n    effects.enter('tableCellDivider')\n    effects.consume(code)\n    effects.exit('tableCellDivider')\n    return cellBreakBody\n  }\n  /** @type {State} */\n\n  function cellBreakBody(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return atRowEndBody(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceBody\n    } // `|`\n\n    if (code === 124) {\n      return cellDividerBody(code)\n    } // Anything else is cell content.\n\n    effects.enter('temporaryTableCellContent')\n    return inCellContentBody(code)\n  }\n  /** @type {State} */\n\n  function inWhitespaceBody(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return inWhitespaceBody\n    }\n\n    effects.exit('whitespace')\n    return cellBreakBody(code)\n  }\n  /** @type {State} */\n\n  function inCellContentBody(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {\n      effects.exit('temporaryTableCellContent')\n      return cellBreakBody(code)\n    }\n\n    effects.consume(code)\n    return code === 92 ? inCellContentEscapeBody : inCellContentBody\n  }\n  /** @type {State} */\n\n  function inCellContentEscapeBody(code) {\n    if (code === 92 || code === 124) {\n      effects.consume(code)\n      return inCellContentBody\n    } // Anything else.\n\n    return inCellContentBody(code)\n  }\n  /** @type {State} */\n\n  function atRowEndBody(code) {\n    effects.exit('tableRow')\n\n    if (code === null) {\n      return tableBodyClose(code)\n    }\n\n    return effects.check(\n      nextPrefixedOrBlank,\n      tableBodyClose,\n      effects.attempt(\n        {\n          tokenize: tokenizeRowEnd,\n          partial: true\n        },\n        factorySpace(effects, rowStartBody, 'linePrefix', 4),\n        tableBodyClose\n      )\n    )(code)\n  }\n  /** @type {State} */\n\n  function tableBodyClose(code) {\n    effects.exit('tableBody')\n    return tableClose(code)\n  }\n  /** @type {Tokenizer} */\n\n  function tokenizeRowEnd(effects, ok, nok) {\n    return start\n    /** @type {State} */\n\n    function start(code) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return factorySpace(effects, prefixed, 'linePrefix')\n    }\n    /** @type {State} */\n\n    function prefixed(code) {\n      // Blank or interrupting line.\n      if (\n        self.parser.lazy[self.now().line] ||\n        code === null ||\n        markdownLineEnding(code)\n      ) {\n        return nok(code)\n      }\n\n      const tail = self.events[self.events.length - 1] // Indented code can interrupt delimiter and body rows.\n\n      if (\n        !self.parser.constructs.disable.null.includes('codeIndented') &&\n        tail &&\n        tail[1].type === 'linePrefix' &&\n        tail[2].sliceSerialize(tail[1], true).length >= 4\n      ) {\n        return nok(code)\n      }\n\n      self._gfmTableDynamicInterruptHack = true\n      return effects.check(\n        self.parser.constructs.flow,\n        function (code) {\n          self._gfmTableDynamicInterruptHack = false\n          return nok(code)\n        },\n        function (code) {\n          self._gfmTableDynamicInterruptHack = false\n          return ok(code)\n        }\n      )(code)\n    }\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeNextPrefixedOrBlank(effects, ok, nok) {\n  let size = 0\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    // This is a check, so we don’t care about tokens, but we open a bogus one\n    // so we’re valid.\n    effects.enter('check') // EOL.\n\n    effects.consume(code)\n    return whitespace\n  }\n  /** @type {State} */\n\n  function whitespace(code) {\n    if (code === -1 || code === 32) {\n      effects.consume(code)\n      size++\n      return size === 4 ? ok : whitespace\n    } // EOF or whitespace\n\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      return ok(code)\n    } // Anything else.\n\n    return nok(code)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
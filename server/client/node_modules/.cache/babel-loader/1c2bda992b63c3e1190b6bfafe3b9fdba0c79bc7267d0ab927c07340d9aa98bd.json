{"ast":null,"code":"import _classCallCheck from \"/home/kty/workspace/seb41_pre_001/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/kty/workspace/seb41_pre_001/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('./types.js').Selectors} Selectors\n * @typedef {import('./types.js').Rule} Rule\n * @typedef {import('./types.js').RuleSet} RuleSet\n * @typedef {import('./types.js').HastNode} HastNode\n * @typedef {import('./types.js').SelectIterator} SelectIterator\n * @typedef {import('./types.js').SelectState} SelectState\n */\n\nimport { html, svg } from 'property-information';\nimport { zwitch } from 'zwitch';\nimport { enterState } from './enter-state.js';\nimport { nest } from './nest.js';\nimport { pseudo } from './pseudo.js';\nimport { test } from './test.js';\nvar type = zwitch('type', {\n  // @ts-expect-error: hush.\n  unknown: unknownType,\n  invalid: invalidType,\n  // @ts-expect-error: hush.\n  handlers: {\n    selectors: selectors,\n    ruleSet: ruleSet,\n    rule: rule\n  }\n});\n\n/**\n * @param {Selectors|RuleSet|Rule} query\n * @param {HastNode|undefined} node\n * @param {SelectState} state\n * @returns {Array<Element>}\n */\nexport function any(query, node, state) {\n  // @ts-expect-error zwitch types are off.\n  return query && node ? type(query, node, state) : [];\n}\n\n/**\n * @param {Selectors} query\n * @param {HastNode} node\n * @param {SelectState} state\n * @returns {Array<Element>}\n */\nfunction selectors(query, node, state) {\n  var collector = new Collector(state.one);\n  var index = -1;\n  while (++index < query.selectors.length) {\n    collector.collectAll(ruleSet(query.selectors[index], node, state));\n  }\n  return collector.result;\n}\n\n/**\n * @param {RuleSet} query\n * @param {HastNode} node\n * @param {SelectState} state\n * @returns {Array<Element>}\n */\nfunction ruleSet(query, node, state) {\n  return rule(query.rule, node, state);\n}\n\n/**\n * @param {Rule} query\n * @param {HastNode} tree\n * @param {SelectState} state\n * @returns {Array<Element>}\n */\nfunction rule(query, tree, state) {\n  var collector = new Collector(state.one);\n  if (state.shallow && query.rule) {\n    throw new Error('Expected selector without nesting');\n  }\n  nest(query, tree, 0, null, configure(query, {\n    schema: state.space === 'svg' ? svg : html,\n    language: undefined,\n    direction: 'ltr',\n    editableOrEditingHost: false,\n    // @ts-expect-error assume elements.\n    scopeElements: tree.type === 'root' ? tree.children : [tree],\n    iterator: iterator,\n    one: state.one,\n    shallow: state.shallow\n  }));\n  return collector.result;\n\n  /** @type {SelectIterator} */\n  function iterator(query, node, index, parent, state) {\n    var exit = enterState(state, node);\n    if (test(query, node, index, parent, state)) {\n      if (query.rule) {\n        nest(query.rule, node, index, parent, configure(query.rule, state));\n      } else {\n        // @ts-expect-error `test` also asserts `node is Element`\n        collector.collect(node);\n        state.found = true;\n      }\n    }\n    exit();\n  }\n\n  /**\n   * @template {SelectState} S\n   * @param {Rule} query\n   * @param {S} state\n   * @returns {S}\n   */\n  function configure(query, state) {\n    var pseudos = query.pseudos || [];\n    var index = -1;\n    while (++index < pseudos.length) {\n      if (pseudo.needsIndex.includes(pseudos[index].name)) {\n        state.index = true;\n        break;\n      }\n    }\n    return state;\n  }\n}\n\n// Shouldn’t be called, all data is handled.\n/* c8 ignore next 6 */\n/**\n * @param {{[x: string]: unknown, type: string}} query\n */\nfunction unknownType(query) {\n  throw new Error('Unknown type `' + query.type + '`');\n}\n\n// Shouldn’t be called, parser gives correct data.\n/* c8 ignore next 3 */\nfunction invalidType() {\n  throw new Error('Invalid type');\n}\nvar Collector = /*#__PURE__*/function () {\n  /**\n   * @param {boolean|undefined} [one]\n   */\n  function Collector(one) {\n    _classCallCheck(this, Collector);\n    /** @type {Array<Element>} */\n    this.result = [];\n    /** @type {boolean|undefined} */\n    this.one = one;\n    /** @type {boolean} */\n    this.found = false;\n  }\n\n  /**\n   * Append nodes to array, filtering out duplicates.\n   *\n   * @param {Array<Element>} elements\n   */\n  _createClass(Collector, [{\n    key: \"collectAll\",\n    value: function collectAll(elements) {\n      var index = -1;\n      while (++index < elements.length) {\n        this.collect(elements[index]);\n      }\n    }\n\n    /**\n     * Append one node.\n     *\n     * @param {Element} element\n     */\n  }, {\n    key: \"collect\",\n    value: function collect(element) {\n      if (this.one) {\n        // Shouldn’t happen, safeguards performance problems.\n        /* c8 ignore next */\n        if (this.found) return;\n        this.found = true;\n      }\n      if (!this.result.includes(element)) this.result.push(element);\n    }\n  }]);\n  return Collector;\n}();","map":{"version":3,"names":["html","svg","zwitch","enterState","nest","pseudo","test","type","unknown","unknownType","invalid","invalidType","handlers","selectors","ruleSet","rule","any","query","node","state","collector","Collector","one","index","length","collectAll","result","tree","shallow","Error","configure","schema","space","language","undefined","direction","editableOrEditingHost","scopeElements","children","iterator","parent","exit","collect","found","pseudos","needsIndex","includes","name","elements","element","push"],"sources":["/home/kty/workspace/seb41_pre_001/client/node_modules/hast-util-select/lib/any.js"],"sourcesContent":["/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('./types.js').Selectors} Selectors\n * @typedef {import('./types.js').Rule} Rule\n * @typedef {import('./types.js').RuleSet} RuleSet\n * @typedef {import('./types.js').HastNode} HastNode\n * @typedef {import('./types.js').SelectIterator} SelectIterator\n * @typedef {import('./types.js').SelectState} SelectState\n */\n\nimport {html, svg} from 'property-information'\nimport {zwitch} from 'zwitch'\nimport {enterState} from './enter-state.js'\nimport {nest} from './nest.js'\nimport {pseudo} from './pseudo.js'\nimport {test} from './test.js'\n\nconst type = zwitch('type', {\n  // @ts-expect-error: hush.\n  unknown: unknownType,\n  invalid: invalidType,\n  // @ts-expect-error: hush.\n  handlers: {selectors, ruleSet, rule}\n})\n\n/**\n * @param {Selectors|RuleSet|Rule} query\n * @param {HastNode|undefined} node\n * @param {SelectState} state\n * @returns {Array<Element>}\n */\nexport function any(query, node, state) {\n  // @ts-expect-error zwitch types are off.\n  return query && node ? type(query, node, state) : []\n}\n\n/**\n * @param {Selectors} query\n * @param {HastNode} node\n * @param {SelectState} state\n * @returns {Array<Element>}\n */\nfunction selectors(query, node, state) {\n  const collector = new Collector(state.one)\n  let index = -1\n\n  while (++index < query.selectors.length) {\n    collector.collectAll(ruleSet(query.selectors[index], node, state))\n  }\n\n  return collector.result\n}\n\n/**\n * @param {RuleSet} query\n * @param {HastNode} node\n * @param {SelectState} state\n * @returns {Array<Element>}\n */\nfunction ruleSet(query, node, state) {\n  return rule(query.rule, node, state)\n}\n\n/**\n * @param {Rule} query\n * @param {HastNode} tree\n * @param {SelectState} state\n * @returns {Array<Element>}\n */\nfunction rule(query, tree, state) {\n  const collector = new Collector(state.one)\n\n  if (state.shallow && query.rule) {\n    throw new Error('Expected selector without nesting')\n  }\n\n  nest(\n    query,\n    tree,\n    0,\n    null,\n    configure(query, {\n      schema: state.space === 'svg' ? svg : html,\n      language: undefined,\n      direction: 'ltr',\n      editableOrEditingHost: false,\n      // @ts-expect-error assume elements.\n      scopeElements: tree.type === 'root' ? tree.children : [tree],\n      iterator,\n      one: state.one,\n      shallow: state.shallow\n    })\n  )\n\n  return collector.result\n\n  /** @type {SelectIterator} */\n  function iterator(query, node, index, parent, state) {\n    const exit = enterState(state, node)\n\n    if (test(query, node, index, parent, state)) {\n      if (query.rule) {\n        nest(query.rule, node, index, parent, configure(query.rule, state))\n      } else {\n        // @ts-expect-error `test` also asserts `node is Element`\n        collector.collect(node)\n        state.found = true\n      }\n    }\n\n    exit()\n  }\n\n  /**\n   * @template {SelectState} S\n   * @param {Rule} query\n   * @param {S} state\n   * @returns {S}\n   */\n  function configure(query, state) {\n    const pseudos = query.pseudos || []\n    let index = -1\n\n    while (++index < pseudos.length) {\n      if (pseudo.needsIndex.includes(pseudos[index].name)) {\n        state.index = true\n        break\n      }\n    }\n\n    return state\n  }\n}\n\n// Shouldn’t be called, all data is handled.\n/* c8 ignore next 6 */\n/**\n * @param {{[x: string]: unknown, type: string}} query\n */\nfunction unknownType(query) {\n  throw new Error('Unknown type `' + query.type + '`')\n}\n\n// Shouldn’t be called, parser gives correct data.\n/* c8 ignore next 3 */\nfunction invalidType() {\n  throw new Error('Invalid type')\n}\n\nclass Collector {\n  /**\n   * @param {boolean|undefined} [one]\n   */\n  constructor(one) {\n    /** @type {Array<Element>} */\n    this.result = []\n    /** @type {boolean|undefined} */\n    this.one = one\n    /** @type {boolean} */\n    this.found = false\n  }\n\n  /**\n   * Append nodes to array, filtering out duplicates.\n   *\n   * @param {Array<Element>} elements\n   */\n  collectAll(elements) {\n    let index = -1\n\n    while (++index < elements.length) {\n      this.collect(elements[index])\n    }\n  }\n\n  /**\n   * Append one node.\n   *\n   * @param {Element} element\n   */\n  collect(element) {\n    if (this.one) {\n      // Shouldn’t happen, safeguards performance problems.\n      /* c8 ignore next */\n      if (this.found) return\n      this.found = true\n    }\n\n    if (!this.result.includes(element)) this.result.push(element)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import _defineProperty from \"/home/kty/workspace/seb41_pre_001/client/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Event} Event\n */\nimport { blankLine } from 'micromark-core-commonmark';\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding, markdownLineEndingOrSpace } from 'micromark-util-character';\nimport { normalizeIdentifier } from 'micromark-util-normalize-identifier';\nvar indent = {\n  tokenize: tokenizeIndent,\n  partial: true\n};\n/**\n * @returns {Extension}\n */\n\nexport function gfmFootnote() {\n  var _text;\n  /** @type {Extension} */\n  return {\n    document: _defineProperty({}, 91, {\n      tokenize: tokenizeDefinitionStart,\n      continuation: {\n        tokenize: tokenizeDefinitionContinuation\n      },\n      exit: gfmFootnoteDefinitionEnd\n    }),\n    text: (_text = {}, _defineProperty(_text, 91, {\n      tokenize: tokenizeGfmFootnoteCall\n    }), _defineProperty(_text, 93, {\n      add: 'after',\n      tokenize: tokenizePotentialGfmFootnoteCall,\n      resolveTo: resolveToPotentialGfmFootnoteCall\n    }), _text)\n  };\n}\n/** @type {Tokenizer} */\n\nfunction tokenizePotentialGfmFootnoteCall(effects, ok, nok) {\n  var self = this;\n  var index = self.events.length;\n  /** @type {Array<string>} */\n  // @ts-expect-error It’s fine!\n\n  var defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);\n  /** @type {Token} */\n\n  var labelStart; // Find an opening.\n\n  while (index--) {\n    var token = self.events[index][1];\n    if (token.type === 'labelImage') {\n      labelStart = token;\n      break;\n    } // Exit if we’ve walked far enough.\n\n    if (token.type === 'gfmFootnoteCall' || token.type === 'labelLink' || token.type === 'label' || token.type === 'image' || token.type === 'link') {\n      break;\n    }\n  }\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if (!labelStart || !labelStart._balanced) {\n      return nok(code);\n    }\n    var id = normalizeIdentifier(self.sliceSerialize({\n      start: labelStart.end,\n      end: self.now()\n    }));\n    if (id.charCodeAt(0) !== 94 || !defined.includes(id.slice(1))) {\n      return nok(code);\n    }\n    effects.enter('gfmFootnoteCallLabelMarker');\n    effects.consume(code);\n    effects.exit('gfmFootnoteCallLabelMarker');\n    return ok(code);\n  }\n}\n/** @type {Resolver} */\n\nfunction resolveToPotentialGfmFootnoteCall(events, context) {\n  var index = events.length;\n  /** @type {Token|undefined} */\n\n  var labelStart; // Find an opening.\n\n  while (index--) {\n    if (events[index][1].type === 'labelImage' && events[index][0] === 'enter') {\n      labelStart = events[index][1];\n      break;\n    }\n  }\n\n  // Change the `labelImageMarker` to a `data`.\n  events[index + 1][1].type = 'data';\n  events[index + 3][1].type = 'gfmFootnoteCallLabelMarker'; // The whole (without `!`):\n\n  var call = {\n    type: 'gfmFootnoteCall',\n    start: Object.assign({}, events[index + 3][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }; // The `^` marker\n\n  var marker = {\n    type: 'gfmFootnoteCallMarker',\n    start: Object.assign({}, events[index + 3][1].end),\n    end: Object.assign({}, events[index + 3][1].end)\n  }; // Increment the end 1 character.\n\n  marker.end.column++;\n  marker.end.offset++;\n  marker.end._bufferIndex++;\n  var string = {\n    type: 'gfmFootnoteCallString',\n    start: Object.assign({}, marker.end),\n    end: Object.assign({}, events[events.length - 1][1].start)\n  };\n  var chunk = {\n    type: 'chunkString',\n    contentType: 'string',\n    start: Object.assign({}, string.start),\n    end: Object.assign({}, string.end)\n  };\n  /** @type {Array<Event>} */\n\n  var replacement = [\n  // Take the `labelImageMarker` (now `data`, the `!`)\n  events[index + 1], events[index + 2], ['enter', call, context],\n  // The `[`\n  events[index + 3], events[index + 4],\n  // The `^`.\n  ['enter', marker, context], ['exit', marker, context],\n  // Everything in between.\n  ['enter', string, context], ['enter', chunk, context], ['exit', chunk, context], ['exit', string, context],\n  // The ending (`]`, properly parsed and labelled).\n  events[events.length - 2], events[events.length - 1], ['exit', call, context]];\n  events.splice.apply(events, [index, events.length - index + 1].concat(replacement));\n  return events;\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeGfmFootnoteCall(effects, ok, nok) {\n  var self = this;\n  /** @type {Array<string>} */\n  // @ts-expect-error It’s fine!\n\n  var defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);\n  var size = 0;\n  /** @type {boolean} */\n\n  var data;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('gfmFootnoteCall');\n    effects.enter('gfmFootnoteCallLabelMarker');\n    effects.consume(code);\n    effects.exit('gfmFootnoteCallLabelMarker');\n    return callStart;\n  }\n  /** @type {State} */\n\n  function callStart(code) {\n    if (code !== 94) return nok(code);\n    effects.enter('gfmFootnoteCallMarker');\n    effects.consume(code);\n    effects.exit('gfmFootnoteCallMarker');\n    effects.enter('gfmFootnoteCallString');\n    effects.enter('chunkString').contentType = 'string';\n    return callData;\n  }\n  /** @type {State} */\n\n  function callData(code) {\n    /** @type {Token} */\n    var token;\n    if (code === null || code === 91 || size++ > 999) {\n      return nok(code);\n    }\n    if (code === 93) {\n      if (!data) {\n        return nok(code);\n      }\n      effects.exit('chunkString');\n      token = effects.exit('gfmFootnoteCallString');\n      return defined.includes(normalizeIdentifier(self.sliceSerialize(token))) ? end(code) : nok(code);\n    }\n    effects.consume(code);\n    if (!markdownLineEndingOrSpace(code)) {\n      data = true;\n    }\n    return code === 92 ? callEscape : callData;\n  }\n  /** @type {State} */\n\n  function callEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code);\n      size++;\n      return callData;\n    }\n    return callData(code);\n  }\n  /** @type {State} */\n\n  function end(code) {\n    effects.enter('gfmFootnoteCallLabelMarker');\n    effects.consume(code);\n    effects.exit('gfmFootnoteCallLabelMarker');\n    effects.exit('gfmFootnoteCall');\n    return ok;\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeDefinitionStart(effects, ok, nok) {\n  var self = this;\n  /** @type {Array<string>} */\n  // @ts-expect-error It’s fine!\n\n  var defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);\n  /** @type {string} */\n\n  var identifier;\n  var size = 0;\n  /** @type {boolean|undefined} */\n\n  var data;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('gfmFootnoteDefinition')._container = true;\n    effects.enter('gfmFootnoteDefinitionLabel');\n    effects.enter('gfmFootnoteDefinitionLabelMarker');\n    effects.consume(code);\n    effects.exit('gfmFootnoteDefinitionLabelMarker');\n    return labelStart;\n  }\n  /** @type {State} */\n\n  function labelStart(code) {\n    if (code === 94) {\n      effects.enter('gfmFootnoteDefinitionMarker');\n      effects.consume(code);\n      effects.exit('gfmFootnoteDefinitionMarker');\n      effects.enter('gfmFootnoteDefinitionLabelString');\n      return atBreak;\n    }\n    return nok(code);\n  }\n  /** @type {State} */\n\n  function atBreak(code) {\n    /** @type {Token} */\n    var token;\n    if (code === null || code === 91 || size > 999) {\n      return nok(code);\n    }\n    if (code === 93) {\n      if (!data) {\n        return nok(code);\n      }\n      token = effects.exit('gfmFootnoteDefinitionLabelString');\n      identifier = normalizeIdentifier(self.sliceSerialize(token));\n      effects.enter('gfmFootnoteDefinitionLabelMarker');\n      effects.consume(code);\n      effects.exit('gfmFootnoteDefinitionLabelMarker');\n      effects.exit('gfmFootnoteDefinitionLabel');\n      return labelAfter;\n    }\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding');\n      effects.consume(code);\n      effects.exit('lineEnding');\n      size++;\n      return atBreak;\n    }\n    effects.enter('chunkString').contentType = 'string';\n    return label(code);\n  }\n  /** @type {State} */\n\n  function label(code) {\n    if (code === null || markdownLineEnding(code) || code === 91 || code === 93 || size > 999) {\n      effects.exit('chunkString');\n      return atBreak(code);\n    }\n    if (!markdownLineEndingOrSpace(code)) {\n      data = true;\n    }\n    size++;\n    effects.consume(code);\n    return code === 92 ? labelEscape : label;\n  }\n  /** @type {State} */\n\n  function labelEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code);\n      size++;\n      return label;\n    }\n    return label(code);\n  }\n  /** @type {State} */\n\n  function labelAfter(code) {\n    if (code === 58) {\n      effects.enter('definitionMarker');\n      effects.consume(code);\n      effects.exit('definitionMarker'); // Any whitespace after the marker is eaten, forming indented code\n      // is not possible.\n      // No space is also fine, just like a block quote marker.\n\n      return factorySpace(effects, done, 'gfmFootnoteDefinitionWhitespace');\n    }\n    return nok(code);\n  }\n  /** @type {State} */\n\n  function done(code) {\n    if (!defined.includes(identifier)) {\n      defined.push(identifier);\n    }\n    return ok(code);\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeDefinitionContinuation(effects, ok, nok) {\n  // Either a blank line, which is okay, or an indented thing.\n  return effects.check(blankLine, ok, effects.attempt(indent, ok, nok));\n}\n/** @type {Exiter} */\n\nfunction gfmFootnoteDefinitionEnd(effects) {\n  effects.exit('gfmFootnoteDefinition');\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeIndent(effects, ok, nok) {\n  var self = this;\n  return factorySpace(effects, afterPrefix, 'gfmFootnoteDefinitionIndent', 4 + 1);\n  /** @type {State} */\n\n  function afterPrefix(code) {\n    var tail = self.events[self.events.length - 1];\n    return tail && tail[1].type === 'gfmFootnoteDefinitionIndent' && tail[2].sliceSerialize(tail[1], true).length === 4 ? ok(code) : nok(code);\n  }\n}","map":{"version":3,"names":["blankLine","factorySpace","markdownLineEnding","markdownLineEndingOrSpace","normalizeIdentifier","indent","tokenize","tokenizeIndent","partial","gfmFootnote","document","tokenizeDefinitionStart","continuation","tokenizeDefinitionContinuation","exit","gfmFootnoteDefinitionEnd","text","tokenizeGfmFootnoteCall","add","tokenizePotentialGfmFootnoteCall","resolveTo","resolveToPotentialGfmFootnoteCall","effects","ok","nok","self","index","events","length","defined","parser","gfmFootnotes","labelStart","token","type","start","code","_balanced","id","sliceSerialize","end","now","charCodeAt","includes","slice","enter","consume","context","call","Object","assign","marker","column","offset","_bufferIndex","string","chunk","contentType","replacement","splice","size","data","callStart","callData","callEscape","identifier","_container","atBreak","labelAfter","label","labelEscape","done","push","check","attempt","afterPrefix","tail"],"sources":["/home/kty/workspace/seb41_pre_001/client/node_modules/micromark-extension-gfm-footnote/lib/syntax.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Event} Event\n */\nimport {blankLine} from 'micromark-core-commonmark'\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace\n} from 'micromark-util-character'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nconst indent = {\n  tokenize: tokenizeIndent,\n  partial: true\n}\n/**\n * @returns {Extension}\n */\n\nexport function gfmFootnote() {\n  /** @type {Extension} */\n  return {\n    document: {\n      [91]: {\n        tokenize: tokenizeDefinitionStart,\n        continuation: {\n          tokenize: tokenizeDefinitionContinuation\n        },\n        exit: gfmFootnoteDefinitionEnd\n      }\n    },\n    text: {\n      [91]: {\n        tokenize: tokenizeGfmFootnoteCall\n      },\n      [93]: {\n        add: 'after',\n        tokenize: tokenizePotentialGfmFootnoteCall,\n        resolveTo: resolveToPotentialGfmFootnoteCall\n      }\n    }\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizePotentialGfmFootnoteCall(effects, ok, nok) {\n  const self = this\n  let index = self.events.length\n  /** @type {Array<string>} */\n  // @ts-expect-error It’s fine!\n\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\n  /** @type {Token} */\n\n  let labelStart // Find an opening.\n\n  while (index--) {\n    const token = self.events[index][1]\n\n    if (token.type === 'labelImage') {\n      labelStart = token\n      break\n    } // Exit if we’ve walked far enough.\n\n    if (\n      token.type === 'gfmFootnoteCall' ||\n      token.type === 'labelLink' ||\n      token.type === 'label' ||\n      token.type === 'image' ||\n      token.type === 'link'\n    ) {\n      break\n    }\n  }\n\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (!labelStart || !labelStart._balanced) {\n      return nok(code)\n    }\n\n    const id = normalizeIdentifier(\n      self.sliceSerialize({\n        start: labelStart.end,\n        end: self.now()\n      })\n    )\n\n    if (id.charCodeAt(0) !== 94 || !defined.includes(id.slice(1))) {\n      return nok(code)\n    }\n\n    effects.enter('gfmFootnoteCallLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallLabelMarker')\n    return ok(code)\n  }\n}\n/** @type {Resolver} */\n\nfunction resolveToPotentialGfmFootnoteCall(events, context) {\n  let index = events.length\n  /** @type {Token|undefined} */\n\n  let labelStart // Find an opening.\n\n  while (index--) {\n    if (\n      events[index][1].type === 'labelImage' &&\n      events[index][0] === 'enter'\n    ) {\n      labelStart = events[index][1]\n      break\n    }\n  }\n\n  // Change the `labelImageMarker` to a `data`.\n  events[index + 1][1].type = 'data'\n  events[index + 3][1].type = 'gfmFootnoteCallLabelMarker' // The whole (without `!`):\n\n  const call = {\n    type: 'gfmFootnoteCall',\n    start: Object.assign({}, events[index + 3][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  } // The `^` marker\n\n  const marker = {\n    type: 'gfmFootnoteCallMarker',\n    start: Object.assign({}, events[index + 3][1].end),\n    end: Object.assign({}, events[index + 3][1].end)\n  } // Increment the end 1 character.\n\n  marker.end.column++\n  marker.end.offset++\n  marker.end._bufferIndex++\n  const string = {\n    type: 'gfmFootnoteCallString',\n    start: Object.assign({}, marker.end),\n    end: Object.assign({}, events[events.length - 1][1].start)\n  }\n  const chunk = {\n    type: 'chunkString',\n    contentType: 'string',\n    start: Object.assign({}, string.start),\n    end: Object.assign({}, string.end)\n  }\n  /** @type {Array<Event>} */\n\n  const replacement = [\n    // Take the `labelImageMarker` (now `data`, the `!`)\n    events[index + 1],\n    events[index + 2],\n    ['enter', call, context], // The `[`\n    events[index + 3],\n    events[index + 4], // The `^`.\n    ['enter', marker, context],\n    ['exit', marker, context], // Everything in between.\n    ['enter', string, context],\n    ['enter', chunk, context],\n    ['exit', chunk, context],\n    ['exit', string, context], // The ending (`]`, properly parsed and labelled).\n    events[events.length - 2],\n    events[events.length - 1],\n    ['exit', call, context]\n  ]\n  events.splice(index, events.length - index + 1, ...replacement)\n  return events\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeGfmFootnoteCall(effects, ok, nok) {\n  const self = this\n  /** @type {Array<string>} */\n  // @ts-expect-error It’s fine!\n\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\n  let size = 0\n  /** @type {boolean} */\n\n  let data\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('gfmFootnoteCall')\n    effects.enter('gfmFootnoteCallLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallLabelMarker')\n    return callStart\n  }\n  /** @type {State} */\n\n  function callStart(code) {\n    if (code !== 94) return nok(code)\n    effects.enter('gfmFootnoteCallMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallMarker')\n    effects.enter('gfmFootnoteCallString')\n    effects.enter('chunkString').contentType = 'string'\n    return callData\n  }\n  /** @type {State} */\n\n  function callData(code) {\n    /** @type {Token} */\n    let token\n\n    if (code === null || code === 91 || size++ > 999) {\n      return nok(code)\n    }\n\n    if (code === 93) {\n      if (!data) {\n        return nok(code)\n      }\n\n      effects.exit('chunkString')\n      token = effects.exit('gfmFootnoteCallString')\n      return defined.includes(normalizeIdentifier(self.sliceSerialize(token)))\n        ? end(code)\n        : nok(code)\n    }\n\n    effects.consume(code)\n\n    if (!markdownLineEndingOrSpace(code)) {\n      data = true\n    }\n\n    return code === 92 ? callEscape : callData\n  }\n  /** @type {State} */\n\n  function callEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code)\n      size++\n      return callData\n    }\n\n    return callData(code)\n  }\n  /** @type {State} */\n\n  function end(code) {\n    effects.enter('gfmFootnoteCallLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallLabelMarker')\n    effects.exit('gfmFootnoteCall')\n    return ok\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeDefinitionStart(effects, ok, nok) {\n  const self = this\n  /** @type {Array<string>} */\n  // @ts-expect-error It’s fine!\n\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\n  /** @type {string} */\n\n  let identifier\n  let size = 0\n  /** @type {boolean|undefined} */\n\n  let data\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('gfmFootnoteDefinition')._container = true\n    effects.enter('gfmFootnoteDefinitionLabel')\n    effects.enter('gfmFootnoteDefinitionLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteDefinitionLabelMarker')\n    return labelStart\n  }\n  /** @type {State} */\n\n  function labelStart(code) {\n    if (code === 94) {\n      effects.enter('gfmFootnoteDefinitionMarker')\n      effects.consume(code)\n      effects.exit('gfmFootnoteDefinitionMarker')\n      effects.enter('gfmFootnoteDefinitionLabelString')\n      return atBreak\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function atBreak(code) {\n    /** @type {Token} */\n    let token\n\n    if (code === null || code === 91 || size > 999) {\n      return nok(code)\n    }\n\n    if (code === 93) {\n      if (!data) {\n        return nok(code)\n      }\n\n      token = effects.exit('gfmFootnoteDefinitionLabelString')\n      identifier = normalizeIdentifier(self.sliceSerialize(token))\n      effects.enter('gfmFootnoteDefinitionLabelMarker')\n      effects.consume(code)\n      effects.exit('gfmFootnoteDefinitionLabelMarker')\n      effects.exit('gfmFootnoteDefinitionLabel')\n      return labelAfter\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      size++\n      return atBreak\n    }\n\n    effects.enter('chunkString').contentType = 'string'\n    return label(code)\n  }\n  /** @type {State} */\n\n  function label(code) {\n    if (\n      code === null ||\n      markdownLineEnding(code) ||\n      code === 91 ||\n      code === 93 ||\n      size > 999\n    ) {\n      effects.exit('chunkString')\n      return atBreak(code)\n    }\n\n    if (!markdownLineEndingOrSpace(code)) {\n      data = true\n    }\n\n    size++\n    effects.consume(code)\n    return code === 92 ? labelEscape : label\n  }\n  /** @type {State} */\n\n  function labelEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code)\n      size++\n      return label\n    }\n\n    return label(code)\n  }\n  /** @type {State} */\n\n  function labelAfter(code) {\n    if (code === 58) {\n      effects.enter('definitionMarker')\n      effects.consume(code)\n      effects.exit('definitionMarker') // Any whitespace after the marker is eaten, forming indented code\n      // is not possible.\n      // No space is also fine, just like a block quote marker.\n\n      return factorySpace(effects, done, 'gfmFootnoteDefinitionWhitespace')\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function done(code) {\n    if (!defined.includes(identifier)) {\n      defined.push(identifier)\n    }\n\n    return ok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeDefinitionContinuation(effects, ok, nok) {\n  // Either a blank line, which is okay, or an indented thing.\n  return effects.check(blankLine, ok, effects.attempt(indent, ok, nok))\n}\n/** @type {Exiter} */\n\nfunction gfmFootnoteDefinitionEnd(effects) {\n  effects.exit('gfmFootnoteDefinition')\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeIndent(effects, ok, nok) {\n  const self = this\n  return factorySpace(\n    effects,\n    afterPrefix,\n    'gfmFootnoteDefinitionIndent',\n    4 + 1\n  )\n  /** @type {State} */\n\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return tail &&\n      tail[1].type === 'gfmFootnoteDefinitionIndent' &&\n      tail[2].sliceSerialize(tail[1], true).length === 4\n      ? ok(code)\n      : nok(code)\n  }\n}\n"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQA,SAAS,QAAO,2BAA2B;AACnD,SAAQC,YAAY,QAAO,yBAAyB;AACpD,SACEC,kBAAkB,EAClBC,yBAAyB,QACpB,0BAA0B;AACjC,SAAQC,mBAAmB,QAAO,qCAAqC;AACvE,IAAMC,MAAM,GAAG;EACbC,QAAQ,EAAEC,cAAc;EACxBC,OAAO,EAAE;AACX,CAAC;AACD;AACA;AACA;;AAEA,OAAO,SAASC,WAAW,GAAG;EAAA;EAC5B;EACA,OAAO;IACLC,QAAQ,sBACL,EAAE,EAAG;MACJJ,QAAQ,EAAEK,uBAAuB;MACjCC,YAAY,EAAE;QACZN,QAAQ,EAAEO;MACZ,CAAC;MACDC,IAAI,EAAEC;IACR,CAAC,CACF;IACDC,IAAI,sCACD,EAAE,EAAG;MACJV,QAAQ,EAAEW;IACZ,CAAC,0BACA,EAAE,EAAG;MACJC,GAAG,EAAE,OAAO;MACZZ,QAAQ,EAAEa,gCAAgC;MAC1CC,SAAS,EAAEC;IACb,CAAC;EAEL,CAAC;AACH;AACA;;AAEA,SAASF,gCAAgC,CAACG,OAAO,EAAEC,EAAE,EAAEC,GAAG,EAAE;EAC1D,IAAMC,IAAI,GAAG,IAAI;EACjB,IAAIC,KAAK,GAAGD,IAAI,CAACE,MAAM,CAACC,MAAM;EAC9B;EACA;;EAEA,IAAMC,OAAO,GAAGJ,IAAI,CAACK,MAAM,CAACC,YAAY,KAAKN,IAAI,CAACK,MAAM,CAACC,YAAY,GAAG,EAAE,CAAC;EAC3E;;EAEA,IAAIC,UAAU,EAAC;;EAEf,OAAON,KAAK,EAAE,EAAE;IACd,IAAMO,KAAK,GAAGR,IAAI,CAACE,MAAM,CAACD,KAAK,CAAC,CAAC,CAAC,CAAC;IAEnC,IAAIO,KAAK,CAACC,IAAI,KAAK,YAAY,EAAE;MAC/BF,UAAU,GAAGC,KAAK;MAClB;IACF,CAAC,CAAC;;IAEF,IACEA,KAAK,CAACC,IAAI,KAAK,iBAAiB,IAChCD,KAAK,CAACC,IAAI,KAAK,WAAW,IAC1BD,KAAK,CAACC,IAAI,KAAK,OAAO,IACtBD,KAAK,CAACC,IAAI,KAAK,OAAO,IACtBD,KAAK,CAACC,IAAI,KAAK,MAAM,EACrB;MACA;IACF;EACF;EAEA,OAAOC,KAAK;EACZ;;EAEA,SAASA,KAAK,CAACC,IAAI,EAAE;IACnB,IAAI,CAACJ,UAAU,IAAI,CAACA,UAAU,CAACK,SAAS,EAAE;MACxC,OAAOb,GAAG,CAACY,IAAI,CAAC;IAClB;IAEA,IAAME,EAAE,GAAGlC,mBAAmB,CAC5BqB,IAAI,CAACc,cAAc,CAAC;MAClBJ,KAAK,EAAEH,UAAU,CAACQ,GAAG;MACrBA,GAAG,EAAEf,IAAI,CAACgB,GAAG;IACf,CAAC,CAAC,CACH;IAED,IAAIH,EAAE,CAACI,UAAU,CAAC,CAAC,CAAC,KAAK,EAAE,IAAI,CAACb,OAAO,CAACc,QAAQ,CAACL,EAAE,CAACM,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE;MAC7D,OAAOpB,GAAG,CAACY,IAAI,CAAC;IAClB;IAEAd,OAAO,CAACuB,KAAK,CAAC,4BAA4B,CAAC;IAC3CvB,OAAO,CAACwB,OAAO,CAACV,IAAI,CAAC;IACrBd,OAAO,CAACR,IAAI,CAAC,4BAA4B,CAAC;IAC1C,OAAOS,EAAE,CAACa,IAAI,CAAC;EACjB;AACF;AACA;;AAEA,SAASf,iCAAiC,CAACM,MAAM,EAAEoB,OAAO,EAAE;EAC1D,IAAIrB,KAAK,GAAGC,MAAM,CAACC,MAAM;EACzB;;EAEA,IAAII,UAAU,EAAC;;EAEf,OAAON,KAAK,EAAE,EAAE;IACd,IACEC,MAAM,CAACD,KAAK,CAAC,CAAC,CAAC,CAAC,CAACQ,IAAI,KAAK,YAAY,IACtCP,MAAM,CAACD,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,OAAO,EAC5B;MACAM,UAAU,GAAGL,MAAM,CAACD,KAAK,CAAC,CAAC,CAAC,CAAC;MAC7B;IACF;EACF;;EAEA;EACAC,MAAM,CAACD,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAACQ,IAAI,GAAG,MAAM;EAClCP,MAAM,CAACD,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAACQ,IAAI,GAAG,4BAA4B,EAAC;;EAEzD,IAAMc,IAAI,GAAG;IACXd,IAAI,EAAE,iBAAiB;IACvBC,KAAK,EAAEc,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEvB,MAAM,CAACD,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAACS,KAAK,CAAC;IACpDK,GAAG,EAAES,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEvB,MAAM,CAACA,MAAM,CAACC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAACY,GAAG;EACzD,CAAC,EAAC;;EAEF,IAAMW,MAAM,GAAG;IACbjB,IAAI,EAAE,uBAAuB;IAC7BC,KAAK,EAAEc,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEvB,MAAM,CAACD,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAACc,GAAG,CAAC;IAClDA,GAAG,EAAES,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEvB,MAAM,CAACD,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAACc,GAAG;EACjD,CAAC,EAAC;;EAEFW,MAAM,CAACX,GAAG,CAACY,MAAM,EAAE;EACnBD,MAAM,CAACX,GAAG,CAACa,MAAM,EAAE;EACnBF,MAAM,CAACX,GAAG,CAACc,YAAY,EAAE;EACzB,IAAMC,MAAM,GAAG;IACbrB,IAAI,EAAE,uBAAuB;IAC7BC,KAAK,EAAEc,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEC,MAAM,CAACX,GAAG,CAAC;IACpCA,GAAG,EAAES,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEvB,MAAM,CAACA,MAAM,CAACC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAACO,KAAK;EAC3D,CAAC;EACD,IAAMqB,KAAK,GAAG;IACZtB,IAAI,EAAE,aAAa;IACnBuB,WAAW,EAAE,QAAQ;IACrBtB,KAAK,EAAEc,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEK,MAAM,CAACpB,KAAK,CAAC;IACtCK,GAAG,EAAES,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEK,MAAM,CAACf,GAAG;EACnC,CAAC;EACD;;EAEA,IAAMkB,WAAW,GAAG;EAClB;EACA/B,MAAM,CAACD,KAAK,GAAG,CAAC,CAAC,EACjBC,MAAM,CAACD,KAAK,GAAG,CAAC,CAAC,EACjB,CAAC,OAAO,EAAEsB,IAAI,EAAED,OAAO,CAAC;EAAE;EAC1BpB,MAAM,CAACD,KAAK,GAAG,CAAC,CAAC,EACjBC,MAAM,CAACD,KAAK,GAAG,CAAC,CAAC;EAAE;EACnB,CAAC,OAAO,EAAEyB,MAAM,EAAEJ,OAAO,CAAC,EAC1B,CAAC,MAAM,EAAEI,MAAM,EAAEJ,OAAO,CAAC;EAAE;EAC3B,CAAC,OAAO,EAAEQ,MAAM,EAAER,OAAO,CAAC,EAC1B,CAAC,OAAO,EAAES,KAAK,EAAET,OAAO,CAAC,EACzB,CAAC,MAAM,EAAES,KAAK,EAAET,OAAO,CAAC,EACxB,CAAC,MAAM,EAAEQ,MAAM,EAAER,OAAO,CAAC;EAAE;EAC3BpB,MAAM,CAACA,MAAM,CAACC,MAAM,GAAG,CAAC,CAAC,EACzBD,MAAM,CAACA,MAAM,CAACC,MAAM,GAAG,CAAC,CAAC,EACzB,CAAC,MAAM,EAAEoB,IAAI,EAAED,OAAO,CAAC,CACxB;EACDpB,MAAM,CAACgC,MAAM,OAAbhC,MAAM,GAAQD,KAAK,EAAEC,MAAM,CAACC,MAAM,GAAGF,KAAK,GAAG,CAAC,SAAKgC,WAAW,EAAC;EAC/D,OAAO/B,MAAM;AACf;AACA;;AAEA,SAASV,uBAAuB,CAACK,OAAO,EAAEC,EAAE,EAAEC,GAAG,EAAE;EACjD,IAAMC,IAAI,GAAG,IAAI;EACjB;EACA;;EAEA,IAAMI,OAAO,GAAGJ,IAAI,CAACK,MAAM,CAACC,YAAY,KAAKN,IAAI,CAACK,MAAM,CAACC,YAAY,GAAG,EAAE,CAAC;EAC3E,IAAI6B,IAAI,GAAG,CAAC;EACZ;;EAEA,IAAIC,IAAI;EACR,OAAO1B,KAAK;EACZ;;EAEA,SAASA,KAAK,CAACC,IAAI,EAAE;IACnBd,OAAO,CAACuB,KAAK,CAAC,iBAAiB,CAAC;IAChCvB,OAAO,CAACuB,KAAK,CAAC,4BAA4B,CAAC;IAC3CvB,OAAO,CAACwB,OAAO,CAACV,IAAI,CAAC;IACrBd,OAAO,CAACR,IAAI,CAAC,4BAA4B,CAAC;IAC1C,OAAOgD,SAAS;EAClB;EACA;;EAEA,SAASA,SAAS,CAAC1B,IAAI,EAAE;IACvB,IAAIA,IAAI,KAAK,EAAE,EAAE,OAAOZ,GAAG,CAACY,IAAI,CAAC;IACjCd,OAAO,CAACuB,KAAK,CAAC,uBAAuB,CAAC;IACtCvB,OAAO,CAACwB,OAAO,CAACV,IAAI,CAAC;IACrBd,OAAO,CAACR,IAAI,CAAC,uBAAuB,CAAC;IACrCQ,OAAO,CAACuB,KAAK,CAAC,uBAAuB,CAAC;IACtCvB,OAAO,CAACuB,KAAK,CAAC,aAAa,CAAC,CAACY,WAAW,GAAG,QAAQ;IACnD,OAAOM,QAAQ;EACjB;EACA;;EAEA,SAASA,QAAQ,CAAC3B,IAAI,EAAE;IACtB;IACA,IAAIH,KAAK;IAET,IAAIG,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,EAAE,IAAIwB,IAAI,EAAE,GAAG,GAAG,EAAE;MAChD,OAAOpC,GAAG,CAACY,IAAI,CAAC;IAClB;IAEA,IAAIA,IAAI,KAAK,EAAE,EAAE;MACf,IAAI,CAACyB,IAAI,EAAE;QACT,OAAOrC,GAAG,CAACY,IAAI,CAAC;MAClB;MAEAd,OAAO,CAACR,IAAI,CAAC,aAAa,CAAC;MAC3BmB,KAAK,GAAGX,OAAO,CAACR,IAAI,CAAC,uBAAuB,CAAC;MAC7C,OAAOe,OAAO,CAACc,QAAQ,CAACvC,mBAAmB,CAACqB,IAAI,CAACc,cAAc,CAACN,KAAK,CAAC,CAAC,CAAC,GACpEO,GAAG,CAACJ,IAAI,CAAC,GACTZ,GAAG,CAACY,IAAI,CAAC;IACf;IAEAd,OAAO,CAACwB,OAAO,CAACV,IAAI,CAAC;IAErB,IAAI,CAACjC,yBAAyB,CAACiC,IAAI,CAAC,EAAE;MACpCyB,IAAI,GAAG,IAAI;IACb;IAEA,OAAOzB,IAAI,KAAK,EAAE,GAAG4B,UAAU,GAAGD,QAAQ;EAC5C;EACA;;EAEA,SAASC,UAAU,CAAC5B,IAAI,EAAE;IACxB,IAAIA,IAAI,KAAK,EAAE,IAAIA,IAAI,KAAK,EAAE,IAAIA,IAAI,KAAK,EAAE,EAAE;MAC7Cd,OAAO,CAACwB,OAAO,CAACV,IAAI,CAAC;MACrBwB,IAAI,EAAE;MACN,OAAOG,QAAQ;IACjB;IAEA,OAAOA,QAAQ,CAAC3B,IAAI,CAAC;EACvB;EACA;;EAEA,SAASI,GAAG,CAACJ,IAAI,EAAE;IACjBd,OAAO,CAACuB,KAAK,CAAC,4BAA4B,CAAC;IAC3CvB,OAAO,CAACwB,OAAO,CAACV,IAAI,CAAC;IACrBd,OAAO,CAACR,IAAI,CAAC,4BAA4B,CAAC;IAC1CQ,OAAO,CAACR,IAAI,CAAC,iBAAiB,CAAC;IAC/B,OAAOS,EAAE;EACX;AACF;AACA;;AAEA,SAASZ,uBAAuB,CAACW,OAAO,EAAEC,EAAE,EAAEC,GAAG,EAAE;EACjD,IAAMC,IAAI,GAAG,IAAI;EACjB;EACA;;EAEA,IAAMI,OAAO,GAAGJ,IAAI,CAACK,MAAM,CAACC,YAAY,KAAKN,IAAI,CAACK,MAAM,CAACC,YAAY,GAAG,EAAE,CAAC;EAC3E;;EAEA,IAAIkC,UAAU;EACd,IAAIL,IAAI,GAAG,CAAC;EACZ;;EAEA,IAAIC,IAAI;EACR,OAAO1B,KAAK;EACZ;;EAEA,SAASA,KAAK,CAACC,IAAI,EAAE;IACnBd,OAAO,CAACuB,KAAK,CAAC,uBAAuB,CAAC,CAACqB,UAAU,GAAG,IAAI;IACxD5C,OAAO,CAACuB,KAAK,CAAC,4BAA4B,CAAC;IAC3CvB,OAAO,CAACuB,KAAK,CAAC,kCAAkC,CAAC;IACjDvB,OAAO,CAACwB,OAAO,CAACV,IAAI,CAAC;IACrBd,OAAO,CAACR,IAAI,CAAC,kCAAkC,CAAC;IAChD,OAAOkB,UAAU;EACnB;EACA;;EAEA,SAASA,UAAU,CAACI,IAAI,EAAE;IACxB,IAAIA,IAAI,KAAK,EAAE,EAAE;MACfd,OAAO,CAACuB,KAAK,CAAC,6BAA6B,CAAC;MAC5CvB,OAAO,CAACwB,OAAO,CAACV,IAAI,CAAC;MACrBd,OAAO,CAACR,IAAI,CAAC,6BAA6B,CAAC;MAC3CQ,OAAO,CAACuB,KAAK,CAAC,kCAAkC,CAAC;MACjD,OAAOsB,OAAO;IAChB;IAEA,OAAO3C,GAAG,CAACY,IAAI,CAAC;EAClB;EACA;;EAEA,SAAS+B,OAAO,CAAC/B,IAAI,EAAE;IACrB;IACA,IAAIH,KAAK;IAET,IAAIG,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,EAAE,IAAIwB,IAAI,GAAG,GAAG,EAAE;MAC9C,OAAOpC,GAAG,CAACY,IAAI,CAAC;IAClB;IAEA,IAAIA,IAAI,KAAK,EAAE,EAAE;MACf,IAAI,CAACyB,IAAI,EAAE;QACT,OAAOrC,GAAG,CAACY,IAAI,CAAC;MAClB;MAEAH,KAAK,GAAGX,OAAO,CAACR,IAAI,CAAC,kCAAkC,CAAC;MACxDmD,UAAU,GAAG7D,mBAAmB,CAACqB,IAAI,CAACc,cAAc,CAACN,KAAK,CAAC,CAAC;MAC5DX,OAAO,CAACuB,KAAK,CAAC,kCAAkC,CAAC;MACjDvB,OAAO,CAACwB,OAAO,CAACV,IAAI,CAAC;MACrBd,OAAO,CAACR,IAAI,CAAC,kCAAkC,CAAC;MAChDQ,OAAO,CAACR,IAAI,CAAC,4BAA4B,CAAC;MAC1C,OAAOsD,UAAU;IACnB;IAEA,IAAIlE,kBAAkB,CAACkC,IAAI,CAAC,EAAE;MAC5Bd,OAAO,CAACuB,KAAK,CAAC,YAAY,CAAC;MAC3BvB,OAAO,CAACwB,OAAO,CAACV,IAAI,CAAC;MACrBd,OAAO,CAACR,IAAI,CAAC,YAAY,CAAC;MAC1B8C,IAAI,EAAE;MACN,OAAOO,OAAO;IAChB;IAEA7C,OAAO,CAACuB,KAAK,CAAC,aAAa,CAAC,CAACY,WAAW,GAAG,QAAQ;IACnD,OAAOY,KAAK,CAACjC,IAAI,CAAC;EACpB;EACA;;EAEA,SAASiC,KAAK,CAACjC,IAAI,EAAE;IACnB,IACEA,IAAI,KAAK,IAAI,IACblC,kBAAkB,CAACkC,IAAI,CAAC,IACxBA,IAAI,KAAK,EAAE,IACXA,IAAI,KAAK,EAAE,IACXwB,IAAI,GAAG,GAAG,EACV;MACAtC,OAAO,CAACR,IAAI,CAAC,aAAa,CAAC;MAC3B,OAAOqD,OAAO,CAAC/B,IAAI,CAAC;IACtB;IAEA,IAAI,CAACjC,yBAAyB,CAACiC,IAAI,CAAC,EAAE;MACpCyB,IAAI,GAAG,IAAI;IACb;IAEAD,IAAI,EAAE;IACNtC,OAAO,CAACwB,OAAO,CAACV,IAAI,CAAC;IACrB,OAAOA,IAAI,KAAK,EAAE,GAAGkC,WAAW,GAAGD,KAAK;EAC1C;EACA;;EAEA,SAASC,WAAW,CAAClC,IAAI,EAAE;IACzB,IAAIA,IAAI,KAAK,EAAE,IAAIA,IAAI,KAAK,EAAE,IAAIA,IAAI,KAAK,EAAE,EAAE;MAC7Cd,OAAO,CAACwB,OAAO,CAACV,IAAI,CAAC;MACrBwB,IAAI,EAAE;MACN,OAAOS,KAAK;IACd;IAEA,OAAOA,KAAK,CAACjC,IAAI,CAAC;EACpB;EACA;;EAEA,SAASgC,UAAU,CAAChC,IAAI,EAAE;IACxB,IAAIA,IAAI,KAAK,EAAE,EAAE;MACfd,OAAO,CAACuB,KAAK,CAAC,kBAAkB,CAAC;MACjCvB,OAAO,CAACwB,OAAO,CAACV,IAAI,CAAC;MACrBd,OAAO,CAACR,IAAI,CAAC,kBAAkB,CAAC,EAAC;MACjC;MACA;;MAEA,OAAOb,YAAY,CAACqB,OAAO,EAAEiD,IAAI,EAAE,iCAAiC,CAAC;IACvE;IAEA,OAAO/C,GAAG,CAACY,IAAI,CAAC;EAClB;EACA;;EAEA,SAASmC,IAAI,CAACnC,IAAI,EAAE;IAClB,IAAI,CAACP,OAAO,CAACc,QAAQ,CAACsB,UAAU,CAAC,EAAE;MACjCpC,OAAO,CAAC2C,IAAI,CAACP,UAAU,CAAC;IAC1B;IAEA,OAAO1C,EAAE,CAACa,IAAI,CAAC;EACjB;AACF;AACA;;AAEA,SAASvB,8BAA8B,CAACS,OAAO,EAAEC,EAAE,EAAEC,GAAG,EAAE;EACxD;EACA,OAAOF,OAAO,CAACmD,KAAK,CAACzE,SAAS,EAAEuB,EAAE,EAAED,OAAO,CAACoD,OAAO,CAACrE,MAAM,EAAEkB,EAAE,EAAEC,GAAG,CAAC,CAAC;AACvE;AACA;;AAEA,SAAST,wBAAwB,CAACO,OAAO,EAAE;EACzCA,OAAO,CAACR,IAAI,CAAC,uBAAuB,CAAC;AACvC;AACA;;AAEA,SAASP,cAAc,CAACe,OAAO,EAAEC,EAAE,EAAEC,GAAG,EAAE;EACxC,IAAMC,IAAI,GAAG,IAAI;EACjB,OAAOxB,YAAY,CACjBqB,OAAO,EACPqD,WAAW,EACX,6BAA6B,EAC7B,CAAC,GAAG,CAAC,CACN;EACD;;EAEA,SAASA,WAAW,CAACvC,IAAI,EAAE;IACzB,IAAMwC,IAAI,GAAGnD,IAAI,CAACE,MAAM,CAACF,IAAI,CAACE,MAAM,CAACC,MAAM,GAAG,CAAC,CAAC;IAChD,OAAOgD,IAAI,IACTA,IAAI,CAAC,CAAC,CAAC,CAAC1C,IAAI,KAAK,6BAA6B,IAC9C0C,IAAI,CAAC,CAAC,CAAC,CAACrC,cAAc,CAACqC,IAAI,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAAChD,MAAM,KAAK,CAAC,GAChDL,EAAE,CAACa,IAAI,CAAC,GACRZ,GAAG,CAACY,IAAI,CAAC;EACf;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}
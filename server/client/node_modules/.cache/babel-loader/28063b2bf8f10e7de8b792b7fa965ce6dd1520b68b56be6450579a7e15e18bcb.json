{"ast":null,"code":"/**\n * @typedef {import('unist').Point} Point\n * @typedef {import('unist').Position} Position\n */\n\nimport { characterEntitiesLegacy } from 'character-entities-legacy';\nimport { characterReferenceInvalid } from 'character-reference-invalid';\nimport { isDecimal } from 'is-decimal';\nimport { isHexadecimal } from 'is-hexadecimal';\nimport { isAlphanumerical } from 'is-alphanumerical';\nimport { decodeNamedCharacterReference } from 'decode-named-character-reference';\nconst fromCharCode = String.fromCharCode;\n\n// Warning messages.\nconst messages = ['', /* 1: Non terminated (named) */\n'Named character references must be terminated by a semicolon', /* 2: Non terminated (numeric) */\n'Numeric character references must be terminated by a semicolon', /* 3: Empty (named) */\n'Named character references cannot be empty', /* 4: Empty (numeric) */\n'Numeric character references cannot be empty', /* 5: Unknown (named) */\n'Named character references must be known', /* 6: Disallowed (numeric) */\n'Numeric character references cannot be disallowed', /* 7: Prohibited (numeric) */\n'Numeric character references cannot be outside the permissible Unicode range'];\n\n/**\n * Parse HTML character references.\n *\n * @param {string} value\n * @param {import('../index.js').Options} [options={}]\n */\nexport function parseEntities(value) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const additional = typeof options.additional === 'string' ? options.additional.charCodeAt(0) : options.additional;\n  /** @type {string[]} */\n  const result = [];\n  let index = 0;\n  let lines = -1;\n  let queue = '';\n  /** @type {Point|undefined} */\n  let point;\n  /** @type {number[]|undefined} */\n  let indent;\n  if (options.position) {\n    if ('start' in options.position || 'indent' in options.position) {\n      indent = options.position.indent;\n      point = options.position.start;\n    } else {\n      point = options.position;\n    }\n  }\n  let line = (point ? point.line : 0) || 1;\n  let column = (point ? point.column : 0) || 1;\n\n  // Cache the current point.\n  let previous = now();\n  /** @type {number|undefined} */\n  let character;\n\n  // Ensure the algorithm walks over the first character (inclusive).\n  index--;\n  while (++index <= value.length) {\n    // If the previous character was a newline.\n    if (character === 10 /* `\\n` */) {\n      column = (indent ? indent[lines] : 0) || 1;\n    }\n    character = value.charCodeAt(index);\n    if (character === 38 /* `&` */) {\n      const following = value.charCodeAt(index + 1);\n\n      // The behavior depends on the identity of the next character.\n      if (following === 9 /* `\\t` */ || following === 10 /* `\\n` */ || following === 12 /* `\\f` */ || following === 32 /* ` ` */ || following === 38 /* `&` */ || following === 60 /* `<` */ || Number.isNaN(following) || additional && following === additional) {\n        // Not a character reference.\n        // No characters are consumed, and nothing is returned.\n        // This is not an error, either.\n        queue += fromCharCode(character);\n        column++;\n        continue;\n      }\n      const start = index + 1;\n      let begin = start;\n      let end = start;\n      /** @type {string} */\n      let type;\n      if (following === 35 /* `#` */) {\n        // Numerical reference.\n        end = ++begin;\n\n        // The behavior further depends on the next character.\n        const following = value.charCodeAt(end);\n        if (following === 88 /* `X` */ || following === 120 /* `x` */) {\n          // ASCII hexadecimal digits.\n          type = 'hexadecimal';\n          end = ++begin;\n        } else {\n          // ASCII decimal digits.\n          type = 'decimal';\n        }\n      } else {\n        // Named reference.\n        type = 'named';\n      }\n      let characterReferenceCharacters = '';\n      let characterReference = '';\n      let characters = '';\n      // Each type of character reference accepts different characters.\n      // This test is used to detect whether a reference has ended (as the semicolon\n      // is not strictly needed).\n      const test = type === 'named' ? isAlphanumerical : type === 'decimal' ? isDecimal : isHexadecimal;\n      end--;\n      while (++end <= value.length) {\n        const following = value.charCodeAt(end);\n        if (!test(following)) {\n          break;\n        }\n        characters += fromCharCode(following);\n\n        // Check if we can match a legacy named reference.\n        // If so, we cache that as the last viable named reference.\n        // This ensures we do not need to walk backwards later.\n        if (type === 'named' && characterEntitiesLegacy.includes(characters)) {\n          characterReferenceCharacters = characters;\n          // @ts-expect-error: always able to decode.\n          characterReference = decodeNamedCharacterReference(characters);\n        }\n      }\n      let terminated = value.charCodeAt(end) === 59; /* `;` */\n\n      if (terminated) {\n        end++;\n        const namedReference = type === 'named' ? decodeNamedCharacterReference(characters) : false;\n        if (namedReference) {\n          characterReferenceCharacters = characters;\n          characterReference = namedReference;\n        }\n      }\n      let diff = 1 + end - start;\n      let reference = '';\n      if (!terminated && options.nonTerminated === false) {\n        // Empty.\n      } else if (!characters) {\n        // An empty (possible) reference is valid, unless it’s numeric (thus an\n        // ampersand followed by an octothorp).\n        if (type !== 'named') {\n          warning(4 /* Empty (numeric) */, diff);\n        }\n      } else if (type === 'named') {\n        // An ampersand followed by anything unknown, and not terminated, is\n        // invalid.\n        if (terminated && !characterReference) {\n          warning(5 /* Unknown (named) */, 1);\n        } else {\n          // If there’s something after an named reference which is not known,\n          // cap the reference.\n          if (characterReferenceCharacters !== characters) {\n            end = begin + characterReferenceCharacters.length;\n            diff = 1 + end - begin;\n            terminated = false;\n          }\n\n          // If the reference is not terminated, warn.\n          if (!terminated) {\n            const reason = characterReferenceCharacters ? 1 /* Non terminated (named) */ : 3; /* Empty (named) */\n\n            if (options.attribute) {\n              const following = value.charCodeAt(end);\n              if (following === 61 /* `=` */) {\n                warning(reason, diff);\n                characterReference = '';\n              } else if (isAlphanumerical(following)) {\n                characterReference = '';\n              } else {\n                warning(reason, diff);\n              }\n            } else {\n              warning(reason, diff);\n            }\n          }\n        }\n        reference = characterReference;\n      } else {\n        if (!terminated) {\n          // All nonterminated numeric references are not rendered, and emit a\n          // warning.\n          warning(2 /* Non terminated (numeric) */, diff);\n        }\n\n        // When terminated and numerical, parse as either hexadecimal or\n        // decimal.\n        let referenceCode = Number.parseInt(characters, type === 'hexadecimal' ? 16 : 10);\n\n        // Emit a warning when the parsed number is prohibited, and replace with\n        // replacement character.\n        if (prohibited(referenceCode)) {\n          warning(7 /* Prohibited (numeric) */, diff);\n          reference = fromCharCode(65533 /* `�` */);\n        } else if (referenceCode in characterReferenceInvalid) {\n          // Emit a warning when the parsed number is disallowed, and replace by\n          // an alternative.\n          warning(6 /* Disallowed (numeric) */, diff);\n          reference = characterReferenceInvalid[referenceCode];\n        } else {\n          // Parse the number.\n          let output = '';\n\n          // Emit a warning when the parsed number should not be used.\n          if (disallowed(referenceCode)) {\n            warning(6 /* Disallowed (numeric) */, diff);\n          }\n\n          // Serialize the number.\n          if (referenceCode > 0xffff) {\n            referenceCode -= 0x10000;\n            output += fromCharCode(referenceCode >>> (10 & 0x3ff) | 0xd800);\n            referenceCode = 0xdc00 | referenceCode & 0x3ff;\n          }\n          reference = output + fromCharCode(referenceCode);\n        }\n      }\n\n      // Found it!\n      // First eat the queued characters as normal text, then eat a reference.\n      if (reference) {\n        flush();\n        previous = now();\n        index = end - 1;\n        column += end - start + 1;\n        result.push(reference);\n        const next = now();\n        next.offset++;\n        if (options.reference) {\n          options.reference.call(options.referenceContext, reference, {\n            start: previous,\n            end: next\n          }, value.slice(start - 1, end));\n        }\n        previous = next;\n      } else {\n        // If we could not find a reference, queue the checked characters (as\n        // normal characters), and move the pointer to their end.\n        // This is possible because we can be certain neither newlines nor\n        // ampersands are included.\n        characters = value.slice(start - 1, end);\n        queue += characters;\n        column += characters.length;\n        index = end - 1;\n      }\n    } else {\n      // Handle anything other than an ampersand, including newlines and EOF.\n      if (character === 10 /* `\\n` */) {\n        line++;\n        lines++;\n        column = 0;\n      }\n      if (Number.isNaN(character)) {\n        flush();\n      } else {\n        queue += fromCharCode(character);\n        column++;\n      }\n    }\n  }\n\n  // Return the reduced nodes.\n  return result.join('');\n\n  // Get current position.\n  function now() {\n    return {\n      line,\n      column,\n      offset: index + ((point ? point.offset : 0) || 0)\n    };\n  }\n\n  /**\n   * Handle the warning.\n   *\n   * @param {1|2|3|4|5|6|7} code\n   * @param {number} offset\n   */\n  function warning(code, offset) {\n    /** @type {ReturnType<now>} */\n    let position;\n    if (options.warning) {\n      position = now();\n      position.column += offset;\n      position.offset += offset;\n      options.warning.call(options.warningContext, messages[code], position, code);\n    }\n  }\n\n  /**\n   * Flush `queue` (normal text).\n   * Macro invoked before each reference and at the end of `value`.\n   * Does nothing when `queue` is empty.\n   */\n  function flush() {\n    if (queue) {\n      result.push(queue);\n      if (options.text) {\n        options.text.call(options.textContext, queue, {\n          start: previous,\n          end: now()\n        });\n      }\n      queue = '';\n    }\n  }\n}\n\n/**\n * Check if `character` is outside the permissible unicode range.\n *\n * @param {number} code\n * @returns {boolean}\n */\nfunction prohibited(code) {\n  return code >= 0xd800 && code <= 0xdfff || code > 0x10ffff;\n}\n\n/**\n * Check if `character` is disallowed.\n *\n * @param {number} code\n * @returns {boolean}\n */\nfunction disallowed(code) {\n  return code >= 0x0001 && code <= 0x0008 || code === 0x000b || code >= 0x000d && code <= 0x001f || code >= 0x007f && code <= 0x009f || code >= 0xfdd0 && code <= 0xfdef || (code & 0xffff) === 0xffff || (code & 0xffff) === 0xfffe;\n}","map":{"version":3,"names":["characterEntitiesLegacy","characterReferenceInvalid","isDecimal","isHexadecimal","isAlphanumerical","decodeNamedCharacterReference","fromCharCode","String","messages","parseEntities","value","options","additional","charCodeAt","result","index","lines","queue","point","indent","position","start","line","column","previous","now","character","length","following","Number","isNaN","begin","end","type","characterReferenceCharacters","characterReference","characters","test","includes","terminated","namedReference","diff","reference","nonTerminated","warning","reason","attribute","referenceCode","parseInt","prohibited","output","disallowed","flush","push","next","offset","call","referenceContext","slice","join","code","warningContext","text","textContext"],"sources":["/home/kty/workspace/seb41_pre_001/client/node_modules/parse-entities/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('unist').Point} Point\n * @typedef {import('unist').Position} Position\n */\n\nimport {characterEntitiesLegacy} from 'character-entities-legacy'\nimport {characterReferenceInvalid} from 'character-reference-invalid'\nimport {isDecimal} from 'is-decimal'\nimport {isHexadecimal} from 'is-hexadecimal'\nimport {isAlphanumerical} from 'is-alphanumerical'\nimport {decodeNamedCharacterReference} from 'decode-named-character-reference'\n\nconst fromCharCode = String.fromCharCode\n\n// Warning messages.\nconst messages = [\n  '',\n  /* 1: Non terminated (named) */\n  'Named character references must be terminated by a semicolon',\n  /* 2: Non terminated (numeric) */\n  'Numeric character references must be terminated by a semicolon',\n  /* 3: Empty (named) */\n  'Named character references cannot be empty',\n  /* 4: Empty (numeric) */\n  'Numeric character references cannot be empty',\n  /* 5: Unknown (named) */\n  'Named character references must be known',\n  /* 6: Disallowed (numeric) */\n  'Numeric character references cannot be disallowed',\n  /* 7: Prohibited (numeric) */\n  'Numeric character references cannot be outside the permissible Unicode range'\n]\n\n/**\n * Parse HTML character references.\n *\n * @param {string} value\n * @param {import('../index.js').Options} [options={}]\n */\nexport function parseEntities(value, options = {}) {\n  const additional =\n    typeof options.additional === 'string'\n      ? options.additional.charCodeAt(0)\n      : options.additional\n  /** @type {string[]} */\n  const result = []\n  let index = 0\n  let lines = -1\n  let queue = ''\n  /** @type {Point|undefined} */\n  let point\n  /** @type {number[]|undefined} */\n  let indent\n\n  if (options.position) {\n    if ('start' in options.position || 'indent' in options.position) {\n      indent = options.position.indent\n      point = options.position.start\n    } else {\n      point = options.position\n    }\n  }\n\n  let line = (point ? point.line : 0) || 1\n  let column = (point ? point.column : 0) || 1\n\n  // Cache the current point.\n  let previous = now()\n  /** @type {number|undefined} */\n  let character\n\n  // Ensure the algorithm walks over the first character (inclusive).\n  index--\n\n  while (++index <= value.length) {\n    // If the previous character was a newline.\n    if (character === 10 /* `\\n` */) {\n      column = (indent ? indent[lines] : 0) || 1\n    }\n\n    character = value.charCodeAt(index)\n\n    if (character === 38 /* `&` */) {\n      const following = value.charCodeAt(index + 1)\n\n      // The behavior depends on the identity of the next character.\n      if (\n        following === 9 /* `\\t` */ ||\n        following === 10 /* `\\n` */ ||\n        following === 12 /* `\\f` */ ||\n        following === 32 /* ` ` */ ||\n        following === 38 /* `&` */ ||\n        following === 60 /* `<` */ ||\n        Number.isNaN(following) ||\n        (additional && following === additional)\n      ) {\n        // Not a character reference.\n        // No characters are consumed, and nothing is returned.\n        // This is not an error, either.\n        queue += fromCharCode(character)\n        column++\n        continue\n      }\n\n      const start = index + 1\n      let begin = start\n      let end = start\n      /** @type {string} */\n      let type\n\n      if (following === 35 /* `#` */) {\n        // Numerical reference.\n        end = ++begin\n\n        // The behavior further depends on the next character.\n        const following = value.charCodeAt(end)\n\n        if (following === 88 /* `X` */ || following === 120 /* `x` */) {\n          // ASCII hexadecimal digits.\n          type = 'hexadecimal'\n          end = ++begin\n        } else {\n          // ASCII decimal digits.\n          type = 'decimal'\n        }\n      } else {\n        // Named reference.\n        type = 'named'\n      }\n\n      let characterReferenceCharacters = ''\n      let characterReference = ''\n      let characters = ''\n      // Each type of character reference accepts different characters.\n      // This test is used to detect whether a reference has ended (as the semicolon\n      // is not strictly needed).\n      const test =\n        type === 'named'\n          ? isAlphanumerical\n          : type === 'decimal'\n          ? isDecimal\n          : isHexadecimal\n\n      end--\n\n      while (++end <= value.length) {\n        const following = value.charCodeAt(end)\n\n        if (!test(following)) {\n          break\n        }\n\n        characters += fromCharCode(following)\n\n        // Check if we can match a legacy named reference.\n        // If so, we cache that as the last viable named reference.\n        // This ensures we do not need to walk backwards later.\n        if (type === 'named' && characterEntitiesLegacy.includes(characters)) {\n          characterReferenceCharacters = characters\n          // @ts-expect-error: always able to decode.\n          characterReference = decodeNamedCharacterReference(characters)\n        }\n      }\n\n      let terminated = value.charCodeAt(end) === 59 /* `;` */\n\n      if (terminated) {\n        end++\n\n        const namedReference =\n          type === 'named' ? decodeNamedCharacterReference(characters) : false\n\n        if (namedReference) {\n          characterReferenceCharacters = characters\n          characterReference = namedReference\n        }\n      }\n\n      let diff = 1 + end - start\n      let reference = ''\n\n      if (!terminated && options.nonTerminated === false) {\n        // Empty.\n      } else if (!characters) {\n        // An empty (possible) reference is valid, unless it’s numeric (thus an\n        // ampersand followed by an octothorp).\n        if (type !== 'named') {\n          warning(4 /* Empty (numeric) */, diff)\n        }\n      } else if (type === 'named') {\n        // An ampersand followed by anything unknown, and not terminated, is\n        // invalid.\n        if (terminated && !characterReference) {\n          warning(5 /* Unknown (named) */, 1)\n        } else {\n          // If there’s something after an named reference which is not known,\n          // cap the reference.\n          if (characterReferenceCharacters !== characters) {\n            end = begin + characterReferenceCharacters.length\n            diff = 1 + end - begin\n            terminated = false\n          }\n\n          // If the reference is not terminated, warn.\n          if (!terminated) {\n            const reason = characterReferenceCharacters\n              ? 1 /* Non terminated (named) */\n              : 3 /* Empty (named) */\n\n            if (options.attribute) {\n              const following = value.charCodeAt(end)\n\n              if (following === 61 /* `=` */) {\n                warning(reason, diff)\n                characterReference = ''\n              } else if (isAlphanumerical(following)) {\n                characterReference = ''\n              } else {\n                warning(reason, diff)\n              }\n            } else {\n              warning(reason, diff)\n            }\n          }\n        }\n\n        reference = characterReference\n      } else {\n        if (!terminated) {\n          // All nonterminated numeric references are not rendered, and emit a\n          // warning.\n          warning(2 /* Non terminated (numeric) */, diff)\n        }\n\n        // When terminated and numerical, parse as either hexadecimal or\n        // decimal.\n        let referenceCode = Number.parseInt(\n          characters,\n          type === 'hexadecimal' ? 16 : 10\n        )\n\n        // Emit a warning when the parsed number is prohibited, and replace with\n        // replacement character.\n        if (prohibited(referenceCode)) {\n          warning(7 /* Prohibited (numeric) */, diff)\n          reference = fromCharCode(65533 /* `�` */)\n        } else if (referenceCode in characterReferenceInvalid) {\n          // Emit a warning when the parsed number is disallowed, and replace by\n          // an alternative.\n          warning(6 /* Disallowed (numeric) */, diff)\n          reference = characterReferenceInvalid[referenceCode]\n        } else {\n          // Parse the number.\n          let output = ''\n\n          // Emit a warning when the parsed number should not be used.\n          if (disallowed(referenceCode)) {\n            warning(6 /* Disallowed (numeric) */, diff)\n          }\n\n          // Serialize the number.\n          if (referenceCode > 0xffff) {\n            referenceCode -= 0x10000\n            output += fromCharCode((referenceCode >>> (10 & 0x3ff)) | 0xd800)\n            referenceCode = 0xdc00 | (referenceCode & 0x3ff)\n          }\n\n          reference = output + fromCharCode(referenceCode)\n        }\n      }\n\n      // Found it!\n      // First eat the queued characters as normal text, then eat a reference.\n      if (reference) {\n        flush()\n\n        previous = now()\n        index = end - 1\n        column += end - start + 1\n        result.push(reference)\n        const next = now()\n        next.offset++\n\n        if (options.reference) {\n          options.reference.call(\n            options.referenceContext,\n            reference,\n            {start: previous, end: next},\n            value.slice(start - 1, end)\n          )\n        }\n\n        previous = next\n      } else {\n        // If we could not find a reference, queue the checked characters (as\n        // normal characters), and move the pointer to their end.\n        // This is possible because we can be certain neither newlines nor\n        // ampersands are included.\n        characters = value.slice(start - 1, end)\n        queue += characters\n        column += characters.length\n        index = end - 1\n      }\n    } else {\n      // Handle anything other than an ampersand, including newlines and EOF.\n      if (character === 10 /* `\\n` */) {\n        line++\n        lines++\n        column = 0\n      }\n\n      if (Number.isNaN(character)) {\n        flush()\n      } else {\n        queue += fromCharCode(character)\n        column++\n      }\n    }\n  }\n\n  // Return the reduced nodes.\n  return result.join('')\n\n  // Get current position.\n  function now() {\n    return {\n      line,\n      column,\n      offset: index + ((point ? point.offset : 0) || 0)\n    }\n  }\n\n  /**\n   * Handle the warning.\n   *\n   * @param {1|2|3|4|5|6|7} code\n   * @param {number} offset\n   */\n  function warning(code, offset) {\n    /** @type {ReturnType<now>} */\n    let position\n\n    if (options.warning) {\n      position = now()\n      position.column += offset\n      position.offset += offset\n\n      options.warning.call(\n        options.warningContext,\n        messages[code],\n        position,\n        code\n      )\n    }\n  }\n\n  /**\n   * Flush `queue` (normal text).\n   * Macro invoked before each reference and at the end of `value`.\n   * Does nothing when `queue` is empty.\n   */\n  function flush() {\n    if (queue) {\n      result.push(queue)\n\n      if (options.text) {\n        options.text.call(options.textContext, queue, {\n          start: previous,\n          end: now()\n        })\n      }\n\n      queue = ''\n    }\n  }\n}\n\n/**\n * Check if `character` is outside the permissible unicode range.\n *\n * @param {number} code\n * @returns {boolean}\n */\nfunction prohibited(code) {\n  return (code >= 0xd800 && code <= 0xdfff) || code > 0x10ffff\n}\n\n/**\n * Check if `character` is disallowed.\n *\n * @param {number} code\n * @returns {boolean}\n */\nfunction disallowed(code) {\n  return (\n    (code >= 0x0001 && code <= 0x0008) ||\n    code === 0x000b ||\n    (code >= 0x000d && code <= 0x001f) ||\n    (code >= 0x007f && code <= 0x009f) ||\n    (code >= 0xfdd0 && code <= 0xfdef) ||\n    (code & 0xffff) === 0xffff ||\n    (code & 0xffff) === 0xfffe\n  )\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import _defineProperty from \"/home/kty/workspace/seb41_pre_001/client/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEndingOrSpace, markdownLineEnding } from 'micromark-util-character';\nvar tasklistCheck = {\n  tokenize: tokenizeTasklistCheck\n};\nexport var gfmTaskListItem = {\n  text: _defineProperty({}, 91, tasklistCheck)\n};\n/** @type {Tokenizer} */\n\nfunction tokenizeTasklistCheck(effects, ok, nok) {\n  var self = this;\n  return open;\n  /** @type {State} */\n\n  function open(code) {\n    if (\n    // Exit if there’s stuff before.\n    self.previous !== null ||\n    // Exit if not in the first content that is the first child of a list\n    // item.\n    !self._gfmTasklistFirstContentOfListItem) {\n      return nok(code);\n    }\n    effects.enter('taskListCheck');\n    effects.enter('taskListCheckMarker');\n    effects.consume(code);\n    effects.exit('taskListCheckMarker');\n    return inside;\n  }\n  /** @type {State} */\n\n  function inside(code) {\n    // To match how GH works in comments, use `markdownSpace` (`[ \\t]`) instead\n    // of `markdownLineEndingOrSpace` (`[ \\t\\r\\n]`).\n    if (markdownLineEndingOrSpace(code)) {\n      effects.enter('taskListCheckValueUnchecked');\n      effects.consume(code);\n      effects.exit('taskListCheckValueUnchecked');\n      return close;\n    }\n    if (code === 88 || code === 120) {\n      effects.enter('taskListCheckValueChecked');\n      effects.consume(code);\n      effects.exit('taskListCheckValueChecked');\n      return close;\n    }\n    return nok(code);\n  }\n  /** @type {State} */\n\n  function close(code) {\n    if (code === 93) {\n      effects.enter('taskListCheckMarker');\n      effects.consume(code);\n      effects.exit('taskListCheckMarker');\n      effects.exit('taskListCheck');\n      return effects.check({\n        tokenize: spaceThenNonSpace\n      }, ok, nok);\n    }\n    return nok(code);\n  }\n}\n/** @type {Tokenizer} */\n\nfunction spaceThenNonSpace(effects, ok, nok) {\n  var self = this;\n  return factorySpace(effects, after, 'whitespace');\n  /** @type {State} */\n\n  function after(code) {\n    var tail = self.events[self.events.length - 1];\n    return (\n      // We either found spaces…\n      (tail && tail[1].type === 'whitespace' ||\n      // …or it was followed by a line ending, in which case, there has to be\n      // non-whitespace after that line ending, because otherwise we’d get an\n      // EOF as the content is closed with blank lines.\n      markdownLineEnding(code)) && code !== null ? ok(code) : nok(code)\n    );\n  }\n}","map":{"version":3,"names":["factorySpace","markdownLineEndingOrSpace","markdownLineEnding","tasklistCheck","tokenize","tokenizeTasklistCheck","gfmTaskListItem","text","effects","ok","nok","self","open","code","previous","_gfmTasklistFirstContentOfListItem","enter","consume","exit","inside","close","check","spaceThenNonSpace","after","tail","events","length","type"],"sources":["/home/kty/workspace/seb41_pre_001/client/node_modules/micromark-extension-gfm-task-list-item/lib/syntax.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEndingOrSpace,\n  markdownLineEnding\n} from 'micromark-util-character'\nconst tasklistCheck = {\n  tokenize: tokenizeTasklistCheck\n}\nexport const gfmTaskListItem = {\n  text: {\n    [91]: tasklistCheck\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeTasklistCheck(effects, ok, nok) {\n  const self = this\n  return open\n  /** @type {State} */\n\n  function open(code) {\n    if (\n      // Exit if there’s stuff before.\n      self.previous !== null || // Exit if not in the first content that is the first child of a list\n      // item.\n      !self._gfmTasklistFirstContentOfListItem\n    ) {\n      return nok(code)\n    }\n\n    effects.enter('taskListCheck')\n    effects.enter('taskListCheckMarker')\n    effects.consume(code)\n    effects.exit('taskListCheckMarker')\n    return inside\n  }\n  /** @type {State} */\n\n  function inside(code) {\n    // To match how GH works in comments, use `markdownSpace` (`[ \\t]`) instead\n    // of `markdownLineEndingOrSpace` (`[ \\t\\r\\n]`).\n    if (markdownLineEndingOrSpace(code)) {\n      effects.enter('taskListCheckValueUnchecked')\n      effects.consume(code)\n      effects.exit('taskListCheckValueUnchecked')\n      return close\n    }\n\n    if (code === 88 || code === 120) {\n      effects.enter('taskListCheckValueChecked')\n      effects.consume(code)\n      effects.exit('taskListCheckValueChecked')\n      return close\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function close(code) {\n    if (code === 93) {\n      effects.enter('taskListCheckMarker')\n      effects.consume(code)\n      effects.exit('taskListCheckMarker')\n      effects.exit('taskListCheck')\n      return effects.check(\n        {\n          tokenize: spaceThenNonSpace\n        },\n        ok,\n        nok\n      )\n    }\n\n    return nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction spaceThenNonSpace(effects, ok, nok) {\n  const self = this\n  return factorySpace(effects, after, 'whitespace')\n  /** @type {State} */\n\n  function after(code) {\n    const tail = self.events[self.events.length - 1]\n    return (\n      // We either found spaces…\n      ((tail && tail[1].type === 'whitespace') || // …or it was followed by a line ending, in which case, there has to be\n        // non-whitespace after that line ending, because otherwise we’d get an\n        // EOF as the content is closed with blank lines.\n        markdownLineEnding(code)) &&\n        code !== null\n        ? ok(code)\n        : nok(code)\n    )\n  }\n}\n"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQA,YAAY,QAAO,yBAAyB;AACpD,SACEC,yBAAyB,EACzBC,kBAAkB,QACb,0BAA0B;AACjC,IAAMC,aAAa,GAAG;EACpBC,QAAQ,EAAEC;AACZ,CAAC;AACD,OAAO,IAAMC,eAAe,GAAG;EAC7BC,IAAI,sBACD,EAAE,EAAGJ,aAAa;AAEvB,CAAC;AACD;;AAEA,SAASE,qBAAqB,CAACG,OAAO,EAAEC,EAAE,EAAEC,GAAG,EAAE;EAC/C,IAAMC,IAAI,GAAG,IAAI;EACjB,OAAOC,IAAI;EACX;;EAEA,SAASA,IAAI,CAACC,IAAI,EAAE;IAClB;IACE;IACAF,IAAI,CAACG,QAAQ,KAAK,IAAI;IAAI;IAC1B;IACA,CAACH,IAAI,CAACI,kCAAkC,EACxC;MACA,OAAOL,GAAG,CAACG,IAAI,CAAC;IAClB;IAEAL,OAAO,CAACQ,KAAK,CAAC,eAAe,CAAC;IAC9BR,OAAO,CAACQ,KAAK,CAAC,qBAAqB,CAAC;IACpCR,OAAO,CAACS,OAAO,CAACJ,IAAI,CAAC;IACrBL,OAAO,CAACU,IAAI,CAAC,qBAAqB,CAAC;IACnC,OAAOC,MAAM;EACf;EACA;;EAEA,SAASA,MAAM,CAACN,IAAI,EAAE;IACpB;IACA;IACA,IAAIZ,yBAAyB,CAACY,IAAI,CAAC,EAAE;MACnCL,OAAO,CAACQ,KAAK,CAAC,6BAA6B,CAAC;MAC5CR,OAAO,CAACS,OAAO,CAACJ,IAAI,CAAC;MACrBL,OAAO,CAACU,IAAI,CAAC,6BAA6B,CAAC;MAC3C,OAAOE,KAAK;IACd;IAEA,IAAIP,IAAI,KAAK,EAAE,IAAIA,IAAI,KAAK,GAAG,EAAE;MAC/BL,OAAO,CAACQ,KAAK,CAAC,2BAA2B,CAAC;MAC1CR,OAAO,CAACS,OAAO,CAACJ,IAAI,CAAC;MACrBL,OAAO,CAACU,IAAI,CAAC,2BAA2B,CAAC;MACzC,OAAOE,KAAK;IACd;IAEA,OAAOV,GAAG,CAACG,IAAI,CAAC;EAClB;EACA;;EAEA,SAASO,KAAK,CAACP,IAAI,EAAE;IACnB,IAAIA,IAAI,KAAK,EAAE,EAAE;MACfL,OAAO,CAACQ,KAAK,CAAC,qBAAqB,CAAC;MACpCR,OAAO,CAACS,OAAO,CAACJ,IAAI,CAAC;MACrBL,OAAO,CAACU,IAAI,CAAC,qBAAqB,CAAC;MACnCV,OAAO,CAACU,IAAI,CAAC,eAAe,CAAC;MAC7B,OAAOV,OAAO,CAACa,KAAK,CAClB;QACEjB,QAAQ,EAAEkB;MACZ,CAAC,EACDb,EAAE,EACFC,GAAG,CACJ;IACH;IAEA,OAAOA,GAAG,CAACG,IAAI,CAAC;EAClB;AACF;AACA;;AAEA,SAASS,iBAAiB,CAACd,OAAO,EAAEC,EAAE,EAAEC,GAAG,EAAE;EAC3C,IAAMC,IAAI,GAAG,IAAI;EACjB,OAAOX,YAAY,CAACQ,OAAO,EAAEe,KAAK,EAAE,YAAY,CAAC;EACjD;;EAEA,SAASA,KAAK,CAACV,IAAI,EAAE;IACnB,IAAMW,IAAI,GAAGb,IAAI,CAACc,MAAM,CAACd,IAAI,CAACc,MAAM,CAACC,MAAM,GAAG,CAAC,CAAC;IAChD;MACE;MACA,CAAEF,IAAI,IAAIA,IAAI,CAAC,CAAC,CAAC,CAACG,IAAI,KAAK,YAAY;MAAK;MAC1C;MACA;MACAzB,kBAAkB,CAACW,IAAI,CAAC,KACxBA,IAAI,KAAK,IAAI,GACXJ,EAAE,CAACI,IAAI,CAAC,GACRH,GAAG,CAACG,IAAI;IAAC;EAEjB;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}
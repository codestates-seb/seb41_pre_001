{"ast":null,"code":"/*\n    cycle.js\n    2013-02-19\n\n    Public Domain.\n\n    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n\n    This code should be minified before deployment.\n    See http://javascript.crockford.com/jsmin.html\n\n    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO\n    NOT CONTROL.\n*/\n\n/*jslint evil: true, regexp: true */\n\n/*members $ref, apply, call, decycle, hasOwnProperty, length, prototype, push,\n    retrocycle, stringify, test, toString\n*/\n\nvar cycle = exports;\ncycle.decycle = function decycle(object) {\n  'use strict';\n\n  // Make a deep copy of an object or array, assuring that there is at most\n  // one instance of each object or array in the resulting structure. The\n  // duplicate references (which might be forming cycles) are replaced with\n  // an object of the form\n  //      {$ref: PATH}\n  // where the PATH is a JSONPath string that locates the first occurance.\n  // So,\n  //      var a = [];\n  //      a[0] = a;\n  //      return JSON.stringify(JSON.decycle(a));\n  // produces the string '[{\"$ref\":\"$\"}]'.\n\n  // JSONPath is used to locate the unique object. $ indicates the top level of\n  // the object or array. [NUMBER] or [STRING] indicates a child member or\n  // property.\n  var objects = [],\n    // Keep a reference to each unique object or array\n    paths = []; // Keep the path to each unique object or array\n\n  return function derez(value, path) {\n    // The derez recurses through the object, producing the deep copy.\n\n    var i,\n      // The loop counter\n      name,\n      // Property name\n      nu; // The new object or array\n\n    // typeof null === 'object', so go on if this value is really an object but not\n    // one of the weird builtin objects.\n\n    if (typeof value === 'object' && value !== null && !(value instanceof Boolean) && !(value instanceof Date) && !(value instanceof Number) && !(value instanceof RegExp) && !(value instanceof String)) {\n      // If the value is an object or array, look to see if we have already\n      // encountered it. If so, return a $ref/path object. This is a hard way,\n      // linear search that will get slower as the number of unique objects grows.\n\n      for (i = 0; i < objects.length; i += 1) {\n        if (objects[i] === value) {\n          return {\n            $ref: paths[i]\n          };\n        }\n      }\n\n      // Otherwise, accumulate the unique value and its path.\n\n      objects.push(value);\n      paths.push(path);\n\n      // If it is an array, replicate the array.\n\n      if (Object.prototype.toString.apply(value) === '[object Array]') {\n        nu = [];\n        for (i = 0; i < value.length; i += 1) {\n          nu[i] = derez(value[i], path + '[' + i + ']');\n        }\n      } else {\n        // If it is an object, replicate the object.\n\n        nu = {};\n        for (name in value) {\n          if (Object.prototype.hasOwnProperty.call(value, name)) {\n            nu[name] = derez(value[name], path + '[' + JSON.stringify(name) + ']');\n          }\n        }\n      }\n      return nu;\n    }\n    return value;\n  }(object, '$');\n};\ncycle.retrocycle = function retrocycle($) {\n  'use strict';\n\n  // Restore an object that was reduced by decycle. Members whose values are\n  // objects of the form\n  //      {$ref: PATH}\n  // are replaced with references to the value found by the PATH. This will\n  // restore cycles. The object will be mutated.\n\n  // The eval function is used to locate the values described by a PATH. The\n  // root object is kept in a $ variable. A regular expression is used to\n  // assure that the PATH is extremely well formed. The regexp contains nested\n  // * quantifiers. That has been known to have extremely bad performance\n  // problems on some browsers for very long strings. A PATH is expected to be\n  // reasonably short. A PATH is allowed to belong to a very restricted subset of\n  // Goessner's JSONPath.\n\n  // So,\n  //      var s = '[{\"$ref\":\"$\"}]';\n  //      return JSON.retrocycle(JSON.parse(s));\n  // produces an array containing a single element which is the array itself.\n  var px = /^\\$(?:\\[(?:\\d+|\\\"(?:[^\\\\\\\"\\u0000-\\u001f]|\\\\([\\\\\\\"\\/bfnrt]|u[0-9a-zA-Z]{4}))*\\\")\\])*$/;\n  (function rez(value) {\n    // The rez function walks recursively through the object looking for $ref\n    // properties. When it finds one that has a value that is a path, then it\n    // replaces the $ref object with a reference to the value that is found by\n    // the path.\n\n    var i, item, name, path;\n    if (value && typeof value === 'object') {\n      if (Object.prototype.toString.apply(value) === '[object Array]') {\n        for (i = 0; i < value.length; i += 1) {\n          item = value[i];\n          if (item && typeof item === 'object') {\n            path = item.$ref;\n            if (typeof path === 'string' && px.test(path)) {\n              value[i] = eval(path);\n            } else {\n              rez(item);\n            }\n          }\n        }\n      } else {\n        for (name in value) {\n          if (typeof value[name] === 'object') {\n            item = value[name];\n            if (item) {\n              path = item.$ref;\n              if (typeof path === 'string' && px.test(path)) {\n                value[name] = eval(path);\n              } else {\n                rez(item);\n              }\n            }\n          }\n        }\n      }\n    }\n  })($);\n  return $;\n};","map":{"version":3,"names":["cycle","exports","decycle","object","objects","paths","derez","value","path","i","name","nu","Boolean","Date","Number","RegExp","String","length","$ref","push","Object","prototype","toString","apply","hasOwnProperty","call","JSON","stringify","retrocycle","$","px","rez","item","test","eval"],"sources":["/home/kty/workspace/seb41_pre_001/client/node_modules/cycle/cycle.js"],"sourcesContent":["/*\n    cycle.js\n    2013-02-19\n\n    Public Domain.\n\n    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n\n    This code should be minified before deployment.\n    See http://javascript.crockford.com/jsmin.html\n\n    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO\n    NOT CONTROL.\n*/\n\n/*jslint evil: true, regexp: true */\n\n/*members $ref, apply, call, decycle, hasOwnProperty, length, prototype, push,\n    retrocycle, stringify, test, toString\n*/\n\nvar cycle = exports;\n\ncycle.decycle = function decycle(object) {\n    'use strict';\n\n// Make a deep copy of an object or array, assuring that there is at most\n// one instance of each object or array in the resulting structure. The\n// duplicate references (which might be forming cycles) are replaced with\n// an object of the form\n//      {$ref: PATH}\n// where the PATH is a JSONPath string that locates the first occurance.\n// So,\n//      var a = [];\n//      a[0] = a;\n//      return JSON.stringify(JSON.decycle(a));\n// produces the string '[{\"$ref\":\"$\"}]'.\n\n// JSONPath is used to locate the unique object. $ indicates the top level of\n// the object or array. [NUMBER] or [STRING] indicates a child member or\n// property.\n\n    var objects = [],   // Keep a reference to each unique object or array\n        paths = [];     // Keep the path to each unique object or array\n\n    return (function derez(value, path) {\n\n// The derez recurses through the object, producing the deep copy.\n\n        var i,          // The loop counter\n            name,       // Property name\n            nu;         // The new object or array\n\n// typeof null === 'object', so go on if this value is really an object but not\n// one of the weird builtin objects.\n\n        if (typeof value === 'object' && value !== null &&\n                !(value instanceof Boolean) &&\n                !(value instanceof Date)    &&\n                !(value instanceof Number)  &&\n                !(value instanceof RegExp)  &&\n                !(value instanceof String)) {\n\n// If the value is an object or array, look to see if we have already\n// encountered it. If so, return a $ref/path object. This is a hard way,\n// linear search that will get slower as the number of unique objects grows.\n\n            for (i = 0; i < objects.length; i += 1) {\n                if (objects[i] === value) {\n                    return {$ref: paths[i]};\n                }\n            }\n\n// Otherwise, accumulate the unique value and its path.\n\n            objects.push(value);\n            paths.push(path);\n\n// If it is an array, replicate the array.\n\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n                nu = [];\n                for (i = 0; i < value.length; i += 1) {\n                    nu[i] = derez(value[i], path + '[' + i + ']');\n                }\n            } else {\n\n// If it is an object, replicate the object.\n\n                nu = {};\n                for (name in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, name)) {\n                        nu[name] = derez(value[name],\n                            path + '[' + JSON.stringify(name) + ']');\n                    }\n                }\n            }\n            return nu;\n        }\n        return value;\n    }(object, '$'));\n};\n\n\ncycle.retrocycle = function retrocycle($) {\n    'use strict';\n\n// Restore an object that was reduced by decycle. Members whose values are\n// objects of the form\n//      {$ref: PATH}\n// are replaced with references to the value found by the PATH. This will\n// restore cycles. The object will be mutated.\n\n// The eval function is used to locate the values described by a PATH. The\n// root object is kept in a $ variable. A regular expression is used to\n// assure that the PATH is extremely well formed. The regexp contains nested\n// * quantifiers. That has been known to have extremely bad performance\n// problems on some browsers for very long strings. A PATH is expected to be\n// reasonably short. A PATH is allowed to belong to a very restricted subset of\n// Goessner's JSONPath.\n\n// So,\n//      var s = '[{\"$ref\":\"$\"}]';\n//      return JSON.retrocycle(JSON.parse(s));\n// produces an array containing a single element which is the array itself.\n\n    var px =\n        /^\\$(?:\\[(?:\\d+|\\\"(?:[^\\\\\\\"\\u0000-\\u001f]|\\\\([\\\\\\\"\\/bfnrt]|u[0-9a-zA-Z]{4}))*\\\")\\])*$/;\n\n    (function rez(value) {\n\n// The rez function walks recursively through the object looking for $ref\n// properties. When it finds one that has a value that is a path, then it\n// replaces the $ref object with a reference to the value that is found by\n// the path.\n\n        var i, item, name, path;\n\n        if (value && typeof value === 'object') {\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n                for (i = 0; i < value.length; i += 1) {\n                    item = value[i];\n                    if (item && typeof item === 'object') {\n                        path = item.$ref;\n                        if (typeof path === 'string' && px.test(path)) {\n                            value[i] = eval(path);\n                        } else {\n                            rez(item);\n                        }\n                    }\n                }\n            } else {\n                for (name in value) {\n                    if (typeof value[name] === 'object') {\n                        item = value[name];\n                        if (item) {\n                            path = item.$ref;\n                            if (typeof path === 'string' && px.test(path)) {\n                                value[name] = eval(path);\n                            } else {\n                                rez(item);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }($));\n    return $;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
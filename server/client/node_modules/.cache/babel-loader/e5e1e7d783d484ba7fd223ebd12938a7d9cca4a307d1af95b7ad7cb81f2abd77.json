{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Point} Point\n */\nimport { push, splice } from 'micromark-util-chunked';\nimport { classifyCharacter } from 'micromark-util-classify-character';\nimport { resolveAll } from 'micromark-util-resolve-all';\n\n/** @type {Construct} */\nexport var attention = {\n  name: 'attention',\n  tokenize: tokenizeAttention,\n  resolveAll: resolveAllAttention\n};\n/**\n * Take all events and resolve attention to emphasis or strong.\n *\n * @type {Resolver}\n */\n\nfunction resolveAllAttention(events, context) {\n  var index = -1;\n  /** @type {number} */\n\n  var open;\n  /** @type {Token} */\n\n  var group;\n  /** @type {Token} */\n\n  var text;\n  /** @type {Token} */\n\n  var openingSequence;\n  /** @type {Token} */\n\n  var closingSequence;\n  /** @type {number} */\n\n  var use;\n  /** @type {Event[]} */\n\n  var nextEvents;\n  /** @type {number} */\n\n  var offset; // Walk through all events.\n  //\n  // Note: performance of this is fine on an mb of normal markdown, but it’s\n  // a bottleneck for malicious stuff.\n\n  while (++index < events.length) {\n    // Find a token that can close.\n    if (events[index][0] === 'enter' && events[index][1].type === 'attentionSequence' && events[index][1]._close) {\n      open = index; // Now walk back to find an opener.\n\n      while (open--) {\n        // Find a token that can open the closer.\n        if (events[open][0] === 'exit' && events[open][1].type === 'attentionSequence' && events[open][1]._open &&\n        // If the markers are the same:\n        context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index][1]).charCodeAt(0)) {\n          // If the opening can close or the closing can open,\n          // and the close size *is not* a multiple of three,\n          // but the sum of the opening and closing size *is* multiple of three,\n          // then don’t match.\n          if ((events[open][1]._close || events[index][1]._open) && (events[index][1].end.offset - events[index][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index][1].end.offset - events[index][1].start.offset) % 3)) {\n            continue;\n          } // Number of markers to use from the sequence.\n\n          use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index][1].end.offset - events[index][1].start.offset > 1 ? 2 : 1;\n          var start = Object.assign({}, events[open][1].end);\n          var end = Object.assign({}, events[index][1].start);\n          movePoint(start, -use);\n          movePoint(end, use);\n          openingSequence = {\n            type: use > 1 ? 'strongSequence' : 'emphasisSequence',\n            start: start,\n            end: Object.assign({}, events[open][1].end)\n          };\n          closingSequence = {\n            type: use > 1 ? 'strongSequence' : 'emphasisSequence',\n            start: Object.assign({}, events[index][1].start),\n            end: end\n          };\n          text = {\n            type: use > 1 ? 'strongText' : 'emphasisText',\n            start: Object.assign({}, events[open][1].end),\n            end: Object.assign({}, events[index][1].start)\n          };\n          group = {\n            type: use > 1 ? 'strong' : 'emphasis',\n            start: Object.assign({}, openingSequence.start),\n            end: Object.assign({}, closingSequence.end)\n          };\n          events[open][1].end = Object.assign({}, openingSequence.start);\n          events[index][1].start = Object.assign({}, closingSequence.end);\n          nextEvents = []; // If there are more markers in the opening, add them before.\n\n          if (events[open][1].end.offset - events[open][1].start.offset) {\n            nextEvents = push(nextEvents, [['enter', events[open][1], context], ['exit', events[open][1], context]]);\n          } // Opening.\n\n          nextEvents = push(nextEvents, [['enter', group, context], ['enter', openingSequence, context], ['exit', openingSequence, context], ['enter', text, context]]); // Between.\n\n          nextEvents = push(nextEvents, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + 1, index), context)); // Closing.\n\n          nextEvents = push(nextEvents, [['exit', text, context], ['enter', closingSequence, context], ['exit', closingSequence, context], ['exit', group, context]]); // If there are more markers in the closing, add them after.\n\n          if (events[index][1].end.offset - events[index][1].start.offset) {\n            offset = 2;\n            nextEvents = push(nextEvents, [['enter', events[index][1], context], ['exit', events[index][1], context]]);\n          } else {\n            offset = 0;\n          }\n          splice(events, open - 1, index - open + 3, nextEvents);\n          index = open + nextEvents.length - offset - 2;\n          break;\n        }\n      }\n    }\n  } // Remove remaining sequences.\n\n  index = -1;\n  while (++index < events.length) {\n    if (events[index][1].type === 'attentionSequence') {\n      events[index][1].type = 'data';\n    }\n  }\n  return events;\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeAttention(effects, ok) {\n  var attentionMarkers = this.parser.constructs.attentionMarkers.null;\n  var previous = this.previous;\n  var before = classifyCharacter(previous);\n  /** @type {NonNullable<Code>} */\n\n  var marker;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('attentionSequence');\n    marker = code;\n    return sequence(code);\n  }\n  /** @type {State} */\n\n  function sequence(code) {\n    if (code === marker) {\n      effects.consume(code);\n      return sequence;\n    }\n    var token = effects.exit('attentionSequence');\n    var after = classifyCharacter(code);\n    var open = !after || after === 2 && before || attentionMarkers.includes(code);\n    var close = !before || before === 2 && after || attentionMarkers.includes(previous);\n    token._open = Boolean(marker === 42 ? open : open && (before || !close));\n    token._close = Boolean(marker === 42 ? close : close && (after || !open));\n    return ok(code);\n  }\n}\n/**\n * Move a point a bit.\n *\n * Note: `move` only works inside lines! It’s not possible to move past other\n * chunks (replacement characters, tabs, or line endings).\n *\n * @param {Point} point\n * @param {number} offset\n * @returns {void}\n */\n\nfunction movePoint(point, offset) {\n  point.column += offset;\n  point.offset += offset;\n  point._bufferIndex += offset;\n}","map":{"version":3,"names":["push","splice","classifyCharacter","resolveAll","attention","name","tokenize","tokenizeAttention","resolveAllAttention","events","context","index","open","group","text","openingSequence","closingSequence","use","nextEvents","offset","length","type","_close","_open","sliceSerialize","charCodeAt","end","start","Object","assign","movePoint","parser","constructs","insideSpan","null","slice","effects","ok","attentionMarkers","previous","before","marker","code","enter","sequence","consume","token","exit","after","includes","close","Boolean","point","column","_bufferIndex"],"sources":["/home/kty/workspace/seb41_pre_001/client/node_modules/micromark-core-commonmark/lib/attention.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Point} Point\n */\nimport {push, splice} from 'micromark-util-chunked'\nimport {classifyCharacter} from 'micromark-util-classify-character'\nimport {resolveAll} from 'micromark-util-resolve-all'\n\n/** @type {Construct} */\nexport const attention = {\n  name: 'attention',\n  tokenize: tokenizeAttention,\n  resolveAll: resolveAllAttention\n}\n/**\n * Take all events and resolve attention to emphasis or strong.\n *\n * @type {Resolver}\n */\n\nfunction resolveAllAttention(events, context) {\n  let index = -1\n  /** @type {number} */\n\n  let open\n  /** @type {Token} */\n\n  let group\n  /** @type {Token} */\n\n  let text\n  /** @type {Token} */\n\n  let openingSequence\n  /** @type {Token} */\n\n  let closingSequence\n  /** @type {number} */\n\n  let use\n  /** @type {Event[]} */\n\n  let nextEvents\n  /** @type {number} */\n\n  let offset // Walk through all events.\n  //\n  // Note: performance of this is fine on an mb of normal markdown, but it’s\n  // a bottleneck for malicious stuff.\n\n  while (++index < events.length) {\n    // Find a token that can close.\n    if (\n      events[index][0] === 'enter' &&\n      events[index][1].type === 'attentionSequence' &&\n      events[index][1]._close\n    ) {\n      open = index // Now walk back to find an opener.\n\n      while (open--) {\n        // Find a token that can open the closer.\n        if (\n          events[open][0] === 'exit' &&\n          events[open][1].type === 'attentionSequence' &&\n          events[open][1]._open && // If the markers are the same:\n          context.sliceSerialize(events[open][1]).charCodeAt(0) ===\n            context.sliceSerialize(events[index][1]).charCodeAt(0)\n        ) {\n          // If the opening can close or the closing can open,\n          // and the close size *is not* a multiple of three,\n          // but the sum of the opening and closing size *is* multiple of three,\n          // then don’t match.\n          if (\n            (events[open][1]._close || events[index][1]._open) &&\n            (events[index][1].end.offset - events[index][1].start.offset) % 3 &&\n            !(\n              (events[open][1].end.offset -\n                events[open][1].start.offset +\n                events[index][1].end.offset -\n                events[index][1].start.offset) %\n              3\n            )\n          ) {\n            continue\n          } // Number of markers to use from the sequence.\n\n          use =\n            events[open][1].end.offset - events[open][1].start.offset > 1 &&\n            events[index][1].end.offset - events[index][1].start.offset > 1\n              ? 2\n              : 1\n          const start = Object.assign({}, events[open][1].end)\n          const end = Object.assign({}, events[index][1].start)\n          movePoint(start, -use)\n          movePoint(end, use)\n          openingSequence = {\n            type: use > 1 ? 'strongSequence' : 'emphasisSequence',\n            start,\n            end: Object.assign({}, events[open][1].end)\n          }\n          closingSequence = {\n            type: use > 1 ? 'strongSequence' : 'emphasisSequence',\n            start: Object.assign({}, events[index][1].start),\n            end\n          }\n          text = {\n            type: use > 1 ? 'strongText' : 'emphasisText',\n            start: Object.assign({}, events[open][1].end),\n            end: Object.assign({}, events[index][1].start)\n          }\n          group = {\n            type: use > 1 ? 'strong' : 'emphasis',\n            start: Object.assign({}, openingSequence.start),\n            end: Object.assign({}, closingSequence.end)\n          }\n          events[open][1].end = Object.assign({}, openingSequence.start)\n          events[index][1].start = Object.assign({}, closingSequence.end)\n          nextEvents = [] // If there are more markers in the opening, add them before.\n\n          if (events[open][1].end.offset - events[open][1].start.offset) {\n            nextEvents = push(nextEvents, [\n              ['enter', events[open][1], context],\n              ['exit', events[open][1], context]\n            ])\n          } // Opening.\n\n          nextEvents = push(nextEvents, [\n            ['enter', group, context],\n            ['enter', openingSequence, context],\n            ['exit', openingSequence, context],\n            ['enter', text, context]\n          ]) // Between.\n\n          nextEvents = push(\n            nextEvents,\n            resolveAll(\n              context.parser.constructs.insideSpan.null,\n              events.slice(open + 1, index),\n              context\n            )\n          ) // Closing.\n\n          nextEvents = push(nextEvents, [\n            ['exit', text, context],\n            ['enter', closingSequence, context],\n            ['exit', closingSequence, context],\n            ['exit', group, context]\n          ]) // If there are more markers in the closing, add them after.\n\n          if (events[index][1].end.offset - events[index][1].start.offset) {\n            offset = 2\n            nextEvents = push(nextEvents, [\n              ['enter', events[index][1], context],\n              ['exit', events[index][1], context]\n            ])\n          } else {\n            offset = 0\n          }\n\n          splice(events, open - 1, index - open + 3, nextEvents)\n          index = open + nextEvents.length - offset - 2\n          break\n        }\n      }\n    }\n  } // Remove remaining sequences.\n\n  index = -1\n\n  while (++index < events.length) {\n    if (events[index][1].type === 'attentionSequence') {\n      events[index][1].type = 'data'\n    }\n  }\n\n  return events\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeAttention(effects, ok) {\n  const attentionMarkers = this.parser.constructs.attentionMarkers.null\n  const previous = this.previous\n  const before = classifyCharacter(previous)\n  /** @type {NonNullable<Code>} */\n\n  let marker\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('attentionSequence')\n    marker = code\n    return sequence(code)\n  }\n  /** @type {State} */\n\n  function sequence(code) {\n    if (code === marker) {\n      effects.consume(code)\n      return sequence\n    }\n\n    const token = effects.exit('attentionSequence')\n    const after = classifyCharacter(code)\n    const open =\n      !after || (after === 2 && before) || attentionMarkers.includes(code)\n    const close =\n      !before || (before === 2 && after) || attentionMarkers.includes(previous)\n    token._open = Boolean(marker === 42 ? open : open && (before || !close))\n    token._close = Boolean(marker === 42 ? close : close && (after || !open))\n    return ok(code)\n  }\n}\n/**\n * Move a point a bit.\n *\n * Note: `move` only works inside lines! It’s not possible to move past other\n * chunks (replacement characters, tabs, or line endings).\n *\n * @param {Point} point\n * @param {number} offset\n * @returns {void}\n */\n\nfunction movePoint(point, offset) {\n  point.column += offset\n  point.offset += offset\n  point._bufferIndex += offset\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
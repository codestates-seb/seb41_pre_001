{"ast":null,"code":"/**\n * @typedef {import('./types.js').SelectState} SelectState\n * @typedef {import('./types.js').HastNode} HastNode\n * @typedef {import('./types.js').ElementChild} ElementChild\n * @typedef {import('./types.js').Direction} Direction\n * @typedef {import('unist-util-visit/complex-types').Visitor<ElementChild>} Visitor\n */\n\nimport { direction } from 'direction';\nimport { isElement } from 'hast-util-is-element';\nimport { toString } from 'hast-util-to-string';\nimport { svg } from 'property-information';\nimport { visit, EXIT, SKIP } from 'unist-util-visit';\nimport { element } from './util.js';\n\n/**\n * @param {SelectState} state\n * @param {HastNode} node\n * @returns {() => void}\n */\n// eslint-disable-next-line complexity\nexport function enterState(state, node) {\n  var schema = state.schema;\n  var language = state.language;\n  var currentDirection = state.direction;\n  var editableOrEditingHost = state.editableOrEditingHost;\n  /** @type {Direction|undefined} */\n  var dirInferred;\n  /** @type {boolean|undefined} */\n  var found;\n  if (element(node) && node.properties) {\n    var lang = node.properties.xmlLang || node.properties.lang;\n    var type = node.properties.type || 'text';\n    var dir = dirProperty(node);\n    if (lang !== undefined && lang !== null) {\n      state.language = String(lang);\n      found = true;\n    }\n    if (schema && schema.space === 'html') {\n      if (node.properties.contentEditable === 'true') {\n        state.editableOrEditingHost = true;\n        found = true;\n      }\n      if (isElement(node, 'svg')) {\n        state.schema = svg;\n        found = true;\n      }\n\n      // See: <https://html.spec.whatwg.org/#the-directionality>.\n      // Explicit `[dir=rtl]`.\n      if (dir === 'rtl') {\n        dirInferred = dir;\n      } else if (\n      // Explicit `[dir=ltr]`.\n      dir === 'ltr' ||\n      // HTML with an invalid or no `[dir]`.\n      dir !== 'auto' && isElement(node, 'html') ||\n      // `input[type=tel]` with an invalid or no `[dir]`.\n      dir !== 'auto' && isElement(node, 'input') && type === 'tel') {\n        dirInferred = 'ltr';\n        // `[dir=auto]` or `bdi` with an invalid or no `[dir]`.\n      } else if (dir === 'auto' || isElement(node, 'bdi')) {\n        if (isElement(node, 'textarea')) {\n          // Check contents of `<textarea>`.\n          dirInferred = dirBidi(toString(node));\n        } else if (isElement(node, 'input') && (type === 'email' || type === 'search' || type === 'tel' || type === 'text')) {\n          // Check value of `<input>`.\n          // @ts-expect-error something is `never` in types but this is needed.\n          dirInferred = node.properties.value ?\n          // @ts-expect-error Assume string\n          dirBidi(node.properties.value) : 'ltr';\n        } else {\n          // Check text nodes in `node`.\n          visit(node, inferDirectionality);\n        }\n      }\n      if (dirInferred) {\n        state.direction = dirInferred;\n        found = true;\n      }\n    }\n    // Turn off editing mode in non-HTML spaces.\n    else if (state.editableOrEditingHost) {\n      state.editableOrEditingHost = false;\n      found = true;\n    }\n  }\n  return found ? reset : noop;\n  function reset() {\n    state.schema = schema;\n    state.language = language;\n    state.direction = currentDirection;\n    state.editableOrEditingHost = editableOrEditingHost;\n  }\n\n  /** @type {Visitor} */\n  function inferDirectionality(child) {\n    if (child.type === 'text') {\n      dirInferred = dirBidi(child.value);\n      return dirInferred ? EXIT : null;\n    }\n    if (child !== node && (isElement(child, ['bdi', 'script', 'style', 'textare']) || dirProperty(child))) {\n      return SKIP;\n    }\n  }\n}\n\n/**\n * @param {string} value\n * @returns {Direction|undefined}\n */\nfunction dirBidi(value) {\n  var result = direction(value);\n  return result === 'neutral' ? undefined : result;\n}\n\n/**\n * @param {ElementChild} node\n * @returns {Direction|undefined}\n */\nfunction dirProperty(node) {\n  var value = element(node) && node.properties && typeof node.properties.dir === 'string' ? node.properties.dir.toLowerCase() : undefined;\n  return value === 'auto' || value === 'ltr' || value === 'rtl' ? value : undefined;\n}\nfunction noop() {}","map":{"version":3,"names":["direction","isElement","toString","svg","visit","EXIT","SKIP","element","enterState","state","node","schema","language","currentDirection","editableOrEditingHost","dirInferred","found","properties","lang","xmlLang","type","dir","dirProperty","undefined","String","space","contentEditable","dirBidi","value","inferDirectionality","reset","noop","child","result","toLowerCase"],"sources":["/home/kty/workspace/seb41_pre_001/client/node_modules/hast-util-select/lib/enter-state.js"],"sourcesContent":["/**\n * @typedef {import('./types.js').SelectState} SelectState\n * @typedef {import('./types.js').HastNode} HastNode\n * @typedef {import('./types.js').ElementChild} ElementChild\n * @typedef {import('./types.js').Direction} Direction\n * @typedef {import('unist-util-visit/complex-types').Visitor<ElementChild>} Visitor\n */\n\nimport {direction} from 'direction'\nimport {isElement} from 'hast-util-is-element'\nimport {toString} from 'hast-util-to-string'\nimport {svg} from 'property-information'\nimport {visit, EXIT, SKIP} from 'unist-util-visit'\nimport {element} from './util.js'\n\n/**\n * @param {SelectState} state\n * @param {HastNode} node\n * @returns {() => void}\n */\n// eslint-disable-next-line complexity\nexport function enterState(state, node) {\n  const schema = state.schema\n  const language = state.language\n  const currentDirection = state.direction\n  const editableOrEditingHost = state.editableOrEditingHost\n  /** @type {Direction|undefined} */\n  let dirInferred\n  /** @type {boolean|undefined} */\n  let found\n\n  if (element(node) && node.properties) {\n    const lang = node.properties.xmlLang || node.properties.lang\n    const type = node.properties.type || 'text'\n    const dir = dirProperty(node)\n\n    if (lang !== undefined && lang !== null) {\n      state.language = String(lang)\n      found = true\n    }\n\n    if (schema && schema.space === 'html') {\n      if (node.properties.contentEditable === 'true') {\n        state.editableOrEditingHost = true\n        found = true\n      }\n\n      if (isElement(node, 'svg')) {\n        state.schema = svg\n        found = true\n      }\n\n      // See: <https://html.spec.whatwg.org/#the-directionality>.\n      // Explicit `[dir=rtl]`.\n      if (dir === 'rtl') {\n        dirInferred = dir\n      } else if (\n        // Explicit `[dir=ltr]`.\n        dir === 'ltr' ||\n        // HTML with an invalid or no `[dir]`.\n        (dir !== 'auto' && isElement(node, 'html')) ||\n        // `input[type=tel]` with an invalid or no `[dir]`.\n        (dir !== 'auto' && isElement(node, 'input') && type === 'tel')\n      ) {\n        dirInferred = 'ltr'\n        // `[dir=auto]` or `bdi` with an invalid or no `[dir]`.\n      } else if (dir === 'auto' || isElement(node, 'bdi')) {\n        if (isElement(node, 'textarea')) {\n          // Check contents of `<textarea>`.\n          dirInferred = dirBidi(toString(node))\n        } else if (\n          isElement(node, 'input') &&\n          (type === 'email' ||\n            type === 'search' ||\n            type === 'tel' ||\n            type === 'text')\n        ) {\n          // Check value of `<input>`.\n          // @ts-expect-error something is `never` in types but this is needed.\n          dirInferred = node.properties.value\n            ? // @ts-expect-error Assume string\n              dirBidi(node.properties.value)\n            : 'ltr'\n        } else {\n          // Check text nodes in `node`.\n          visit(node, inferDirectionality)\n        }\n      }\n\n      if (dirInferred) {\n        state.direction = dirInferred\n        found = true\n      }\n    }\n    // Turn off editing mode in non-HTML spaces.\n    else if (state.editableOrEditingHost) {\n      state.editableOrEditingHost = false\n      found = true\n    }\n  }\n\n  return found ? reset : noop\n\n  function reset() {\n    state.schema = schema\n    state.language = language\n    state.direction = currentDirection\n    state.editableOrEditingHost = editableOrEditingHost\n  }\n\n  /** @type {Visitor} */\n  function inferDirectionality(child) {\n    if (child.type === 'text') {\n      dirInferred = dirBidi(child.value)\n      return dirInferred ? EXIT : null\n    }\n\n    if (\n      child !== node &&\n      (isElement(child, ['bdi', 'script', 'style', 'textare']) ||\n        dirProperty(child))\n    ) {\n      return SKIP\n    }\n  }\n}\n\n/**\n * @param {string} value\n * @returns {Direction|undefined}\n */\nfunction dirBidi(value) {\n  const result = direction(value)\n  return result === 'neutral' ? undefined : result\n}\n\n/**\n * @param {ElementChild} node\n * @returns {Direction|undefined}\n */\nfunction dirProperty(node) {\n  const value =\n    element(node) && node.properties && typeof node.properties.dir === 'string'\n      ? node.properties.dir.toLowerCase()\n      : undefined\n\n  return value === 'auto' || value === 'ltr' || value === 'rtl'\n    ? value\n    : undefined\n}\n\nfunction noop() {}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
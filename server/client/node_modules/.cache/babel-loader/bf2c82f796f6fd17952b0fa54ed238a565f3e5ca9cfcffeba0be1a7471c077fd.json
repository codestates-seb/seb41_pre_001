{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding } from 'micromark-util-character';\n\n/** @type {Construct} */\nexport var setextUnderline = {\n  name: 'setextUnderline',\n  tokenize: tokenizeSetextUnderline,\n  resolveTo: resolveToSetextUnderline\n};\n/** @type {Resolver} */\n\nfunction resolveToSetextUnderline(events, context) {\n  var index = events.length;\n  /** @type {number|undefined} */\n\n  var content;\n  /** @type {number|undefined} */\n\n  var text;\n  /** @type {number|undefined} */\n\n  var definition; // Find the opening of the content.\n  // It’ll always exist: we don’t tokenize if it isn’t there.\n\n  while (index--) {\n    if (events[index][0] === 'enter') {\n      if (events[index][1].type === 'content') {\n        content = index;\n        break;\n      }\n      if (events[index][1].type === 'paragraph') {\n        text = index;\n      }\n    } // Exit\n    else {\n      if (events[index][1].type === 'content') {\n        // Remove the content end (if needed we’ll add it later)\n        events.splice(index, 1);\n      }\n      if (!definition && events[index][1].type === 'definition') {\n        definition = index;\n      }\n    }\n  }\n  var heading = {\n    type: 'setextHeading',\n    start: Object.assign({}, events[text][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }; // Change the paragraph to setext heading text.\n\n  events[text][1].type = 'setextHeadingText'; // If we have definitions in the content, we’ll keep on having content,\n  // but we need move it.\n\n  if (definition) {\n    events.splice(text, 0, ['enter', heading, context]);\n    events.splice(definition + 1, 0, ['exit', events[content][1], context]);\n    events[content][1].end = Object.assign({}, events[definition][1].end);\n  } else {\n    events[content][1] = heading;\n  } // Add the heading exit at the end.\n\n  events.push(['exit', heading, context]);\n  return events;\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeSetextUnderline(effects, ok, nok) {\n  var self = this;\n  var index = self.events.length;\n  /** @type {NonNullable<Code>} */\n\n  var marker;\n  /** @type {boolean} */\n\n  var paragraph; // Find an opening.\n\n  while (index--) {\n    // Skip enter/exit of line ending, line prefix, and content.\n    // We can now either have a definition or a paragraph.\n    if (self.events[index][1].type !== 'lineEnding' && self.events[index][1].type !== 'linePrefix' && self.events[index][1].type !== 'content') {\n      paragraph = self.events[index][1].type === 'paragraph';\n      break;\n    }\n  }\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if (!self.parser.lazy[self.now().line] && (self.interrupt || paragraph)) {\n      effects.enter('setextHeadingLine');\n      effects.enter('setextHeadingLineSequence');\n      marker = code;\n      return closingSequence(code);\n    }\n    return nok(code);\n  }\n  /** @type {State} */\n\n  function closingSequence(code) {\n    if (code === marker) {\n      effects.consume(code);\n      return closingSequence;\n    }\n    effects.exit('setextHeadingLineSequence');\n    return factorySpace(effects, closingSequenceEnd, 'lineSuffix')(code);\n  }\n  /** @type {State} */\n\n  function closingSequenceEnd(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('setextHeadingLine');\n      return ok(code);\n    }\n    return nok(code);\n  }\n}","map":{"version":3,"names":["factorySpace","markdownLineEnding","setextUnderline","name","tokenize","tokenizeSetextUnderline","resolveTo","resolveToSetextUnderline","events","context","index","length","content","text","definition","type","splice","heading","start","Object","assign","end","push","effects","ok","nok","self","marker","paragraph","code","parser","lazy","now","line","interrupt","enter","closingSequence","consume","exit","closingSequenceEnd"],"sources":["/home/kty/workspace/seb41_pre_001/client/node_modules/micromark-core-commonmark/lib/setext-underline.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const setextUnderline = {\n  name: 'setextUnderline',\n  tokenize: tokenizeSetextUnderline,\n  resolveTo: resolveToSetextUnderline\n}\n/** @type {Resolver} */\n\nfunction resolveToSetextUnderline(events, context) {\n  let index = events.length\n  /** @type {number|undefined} */\n\n  let content\n  /** @type {number|undefined} */\n\n  let text\n  /** @type {number|undefined} */\n\n  let definition // Find the opening of the content.\n  // It’ll always exist: we don’t tokenize if it isn’t there.\n\n  while (index--) {\n    if (events[index][0] === 'enter') {\n      if (events[index][1].type === 'content') {\n        content = index\n        break\n      }\n\n      if (events[index][1].type === 'paragraph') {\n        text = index\n      }\n    } // Exit\n    else {\n      if (events[index][1].type === 'content') {\n        // Remove the content end (if needed we’ll add it later)\n        events.splice(index, 1)\n      }\n\n      if (!definition && events[index][1].type === 'definition') {\n        definition = index\n      }\n    }\n  }\n\n  const heading = {\n    type: 'setextHeading',\n    start: Object.assign({}, events[text][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  } // Change the paragraph to setext heading text.\n\n  events[text][1].type = 'setextHeadingText' // If we have definitions in the content, we’ll keep on having content,\n  // but we need move it.\n\n  if (definition) {\n    events.splice(text, 0, ['enter', heading, context])\n    events.splice(definition + 1, 0, ['exit', events[content][1], context])\n    events[content][1].end = Object.assign({}, events[definition][1].end)\n  } else {\n    events[content][1] = heading\n  } // Add the heading exit at the end.\n\n  events.push(['exit', heading, context])\n  return events\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeSetextUnderline(effects, ok, nok) {\n  const self = this\n  let index = self.events.length\n  /** @type {NonNullable<Code>} */\n\n  let marker\n  /** @type {boolean} */\n\n  let paragraph // Find an opening.\n\n  while (index--) {\n    // Skip enter/exit of line ending, line prefix, and content.\n    // We can now either have a definition or a paragraph.\n    if (\n      self.events[index][1].type !== 'lineEnding' &&\n      self.events[index][1].type !== 'linePrefix' &&\n      self.events[index][1].type !== 'content'\n    ) {\n      paragraph = self.events[index][1].type === 'paragraph'\n      break\n    }\n  }\n\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (!self.parser.lazy[self.now().line] && (self.interrupt || paragraph)) {\n      effects.enter('setextHeadingLine')\n      effects.enter('setextHeadingLineSequence')\n      marker = code\n      return closingSequence(code)\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function closingSequence(code) {\n    if (code === marker) {\n      effects.consume(code)\n      return closingSequence\n    }\n\n    effects.exit('setextHeadingLineSequence')\n    return factorySpace(effects, closingSequenceEnd, 'lineSuffix')(code)\n  }\n  /** @type {State} */\n\n  function closingSequenceEnd(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('setextHeadingLine')\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"/*\n * prompt.js: Simple prompt for prompting information from the command line\n *\n * (C) 2010, Nodejitsu Inc.\n *\n */\n\nvar events = require('events'),\n  readline = require('readline'),\n  eachSeries = require('async/eachSeries'),\n  rejectSeries = require('async/rejectSeries'),\n  read = require('read'),\n  validate = require('revalidator').validate,\n  winston = require('winston'),\n  colors = require('@colors/colors/safe');\n\n//\n// Monkey-patch readline.Interface to work-around\n// https://github.com/joyent/node/issues/3860\n//\nreadline.Interface.prototype.setPrompt = function (prompt, length) {\n  this._prompt = prompt;\n  if (length) {\n    this._promptLength = length;\n  } else {\n    var lines = prompt.split(/[\\r\\n]/);\n    var lastLine = lines[lines.length - 1];\n    this._promptLength = lastLine.replace(/\\u001b\\[(\\d+(;\\d+)*)?m/g, '').length;\n  }\n};\n\n//\n// Expose version using `pkginfo`\n//\nmodule.exports.version = require('../package.json').version;\nvar stdin,\n  stdout,\n  history = [];\nvar prompt = module.exports = Object.create(events.EventEmitter.prototype);\nvar logger = prompt.logger = new winston.Logger({\n  transports: [new winston.transports.Console()]\n});\nprompt.started = false;\nprompt.paused = false;\nprompt.stopped = true;\nprompt.allowEmpty = false;\nprompt.message = 'prompt';\nprompt.delimiter = ': ';\nprompt.colors = true;\n\n//\n// Create an empty object for the properties\n// known to `prompt`\n//\nprompt.properties = {};\n\n//\n// Setup the default winston logger to use\n// the `cli` levels and colors.\n//\nlogger.cli();\n\n//\n// ### function start (options)\n// #### @options {Object} **Optional** Options to consume by prompt\n// Starts the prompt by listening to the appropriate events on `options.stdin`\n// and `options.stdout`. If no streams are supplied, then `process.stdin`\n// and `process.stdout` are used, respectively.\n//\nprompt.start = function (options) {\n  if (prompt.started) {\n    return;\n  }\n  options = options || {};\n  stdin = options.stdin || process.stdin;\n  stdout = options.stdout || process.stdout;\n\n  //\n  // By default: Remember the last `10` prompt property /\n  // answer pairs and don't allow empty responses globally.\n  //\n  prompt.memory = options.memory || 10;\n  prompt.allowEmpty = options.allowEmpty || false;\n  prompt.message = options.message || prompt.message;\n  prompt.delimiter = options.delimiter || prompt.delimiter;\n  prompt.colors = options.colors || prompt.colors;\n  if (!options.noHandleSIGINT) {\n    if (process.platform !== 'win32') {\n      // windows falls apart trying to deal with SIGINT\n      process.on('SIGINT', function () {\n        stdout.write('\\n');\n        process.exit(1);\n      });\n    } else {\n      // listen for the \"Ctrl+C\" key combination and trigger process event.\n      // See https://stackoverflow.com/questions/10021373/what-is-the-windows-equivalent-of-process-onsigint-in-node-js\n      stdin.on('keypress', function (char, key) {\n        if (key && key.ctrl && key.name == 'c') {\n          stdout.write('\\n');\n          process.emit(\"SIGINT\");\n          process.exit(1);\n        }\n      });\n    }\n  }\n  prompt.emit('start');\n  prompt.started = true;\n  prompt.stopped = false;\n  return prompt;\n};\n\n//\n// ### function pause ()\n// Pauses input coming in from stdin\n//\nprompt.pause = function () {\n  if (!prompt.started || prompt.stopped || prompt.paused) {\n    return;\n  }\n  stdin.pause();\n  prompt.emit('pause');\n  prompt.paused = true;\n  return prompt;\n};\n\n//\n// ### function stop ()\n// Stops input coming in from stdin\n//\nprompt.stop = function () {\n  if (prompt.stopped || !prompt.started) {\n    return;\n  }\n  stdin.destroy();\n  prompt.emit('stop');\n  prompt.stopped = true;\n  prompt.started = false;\n  prompt.paused = false;\n  return prompt;\n};\n\n//\n// ### function resume ()\n// Resumes input coming in from stdin\n//\nprompt.resume = function () {\n  if (!prompt.started || !prompt.paused) {\n    return;\n  }\n  stdin.resume();\n  prompt.emit('resume');\n  prompt.paused = false;\n  return prompt;\n};\n\n//\n// ### function history (search)\n// #### @search {Number|string} Index or property name to find.\n// Returns the `property:value` pair from within the prompts\n// `history` array.\n//\nprompt.history = function (search) {\n  if (typeof search === 'number') {\n    return history[search] || {};\n  }\n  var names = history.map(function (pair) {\n    return typeof pair.property === 'string' ? pair.property : pair.property.name;\n  });\n  if (!~names.indexOf(search)) {\n    return null;\n  }\n  return history.filter(function (pair) {\n    return typeof pair.property === 'string' ? pair.property === search : pair.property.name === search;\n  })[0];\n};\n\n//\n// ### function get (schema, callback)\n// #### @schema {Array|Object|string} Set of variables to get input for.\n// #### @callback {function} Continuation to pass control to when complete.\n// Gets input from the user via stdin for the specified message(s) `msg`.\n//\nprompt.get = function (schema, callback) {\n  if (typeof callback === 'function') return prompt._get(schema, callback);\n  return new Promise(function (resolve, reject) {\n    prompt._get(schema, function (err, result) {\n      return err ? reject(err) : resolve(result);\n    });\n  });\n};\nprompt._get = function (schema, callback) {\n  //\n  // Transforms a full JSON-schema into an array describing path and sub-schemas.\n  // Used for iteration purposes.\n  //\n  function untangle(schema, path) {\n    var results = [];\n    path = path || [];\n    if (schema.properties) {\n      //\n      // Iterate over the properties in the schema and use recursion\n      // to process sub-properties.\n      //\n      Object.keys(schema.properties).forEach(function (key) {\n        var obj = {};\n        obj[key] = schema.properties[key];\n\n        //\n        // Concat a sub-untangling to the results.\n        //\n        results = results.concat(untangle(obj[key], path.concat(key)));\n      });\n\n      // Return the results.\n      return results;\n    }\n\n    //\n    // This is a schema \"leaf\".\n    //\n    return {\n      path: path,\n      schema: schema\n    };\n  }\n\n  //\n  // Iterate over the values in the schema, represented as\n  // a legit single-property object subschemas. Accepts `schema`\n  // of the forms:\n  //\n  //    'prop-name'\n  //\n  //    ['string-name', { path: ['or-well-formed-subschema'], properties: ... }]\n  //\n  //    { path: ['or-well-formed-subschema'], properties: ... ] }\n  //\n  //    { properties: { 'schema-with-no-path' } }\n  //\n  // And transforms them all into\n  //\n  //    { path: ['path', 'to', 'property'], properties: { path: { to: ...} } }\n  //\n  function iterate(schema, get, done) {\n    var iterator = [],\n      result = {};\n    if (typeof schema === 'string') {\n      //\n      // We can iterate over a single string.\n      //\n      iterator.push({\n        path: [schema],\n        schema: prompt.properties[schema.toLowerCase()] || {}\n      });\n    } else if (Array.isArray(schema)) {\n      //\n      // An array of strings and/or single-prop schema and/or no-prop schema.\n      //\n      iterator = schema.map(function (element) {\n        if (typeof element === 'string') {\n          return {\n            path: [element],\n            schema: prompt.properties[element.toLowerCase()] || {}\n          };\n        } else if (element.properties) {\n          return {\n            path: [Object.keys(element.properties)[0]],\n            schema: element.properties[Object.keys(element.properties)[0]]\n          };\n        } else if (element.path && element.schema) {\n          return element;\n        } else {\n          return {\n            path: [element.name || 'question'],\n            schema: element\n          };\n        }\n      });\n    } else if (schema.properties) {\n      //\n      // Or a complete schema `untangle` it for use.\n      //\n      iterator = untangle(schema);\n    } else {\n      //\n      // Or a partial schema and path.\n      // TODO: Evaluate need for this option.\n      //\n      iterator = [{\n        schema: schema.schema ? schema.schema : schema,\n        path: schema.path || [schema.name || 'question']\n      }];\n    }\n\n    //\n    // Now, iterate and assemble the result.\n    //\n    eachSeries(iterator, function (branch, next) {\n      get(branch, function assembler(err, line) {\n        if (err) {\n          return next(err);\n        }\n        function build(path, line) {\n          var obj = {};\n          if (path.length) {\n            obj[path[0]] = build(path.slice(1), line);\n            return obj;\n          }\n          return line;\n        }\n        function attach(obj, attr) {\n          var keys;\n          if (typeof attr !== 'object' || attr instanceof Array) {\n            return attr;\n          }\n          keys = Object.keys(attr);\n          if (keys.length) {\n            if (!obj[keys[0]]) {\n              obj[keys[0]] = {};\n            }\n            obj[keys[0]] = attach(obj[keys[0]], attr[keys[0]]);\n          }\n          return obj;\n        }\n        result = attach(result, build(branch.path, line));\n        next();\n      });\n    }, function (err) {\n      return err ? done(err) : done(null, result);\n    });\n  }\n  iterate(schema, function get(target, next) {\n    prompt.getInput(target, function (err, line) {\n      return err ? next(err) : next(null, line);\n    });\n  }, callback);\n  return prompt;\n};\n\n//\n// ### function confirm (msg, callback)\n// #### @msg {Array|Object|string} set of message to confirm\n// #### @callback {function} Continuation to pass control to when complete.\n// Confirms a single or series of messages by prompting the user for a Y/N response.\n// Returns `true` if ALL messages are answered in the affirmative, otherwise `false`\n//\n// `msg` can be a string, or object (or array of strings/objects).\n// An object may have the following properties:\n//\n//    {\n//      description: 'yes/no' // message to prompt user\n//      pattern: /^[yntf]{1}/i // optional - regex defining acceptable responses\n//      yes: /^[yt]{1}/i // optional - regex defining `affirmative` responses\n//      message: 'yes/no' // optional - message to display for invalid responses\n//    }\n//\nprompt.confirm = function /* msg, options, callback */\n() {\n  var args = Array.prototype.slice.call(arguments),\n    msg = args.shift(),\n    callback = args.pop(),\n    opts = args.shift(),\n    vars = !Array.isArray(msg) ? [msg] : msg,\n    RX_Y = /^[yt]{1}/i,\n    RX_YN = /^[yntf]{1}/i;\n  function confirm(target, next) {\n    var yes = target.yes || RX_Y,\n      options = {\n        description: typeof target === 'string' ? target : target.description || 'yes/no',\n        pattern: target.pattern || RX_YN,\n        name: 'confirm',\n        message: target.message || 'yes/no'\n      };\n    for (var k in opts || {}) {\n      if (opts.hasOwnProperty(k)) {\n        options[k] = opts[k];\n      }\n    }\n    prompt.get([options], function (err, result) {\n      next(null, err ? false : yes.test(result[options.name]));\n    });\n  }\n  rejectSeries(vars, confirm, function (err, result) {\n    callback(null, result.length === 0);\n  });\n};\n\n// Variables needed outside of getInput for multiline arrays.\nvar tmp = [];\n\n// ### function getInput (prop, callback)\n// #### @prop {Object|string} Variable to get input for.\n// #### @callback {function} Continuation to pass control to when complete.\n// Gets input from the user via stdin for the specified message `msg`.\n//\nprompt.getInput = function (prop, callback) {\n  var schema = prop.schema || prop,\n    propName = prop.path && prop.path.join(':') || prop,\n    storedSchema = prompt.properties[propName.toLowerCase()],\n    delim = prompt.delimiter,\n    defaultLine,\n    against,\n    hidden,\n    length,\n    valid,\n    name,\n    raw,\n    msg;\n\n  //\n  // If there is a stored schema for `propName` in `propmpt.properties`\n  // then use it.\n  //\n  if (schema instanceof Object && !Object.keys(schema).length && typeof storedSchema !== 'undefined') {\n    schema = storedSchema;\n  }\n\n  //\n  // Build a proper validation schema if we just have a string\n  // and no `storedSchema`.\n  //\n  if (typeof prop === 'string' && !storedSchema) {\n    schema = {};\n  }\n  schema = convert(schema);\n  defaultLine = schema.default;\n  name = prop.description || schema.description || propName;\n  raw = prompt.colors ? [colors.grey(name), colors.grey(delim)] : [name, delim];\n  if (prompt.message) raw.unshift(prompt.message, delim);\n  prop = {\n    schema: schema,\n    path: propName.split(':')\n  };\n\n  //\n  // If the schema has no `properties` value then set\n  // it to an object containing the current schema\n  // for `propName`.\n  //\n  if (!schema.properties) {\n    schema = function () {\n      var obj = {\n        properties: {}\n      };\n      obj.properties[propName] = schema;\n      return obj;\n    }();\n  }\n\n  //\n  // Handle overrides here.\n  // TODO: Make overrides nestable\n  //\n  if (prompt.override && prompt.override.hasOwnProperty(propName)) {\n    if (prompt._performValidation(name, prop, prompt.override, schema, -1, callback)) {\n      return callback(null, prompt.override[propName]);\n    }\n    delete prompt.override[propName];\n  }\n\n  //\n  // Check if we should skip this prompt\n  //\n  if (typeof prop.schema.ask === 'function' && !prop.schema.ask()) {\n    return callback(null, prop.schema.default || '');\n  }\n  var type = (schema.properties && schema.properties[propName] && schema.properties[propName].type || '').toLowerCase().trim(),\n    wait = type === 'array';\n  if (type === 'array') {\n    length = prop.schema.maxItems;\n    if (length) {\n      msg = (tmp.length + 1).toString() + '/' + length.toString();\n    } else {\n      msg = (tmp.length + 1).toString();\n    }\n    msg += delim;\n    raw.push(prompt.colors ? colors.grey(msg) : msg);\n  }\n\n  //\n  // Calculate the raw length and colorize the prompt\n  //\n  length = raw.join('').length;\n  // raw[0] = raw[0];\n  msg = raw.join('');\n  if (schema.help) {\n    schema.help.forEach(function (line) {\n      logger.help(line);\n    });\n  }\n\n  //\n  // Emit a \"prompting\" event\n  //\n  prompt.emit('prompt', prop);\n\n  //\n  // If defaultLine is a function, execute it and store it back to defaultLine\n  //\n  if (typeof defaultLine === 'function') {\n    defaultLine = defaultLine();\n  }\n\n  //\n  // If there is no default line, set it to an empty string\n  //\n  if (typeof defaultLine === 'undefined') {\n    defaultLine = '';\n  }\n\n  //\n  // set to string for readline ( will not accept Numbers )\n  //\n  defaultLine = defaultLine.toString();\n\n  //\n  // Make the actual read\n  //\n  read({\n    prompt: msg,\n    silent: prop.schema && prop.schema.hidden,\n    replace: prop.schema && prop.schema.replace,\n    default: defaultLine,\n    input: stdin,\n    output: stdout\n  }, function (err, line) {\n    if (err && wait === false) {\n      return callback(err);\n    }\n    var against = {},\n      numericInput,\n      isValid;\n    if (line !== '') {\n      if (schema.properties[propName]) {\n        var type = (schema.properties[propName].type || '').toLowerCase().trim() || undefined;\n\n        //\n        // If type is some sort of numeric create a Number object to pass to revalidator\n        //\n        if (type === 'number' || type === 'integer') {\n          line = Number(line);\n        }\n\n        //\n        // Attempt to parse input as a boolean if the schema expects a boolean\n        //\n        if (type == 'boolean') {\n          if (line.toLowerCase() === \"true\" || line.toLowerCase() === 't') {\n            line = true;\n          } else if (line.toLowerCase() === \"false\" || line.toLowerCase() === 'f') {\n            line = false;\n          }\n        }\n\n        //\n        // If the type is an array, wait for the end. Fixes #54\n        //\n        if (type == 'array') {\n          var length = prop.schema.maxItems;\n          if (err) {\n            if (err.message == 'canceled') {\n              wait = false;\n              stdout.write('\\n');\n            }\n          } else {\n            if (length) {\n              if (tmp.length + 1 < length) {\n                isValid = false;\n                wait = true;\n              } else {\n                isValid = true;\n                wait = false;\n              }\n            } else {\n              isValid = false;\n              wait = true;\n            }\n            tmp.push(line);\n          }\n          line = tmp;\n        }\n      }\n      against[propName] = line;\n    }\n    if (prop && prop.schema.before) {\n      line = prop.schema.before(line);\n    }\n\n    // Validate\n    if (isValid === undefined) isValid = prompt._performValidation(name, prop, against, schema, line, callback);\n    if (!isValid) {\n      return prompt.getInput(prop, callback);\n    }\n\n    //\n    // Log the resulting line, append this `property:value`\n    // pair to the history for `prompt` and respond to\n    // the callback.\n    //\n    logger.input(line.yellow);\n    prompt._remember(propName, line);\n    callback(null, line);\n\n    // Make sure `tmp` is emptied\n    tmp = [];\n  });\n};\n\n//\n// ### function performValidation (name, prop, against, schema, line, callback)\n// #### @name {Object} Variable name\n// #### @prop {Object|string} Variable to get input for.\n// #### @against {Object} Input\n// #### @schema {Object} Validation schema\n// #### @line {String|Boolean} Input line\n// #### @callback {function} Continuation to pass control to when complete.\n// Perfoms user input validation, print errors if needed and returns value according to validation\n//\nprompt._performValidation = function (name, prop, against, schema, line, callback) {\n  var numericInput, valid, msg;\n  try {\n    valid = validate(against, schema);\n  } catch (err) {\n    return line !== -1 ? callback(err) : false;\n  }\n  if (!valid.valid) {\n    if (prop.schema.message) {\n      logger.error(prop.schema.message);\n    } else {\n      msg = line !== -1 ? 'Invalid input for ' : 'Invalid command-line input for ';\n      if (prompt.colors) {\n        logger.error(msg + colors.grey(name));\n      } else {\n        logger.error(msg + name);\n      }\n    }\n    prompt.emit('invalid', prop, line);\n  }\n  return valid.valid;\n};\n\n//\n// ### function addProperties (obj, properties, callback)\n// #### @obj {Object} Object to add properties to\n// #### @properties {Array} List of properties to get values for\n// #### @callback {function} Continuation to pass control to when complete.\n// Prompts the user for values each of the `properties` if `obj` does not already\n// have a value for the property. Responds with the modified object.\n//\nprompt.addProperties = function (obj, properties, callback) {\n  properties = properties.filter(function (prop) {\n    return typeof obj[prop] === 'undefined';\n  });\n  if (properties.length === 0) {\n    return callback(null, obj);\n  }\n  prompt.get(properties, function (err, results) {\n    if (err) {\n      return callback(err);\n    } else if (!results) {\n      return callback(null, obj);\n    }\n    function putNested(obj, path, value) {\n      var last = obj,\n        key;\n      while (path.length > 1) {\n        key = path.shift();\n        if (!last[key]) {\n          last[key] = {};\n        }\n        last = last[key];\n      }\n      last[path.shift()] = value;\n    }\n    Object.keys(results).forEach(function (key) {\n      putNested(obj, key.split('.'), results[key]);\n    });\n    callback(null, obj);\n  });\n  return prompt;\n};\n\n//\n// ### @private function _remember (property, value)\n// #### @property {Object|string} Property that the value is in response to.\n// #### @value {string} User input captured by `prompt`.\n// Prepends the `property:value` pair into the private `history` Array\n// for `prompt` so that it can be accessed later.\n//\nprompt._remember = function (property, value) {\n  history.unshift({\n    property: property,\n    value: value\n  });\n\n  //\n  // If the length of the `history` Array\n  // has exceeded the specified length to remember,\n  // `prompt.memory`, truncate it.\n  //\n  if (history.length > prompt.memory) {\n    history.splice(prompt.memory, history.length - prompt.memory);\n  }\n};\n\n//\n// ### @private function convert (schema)\n// #### @schema {Object} Schema for a property\n// Converts the schema into new format if it is in old format\n//\nfunction convert(schema) {\n  var newProps = Object.keys(validate.messages),\n    newSchema = false,\n    key;\n  newProps = newProps.concat(['description', 'dependencies']);\n  for (key in schema) {\n    if (newProps.indexOf(key) > 0) {\n      newSchema = true;\n      break;\n    }\n  }\n  if (!newSchema || schema.validator || schema.warning || typeof schema.empty !== 'undefined') {\n    if (typeof schema.message !== 'undefined') {\n      schema.description = schema.message;\n    }\n    if (typeof schema.warning !== 'undefined') {\n      schema.message = schema.warning;\n    }\n    if (typeof schema.validator === 'function') {\n      schema.conform = schema.validator;\n    } else {\n      schema.pattern = schema.validator;\n    }\n    if (typeof schema.empty !== 'undefined') {\n      schema.required = !schema.empty;\n    }\n    delete schema.warning;\n    delete schema.validator;\n    delete schema.empty;\n  }\n  return schema;\n}","map":{"version":3,"names":["events","require","readline","eachSeries","rejectSeries","read","validate","winston","colors","Interface","prototype","setPrompt","prompt","length","_prompt","_promptLength","lines","split","lastLine","replace","module","exports","version","stdin","stdout","history","Object","create","EventEmitter","logger","Logger","transports","Console","started","paused","stopped","allowEmpty","message","delimiter","properties","cli","start","options","process","memory","noHandleSIGINT","platform","on","write","exit","char","key","ctrl","name","emit","pause","stop","destroy","resume","search","names","map","pair","property","indexOf","filter","get","schema","callback","_get","Promise","resolve","reject","err","result","untangle","path","results","keys","forEach","obj","concat","iterate","done","iterator","push","toLowerCase","Array","isArray","element","branch","next","assembler","line","build","slice","attach","attr","target","getInput","confirm","args","call","arguments","msg","shift","pop","opts","vars","RX_Y","RX_YN","yes","description","pattern","k","hasOwnProperty","test","tmp","prop","propName","join","storedSchema","delim","defaultLine","against","hidden","valid","raw","convert","default","grey","unshift","override","_performValidation","ask","type","trim","wait","maxItems","toString","help","silent","input","output","numericInput","isValid","undefined","Number","before","yellow","_remember","error","addProperties","putNested","value","last","splice","newProps","messages","newSchema","validator","warning","empty","conform","required"],"sources":["/home/kty/workspace/seb41_pre_001/client/node_modules/prompt/lib/prompt.js"],"sourcesContent":["/*\n * prompt.js: Simple prompt for prompting information from the command line\n *\n * (C) 2010, Nodejitsu Inc.\n *\n */\n\nvar events = require('events'),\n    readline = require('readline'),\n    eachSeries = require('async/eachSeries'),\n    rejectSeries = require('async/rejectSeries'),\n    read = require('read'),\n    validate = require('revalidator').validate,\n    winston = require('winston'),\n    colors = require('@colors/colors/safe');\n\n//\n// Monkey-patch readline.Interface to work-around\n// https://github.com/joyent/node/issues/3860\n//\nreadline.Interface.prototype.setPrompt = function(prompt, length) {\n  this._prompt = prompt;\n  if (length) {\n    this._promptLength = length;\n  } else {\n    var lines = prompt.split(/[\\r\\n]/);\n    var lastLine = lines[lines.length - 1];\n    this._promptLength = lastLine.replace(/\\u001b\\[(\\d+(;\\d+)*)?m/g, '').length;\n  }\n};\n\n//\n// Expose version using `pkginfo`\n//\nmodule.exports.version = require('../package.json').version;\n\nvar stdin, stdout, history = [];\nvar prompt = module.exports = Object.create(events.EventEmitter.prototype);\nvar logger = prompt.logger = new winston.Logger({\n  transports: [new (winston.transports.Console)()]\n});\n\nprompt.started    = false;\nprompt.paused     = false;\nprompt.stopped    = true;\nprompt.allowEmpty = false;\nprompt.message    = 'prompt';\nprompt.delimiter  = ': ';\nprompt.colors     = true;\n\n//\n// Create an empty object for the properties\n// known to `prompt`\n//\nprompt.properties = {};\n\n//\n// Setup the default winston logger to use\n// the `cli` levels and colors.\n//\nlogger.cli();\n\n//\n// ### function start (options)\n// #### @options {Object} **Optional** Options to consume by prompt\n// Starts the prompt by listening to the appropriate events on `options.stdin`\n// and `options.stdout`. If no streams are supplied, then `process.stdin`\n// and `process.stdout` are used, respectively.\n//\nprompt.start = function (options) {\n  if (prompt.started) {\n    return;\n  }\n\n  options = options        || {};\n  stdin   = options.stdin  || process.stdin;\n  stdout  = options.stdout || process.stdout;\n\n  //\n  // By default: Remember the last `10` prompt property /\n  // answer pairs and don't allow empty responses globally.\n  //\n  prompt.memory     = options.memory     || 10;\n  prompt.allowEmpty = options.allowEmpty || false;\n  prompt.message    = options.message    || prompt.message;\n  prompt.delimiter  = options.delimiter  || prompt.delimiter;\n  prompt.colors     = options.colors     || prompt.colors;\n\n  if (!options.noHandleSIGINT) {\n    if (process.platform !== 'win32') {\n      // windows falls apart trying to deal with SIGINT\n      process.on('SIGINT', function () {\n        stdout.write('\\n');\n        process.exit(1);\n      });\n    } else {\n      // listen for the \"Ctrl+C\" key combination and trigger process event.\n      // See https://stackoverflow.com/questions/10021373/what-is-the-windows-equivalent-of-process-onsigint-in-node-js\n      stdin.on('keypress', function(char, key) {\n        if (key && key.ctrl && key.name == 'c') {\n          stdout.write('\\n');\n          process.emit(\"SIGINT\");\n          process.exit(1);\n        }\n      });\n    }\n  }\n\n  prompt.emit('start');\n  prompt.started = true;\n  prompt.stopped = false;\n  return prompt;\n};\n\n//\n// ### function pause ()\n// Pauses input coming in from stdin\n//\nprompt.pause = function () {\n  if (!prompt.started || prompt.stopped || prompt.paused) {\n    return;\n  }\n\n  stdin.pause();\n  prompt.emit('pause');\n  prompt.paused = true;\n  return prompt;\n};\n\n//\n// ### function stop ()\n// Stops input coming in from stdin\n//\nprompt.stop = function () {\n    if (prompt.stopped || !prompt.started) {\n        return;\n    }\n\n    stdin.destroy();\n    prompt.emit('stop');\n    prompt.stopped = true;\n    prompt.started = false;\n    prompt.paused = false;\n    return prompt;\n}\n\n//\n// ### function resume ()\n// Resumes input coming in from stdin\n//\nprompt.resume = function () {\n  if (!prompt.started || !prompt.paused) {\n    return;\n  }\n\n  stdin.resume();\n  prompt.emit('resume');\n  prompt.paused = false;\n  return prompt;\n};\n\n//\n// ### function history (search)\n// #### @search {Number|string} Index or property name to find.\n// Returns the `property:value` pair from within the prompts\n// `history` array.\n//\nprompt.history = function (search) {\n  if (typeof search === 'number') {\n    return history[search] || {};\n  }\n\n  var names = history.map(function (pair) {\n    return typeof pair.property === 'string'\n      ? pair.property\n      : pair.property.name;\n  });\n\n  if (!~names.indexOf(search)) {\n    return null;\n  }\n\n  return history.filter(function (pair) {\n    return typeof pair.property === 'string'\n      ? pair.property === search\n      : pair.property.name === search;\n  })[0];\n};\n\n//\n// ### function get (schema, callback)\n// #### @schema {Array|Object|string} Set of variables to get input for.\n// #### @callback {function} Continuation to pass control to when complete.\n// Gets input from the user via stdin for the specified message(s) `msg`.\n//\nprompt.get = function (schema, callback) {\n  if (typeof callback === 'function') return prompt._get(schema, callback);\n\n  return new Promise(function (resolve, reject) {\n    prompt._get(schema, function (err, result) {\n      return err ? reject(err) : resolve(result);\n    });\n  });\n};\n\nprompt._get = function (schema, callback) {\n  //\n  // Transforms a full JSON-schema into an array describing path and sub-schemas.\n  // Used for iteration purposes.\n  //\n  function untangle(schema, path) {\n    var results = [];\n    path = path || [];\n\n    if (schema.properties) {\n      //\n      // Iterate over the properties in the schema and use recursion\n      // to process sub-properties.\n      //\n      Object.keys(schema.properties).forEach(function (key) {\n        var obj = {};\n        obj[key] = schema.properties[key];\n\n        //\n        // Concat a sub-untangling to the results.\n        //\n        results = results.concat(untangle(obj[key], path.concat(key)));\n      });\n\n      // Return the results.\n      return results;\n    }\n\n    //\n    // This is a schema \"leaf\".\n    //\n    return {\n      path: path,\n      schema: schema\n    };\n  }\n\n  //\n  // Iterate over the values in the schema, represented as\n  // a legit single-property object subschemas. Accepts `schema`\n  // of the forms:\n  //\n  //    'prop-name'\n  //\n  //    ['string-name', { path: ['or-well-formed-subschema'], properties: ... }]\n  //\n  //    { path: ['or-well-formed-subschema'], properties: ... ] }\n  //\n  //    { properties: { 'schema-with-no-path' } }\n  //\n  // And transforms them all into\n  //\n  //    { path: ['path', 'to', 'property'], properties: { path: { to: ...} } }\n  //\n  function iterate(schema, get, done) {\n    var iterator = [],\n        result = {};\n\n    if (typeof schema === 'string') {\n      //\n      // We can iterate over a single string.\n      //\n      iterator.push({\n        path: [schema],\n        schema: prompt.properties[schema.toLowerCase()] || {}\n      });\n    }\n    else if (Array.isArray(schema)) {\n      //\n      // An array of strings and/or single-prop schema and/or no-prop schema.\n      //\n      iterator = schema.map(function (element) {\n        if (typeof element === 'string') {\n          return {\n            path: [element],\n            schema: prompt.properties[element.toLowerCase()] || {}\n          };\n        }\n        else if (element.properties) {\n          return {\n            path: [Object.keys(element.properties)[0]],\n            schema: element.properties[Object.keys(element.properties)[0]]\n          };\n        }\n        else if (element.path && element.schema) {\n          return element;\n        }\n        else {\n          return {\n            path: [element.name || 'question'],\n            schema: element\n          };\n        }\n      });\n    }\n    else if (schema.properties) {\n      //\n      // Or a complete schema `untangle` it for use.\n      //\n      iterator = untangle(schema);\n    }\n    else {\n      //\n      // Or a partial schema and path.\n      // TODO: Evaluate need for this option.\n      //\n      iterator = [{\n        schema: schema.schema ? schema.schema : schema,\n        path: schema.path || [schema.name || 'question']\n      }];\n    }\n\n    //\n    // Now, iterate and assemble the result.\n    //\n    eachSeries(iterator, function (branch, next) {\n      get(branch, function assembler(err, line) {\n        if (err) {\n          return next(err);\n        }\n\n        function build(path, line) {\n          var obj = {};\n          if (path.length) {\n            obj[path[0]] = build(path.slice(1), line);\n            return obj;\n          }\n\n          return line;\n        }\n\n        function attach(obj, attr) {\n          var keys;\n          if (typeof attr !== 'object' || attr instanceof Array) {\n            return attr;\n          }\n\n          keys = Object.keys(attr);\n          if (keys.length) {\n            if (!obj[keys[0]]) {\n              obj[keys[0]] = {};\n            }\n            obj[keys[0]] = attach(obj[keys[0]], attr[keys[0]]);\n          }\n\n          return obj;\n        }\n\n        result = attach(result, build(branch.path, line));\n        next();\n      });\n    }, function (err) {\n      return err ? done(err) : done(null, result);\n    });\n  }\n\n  iterate(schema, function get(target, next) {\n    prompt.getInput(target, function (err, line) {\n      return err ? next(err) : next(null, line);\n    });\n  }, callback);\n\n  return prompt;\n};\n\n//\n// ### function confirm (msg, callback)\n// #### @msg {Array|Object|string} set of message to confirm\n// #### @callback {function} Continuation to pass control to when complete.\n// Confirms a single or series of messages by prompting the user for a Y/N response.\n// Returns `true` if ALL messages are answered in the affirmative, otherwise `false`\n//\n// `msg` can be a string, or object (or array of strings/objects).\n// An object may have the following properties:\n//\n//    {\n//      description: 'yes/no' // message to prompt user\n//      pattern: /^[yntf]{1}/i // optional - regex defining acceptable responses\n//      yes: /^[yt]{1}/i // optional - regex defining `affirmative` responses\n//      message: 'yes/no' // optional - message to display for invalid responses\n//    }\n//\nprompt.confirm = function (/* msg, options, callback */) {\n  var args     = Array.prototype.slice.call(arguments),\n      msg      = args.shift(),\n      callback = args.pop(),\n      opts     = args.shift(),\n      vars     = !Array.isArray(msg) ? [msg] : msg,\n      RX_Y     = /^[yt]{1}/i,\n      RX_YN    = /^[yntf]{1}/i;\n\n  function confirm(target, next) {\n    var yes = target.yes || RX_Y,\n      options = {\n        description: typeof target === 'string' ? target : target.description || 'yes/no',\n        pattern: target.pattern || RX_YN,\n        name: 'confirm',\n        message: target.message || 'yes/no'\n      };\n\n    for (var k in (opts || {})) {\n      if (opts.hasOwnProperty(k)) {\n        options[k] = opts[k];\n      }\n    }\n\n    prompt.get([options], function (err, result) {\n      next(null, err ? false : yes.test(result[options.name]));\n    });\n  }\n\n  rejectSeries(vars, confirm, function(err, result) {\n    callback(null, result.length===0);\n  });\n};\n\n\n// Variables needed outside of getInput for multiline arrays.\nvar tmp = [];\n\n\n// ### function getInput (prop, callback)\n// #### @prop {Object|string} Variable to get input for.\n// #### @callback {function} Continuation to pass control to when complete.\n// Gets input from the user via stdin for the specified message `msg`.\n//\nprompt.getInput = function (prop, callback) {\n  var schema = prop.schema || prop,\n      propName = prop.path && prop.path.join(':') || prop,\n      storedSchema = prompt.properties[propName.toLowerCase()],\n      delim = prompt.delimiter,\n      defaultLine,\n      against,\n      hidden,\n      length,\n      valid,\n      name,\n      raw,\n      msg;\n\n  //\n  // If there is a stored schema for `propName` in `propmpt.properties`\n  // then use it.\n  //\n  if (schema instanceof Object && !Object.keys(schema).length &&\n    typeof storedSchema !== 'undefined') {\n    schema = storedSchema;\n  }\n\n  //\n  // Build a proper validation schema if we just have a string\n  // and no `storedSchema`.\n  //\n  if (typeof prop === 'string' && !storedSchema) {\n    schema = {};\n  }\n\n  schema = convert(schema);\n  defaultLine = schema.default;\n  name = prop.description || schema.description || propName;\n  raw = prompt.colors\n    ? [colors.grey(name), colors.grey(delim)]\n    : [name, delim];\n\n  if (prompt.message)\n    raw.unshift(prompt.message, delim);\n\n  prop = {\n    schema: schema,\n    path: propName.split(':')\n  };\n\n  //\n  // If the schema has no `properties` value then set\n  // it to an object containing the current schema\n  // for `propName`.\n  //\n  if (!schema.properties) {\n    schema = (function () {\n      var obj = { properties: {} };\n      obj.properties[propName] = schema;\n      return obj;\n    })();\n  }\n\n  //\n  // Handle overrides here.\n  // TODO: Make overrides nestable\n  //\n  if (prompt.override && prompt.override.hasOwnProperty(propName)) {\n    if (prompt._performValidation(name, prop, prompt.override, schema, -1, callback)) {\n      return callback(null, prompt.override[propName]);\n    }\n\n    delete prompt.override[propName];\n  }\n\n  //\n  // Check if we should skip this prompt\n  //\n  if (typeof prop.schema.ask === 'function' &&\n    !prop.schema.ask()) {\n    return callback(null, prop.schema.default || '');\n  }\n\n  var type = (schema.properties && schema.properties[propName] &&\n              schema.properties[propName].type || '').toLowerCase().trim(),\n      wait = type === 'array';\n\n  if (type === 'array') {\n    length = prop.schema.maxItems;\n    if (length) {\n      msg = (tmp.length + 1).toString() + '/' + length.toString();\n    }\n    else {\n      msg = (tmp.length + 1).toString();\n    }\n    msg += delim;\n    raw.push(prompt.colors ? colors.grey(msg) : msg);\n  }\n\n  //\n  // Calculate the raw length and colorize the prompt\n  //\n  length = raw.join('').length;\n  // raw[0] = raw[0];\n  msg = raw.join('');\n\n  if (schema.help) {\n    schema.help.forEach(function (line) {\n      logger.help(line);\n    });\n  }\n\n  //\n  // Emit a \"prompting\" event\n  //\n  prompt.emit('prompt', prop);\n\n  //\n  // If defaultLine is a function, execute it and store it back to defaultLine\n  //\n  if(typeof defaultLine === 'function') {\n    defaultLine = defaultLine();\n  }\n\n  //\n  // If there is no default line, set it to an empty string\n  //\n  if(typeof defaultLine === 'undefined') {\n    defaultLine = '';\n  }\n\n  //\n  // set to string for readline ( will not accept Numbers )\n  //\n  defaultLine = defaultLine.toString();\n\n  //\n  // Make the actual read\n  //\n  read({\n    prompt: msg,\n    silent: prop.schema && prop.schema.hidden,\n    replace: prop.schema && prop.schema.replace,\n    default: defaultLine,\n    input: stdin,\n    output: stdout\n  }, function (err, line) {\n    if (err && wait === false) {\n      return callback(err);\n    }\n\n    var against = {},\n        numericInput,\n        isValid;\n\n    if (line !== '') {\n\n      if (schema.properties[propName]) {\n        var type = (schema.properties[propName].type || '').toLowerCase().trim() || undefined;\n\n        //\n        // If type is some sort of numeric create a Number object to pass to revalidator\n        //\n        if (type === 'number' || type === 'integer') {\n          line = Number(line);\n        }\n\n        //\n        // Attempt to parse input as a boolean if the schema expects a boolean\n        //\n        if (type == 'boolean') {\n          if(line.toLowerCase() === \"true\" || line.toLowerCase() === 't') {\n            line = true;\n          } else if(line.toLowerCase() === \"false\" || line.toLowerCase() === 'f') {\n            line = false;\n          }\n        }\n\n        //\n        // If the type is an array, wait for the end. Fixes #54\n        //\n        if (type == 'array') {\n          var length = prop.schema.maxItems;\n          if (err) {\n            if (err.message == 'canceled') {\n              wait = false;\n              stdout.write('\\n');\n            }\n          }\n          else {\n            if (length) {\n              if (tmp.length + 1 < length) {\n                isValid = false;\n                wait = true;\n              }\n              else {\n                isValid = true;\n                wait = false;\n              }\n            }\n            else {\n              isValid = false;\n              wait = true;\n            }\n            tmp.push(line);\n          }\n          line = tmp;\n        }\n      }\n\n      against[propName] = line;\n    }\n\n    if (prop && prop.schema.before) {\n      line = prop.schema.before(line);\n    }\n\n    // Validate\n    if (isValid === undefined) isValid = prompt._performValidation(name, prop, against, schema, line, callback);\n\n    if (!isValid) {\n      return prompt.getInput(prop, callback);\n    }\n\n    //\n    // Log the resulting line, append this `property:value`\n    // pair to the history for `prompt` and respond to\n    // the callback.\n    //\n    logger.input(line.yellow);\n    prompt._remember(propName, line);\n    callback(null, line);\n\n    // Make sure `tmp` is emptied\n    tmp = [];\n  });\n};\n\n//\n// ### function performValidation (name, prop, against, schema, line, callback)\n// #### @name {Object} Variable name\n// #### @prop {Object|string} Variable to get input for.\n// #### @against {Object} Input\n// #### @schema {Object} Validation schema\n// #### @line {String|Boolean} Input line\n// #### @callback {function} Continuation to pass control to when complete.\n// Perfoms user input validation, print errors if needed and returns value according to validation\n//\nprompt._performValidation = function (name, prop, against, schema, line, callback) {\n  var numericInput, valid, msg;\n  try {\n    valid = validate(against, schema);\n  }\n  catch (err) {\n    return (line !== -1) ? callback(err) : false;\n  }\n\n  if (!valid.valid) {\n    if (prop.schema.message) {\n      logger.error(prop.schema.message);\n    } else {\n      msg = line !== -1 ? 'Invalid input for ' : 'Invalid command-line input for ';\n\n      if (prompt.colors) {\n        logger.error(msg + colors.grey(name));\n      }\n      else {\n        logger.error(msg + name);\n      }\n    }\n\n    prompt.emit('invalid', prop, line);\n  }\n\n  return valid.valid;\n};\n\n//\n// ### function addProperties (obj, properties, callback)\n// #### @obj {Object} Object to add properties to\n// #### @properties {Array} List of properties to get values for\n// #### @callback {function} Continuation to pass control to when complete.\n// Prompts the user for values each of the `properties` if `obj` does not already\n// have a value for the property. Responds with the modified object.\n//\nprompt.addProperties = function (obj, properties, callback) {\n  properties = properties.filter(function (prop) {\n    return typeof obj[prop] === 'undefined';\n  });\n\n  if (properties.length === 0) {\n    return callback(null, obj);\n  }\n\n  prompt.get(properties, function (err, results) {\n    if (err) {\n      return callback(err);\n    }\n    else if (!results) {\n      return callback(null, obj);\n    }\n\n    function putNested (obj, path, value) {\n      var last = obj, key;\n\n      while (path.length > 1) {\n        key = path.shift();\n        if (!last[key]) {\n          last[key] = {};\n        }\n\n        last = last[key];\n      }\n\n      last[path.shift()] = value;\n    }\n\n    Object.keys(results).forEach(function (key) {\n      putNested(obj, key.split('.'), results[key]);\n    });\n\n    callback(null, obj);\n  });\n\n  return prompt;\n};\n\n//\n// ### @private function _remember (property, value)\n// #### @property {Object|string} Property that the value is in response to.\n// #### @value {string} User input captured by `prompt`.\n// Prepends the `property:value` pair into the private `history` Array\n// for `prompt` so that it can be accessed later.\n//\nprompt._remember = function (property, value) {\n  history.unshift({\n    property: property,\n    value: value\n  });\n\n  //\n  // If the length of the `history` Array\n  // has exceeded the specified length to remember,\n  // `prompt.memory`, truncate it.\n  //\n  if (history.length > prompt.memory) {\n    history.splice(prompt.memory, history.length - prompt.memory);\n  }\n};\n\n//\n// ### @private function convert (schema)\n// #### @schema {Object} Schema for a property\n// Converts the schema into new format if it is in old format\n//\nfunction convert(schema) {\n  var newProps = Object.keys(validate.messages),\n      newSchema = false,\n      key;\n\n  newProps = newProps.concat(['description', 'dependencies']);\n\n  for (key in schema) {\n    if (newProps.indexOf(key) > 0) {\n      newSchema = true;\n      break;\n    }\n  }\n\n  if (!newSchema || schema.validator || schema.warning || typeof schema.empty !== 'undefined') {\n    if(typeof schema.message !== 'undefined'){\n      schema.description = schema.message;\n    }\n\n    if(typeof schema.warning !== 'undefined'){\n      schema.message = schema.warning;\n    }\n\n    if (typeof schema.validator === 'function') {\n      schema.conform = schema.validator;\n    } else {\n      schema.pattern = schema.validator;\n    }\n\n    if (typeof schema.empty !== 'undefined') {\n      schema.required = !(schema.empty);\n    }\n\n    delete schema.warning;\n    delete schema.validator;\n    delete schema.empty;\n  }\n\n  return schema;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
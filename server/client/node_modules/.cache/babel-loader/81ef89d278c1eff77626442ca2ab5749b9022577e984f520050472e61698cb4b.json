{"ast":null,"code":"/*\r\n * file.js: Transport for outputting to a local log file\r\n *\r\n * (C) 2010 Charlie Robbins\r\n * MIT LICENCE\r\n *\r\n */\n\nvar events = require('events'),\n  fs = require('fs'),\n  path = require('path'),\n  util = require('util'),\n  async = require('async'),\n  zlib = require('zlib'),\n  common = require('../common'),\n  Transport = require('./transport').Transport,\n  isWritable = require('isstream').isWritable,\n  Stream = require('stream').Stream,\n  os = require('os');\n\n//\n// ### function File (options)\n// #### @options {Object} Options for this instance.\n// Constructor function for the File transport object responsible\n// for persisting log messages and metadata to one or more files.\n//\nvar File = exports.File = function (options) {\n  var self = this;\n  Transport.call(this, options);\n\n  //\n  // Helper function which throws an `Error` in the event\n  // that any of the rest of the arguments is present in `options`.\n  //\n  function throwIf(target /*, illegal... */) {\n    Array.prototype.slice.call(arguments, 1).forEach(function (name) {\n      if (options[name]) {\n        throw new Error('Cannot set ' + name + ' and ' + target + 'together');\n      }\n    });\n  }\n  if (options.filename || options.dirname) {\n    throwIf('filename or dirname', 'stream');\n    this._basename = this.filename = options.filename ? path.basename(options.filename) : 'winston.log';\n    this.dirname = options.dirname || path.dirname(options.filename);\n    this.options = options.options || {\n      flags: 'a'\n    };\n\n    //\n    // \"24 bytes\" is maybe a good value for logging lines.\n    //\n    this.options.highWaterMark = this.options.highWaterMark || 24;\n  } else if (options.stream) {\n    throwIf('stream', 'filename', 'maxsize');\n    this._stream = options.stream;\n    this._isStreams2 = isWritable(this._stream);\n    this._stream.on('error', function (error) {\n      self.emit('error', error);\n    });\n    //\n    // We need to listen for drain events when\n    // write() returns false. This can make node\n    // mad at times.\n    //\n    this._stream.setMaxListeners(Infinity);\n  } else {\n    throw new Error('Cannot log to file without filename or stream.');\n  }\n  this.json = options.json !== false;\n  this.logstash = options.logstash || false;\n  this.colorize = options.colorize || false;\n  this.maxsize = options.maxsize || null;\n  this.rotationFormat = options.rotationFormat || false;\n  this.zippedArchive = options.zippedArchive || false;\n  this.maxFiles = options.maxFiles || null;\n  this.prettyPrint = options.prettyPrint || false;\n  this.label = options.label || null;\n  this.timestamp = options.timestamp != null ? options.timestamp : true;\n  this.eol = options.eol || os.EOL;\n  this.tailable = options.tailable || false;\n  this.depth = options.depth || null;\n  this.showLevel = options.showLevel === undefined ? true : options.showLevel;\n  this.maxRetries = options.maxRetries || 2;\n  if (this.json) {\n    this.stringify = options.stringify;\n  }\n\n  //\n  // Internal state variables representing the number\n  // of files this instance has created and the current\n  // size (in bytes) of the current logfile.\n  //\n  this._size = 0;\n  this._created = 0;\n  this._buffer = [];\n  this._draining = false;\n  this._opening = false;\n  this._failures = 0;\n  this._archive = null;\n};\n\n//\n// Inherit from `winston.Transport`.\n//\nutil.inherits(File, Transport);\n\n//\n// Expose the name of this Transport on the prototype\n//\nFile.prototype.name = 'file';\n\n//\n// ### function log (level, msg, [meta], callback)\n// #### @level {string} Level at which to log the message.\n// #### @msg {string} Message to log\n// #### @meta {Object} **Optional** Additional metadata to attach\n// #### @callback {function} Continuation to respond to when complete.\n// Core logging method exposed to Winston. Metadata is optional.\n//\nFile.prototype.log = function (level, msg, meta, callback) {\n  if (this.silent) {\n    return callback(null, true);\n  }\n\n  //\n  // If failures exceeds maxRetries then we can't access the\n  // stream. In this case we need to perform a noop and return\n  // an error.\n  //\n  if (this._failures >= this.maxRetries) {\n    return callback(new Error('Transport is in a failed state.'));\n  }\n  var self = this;\n  if (typeof msg !== 'string') {\n    msg = '' + msg;\n  }\n  var output = common.log({\n    level: level,\n    message: msg,\n    meta: meta,\n    json: this.json,\n    logstash: this.logstash,\n    colorize: this.colorize,\n    prettyPrint: this.prettyPrint,\n    timestamp: this.timestamp,\n    showLevel: this.showLevel,\n    stringify: this.stringify,\n    label: this.label,\n    depth: this.depth,\n    formatter: this.formatter,\n    humanReadableUnhandledException: this.humanReadableUnhandledException\n  });\n  if (typeof output === 'string') {\n    output += this.eol;\n  }\n  if (!this.filename) {\n    //\n    // If there is no `filename` on this instance then it was configured\n    // with a raw `WriteableStream` instance and we should not perform any\n    // size restrictions.\n    //\n    this._write(output, callback);\n    this._size += output.length;\n    this._lazyDrain();\n  } else {\n    this.open(function (err) {\n      if (err) {\n        //\n        // If there was an error enqueue the message\n        //\n        return self._buffer.push([output, callback]);\n      }\n      self._write(output, callback);\n      self._size += output.length;\n      self._lazyDrain();\n    });\n  }\n};\n\n//\n// ### function _write (data, cb)\n// #### @data {String|Buffer} Data to write to the instance's stream.\n// #### @cb {function} Continuation to respond to when complete.\n// Write to the stream, ensure execution of a callback on completion.\n//\nFile.prototype._write = function (data, callback) {\n  if (this._isStreams2) {\n    this._stream.write(data);\n    return callback && process.nextTick(function () {\n      callback(null, true);\n    });\n  }\n\n  // If this is a file write stream, we could use the builtin\n  // callback functionality, however, the stream is not guaranteed\n  // to be an fs.WriteStream.\n  var ret = this._stream.write(data);\n  if (!callback) return;\n  if (ret === false) {\n    return this._stream.once('drain', function () {\n      callback(null, true);\n    });\n  }\n  process.nextTick(function () {\n    callback(null, true);\n  });\n};\n\n//\n// ### function query (options, callback)\n// #### @options {Object} Loggly-like query options for this instance.\n// #### @callback {function} Continuation to respond to when complete.\n// Query the transport. Options object is optional.\n//\nFile.prototype.query = function (options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  var file = path.join(this.dirname, this.filename),\n    options = this.normalizeQuery(options),\n    buff = '',\n    results = [],\n    row = 0;\n  var stream = fs.createReadStream(file, {\n    encoding: 'utf8'\n  });\n  stream.on('error', function (err) {\n    if (stream.readable) {\n      stream.destroy();\n    }\n    if (!callback) return;\n    return err.code !== 'ENOENT' ? callback(err) : callback(null, results);\n  });\n  stream.on('data', function (data) {\n    var data = (buff + data).split(/\\n+/),\n      l = data.length - 1,\n      i = 0;\n    for (; i < l; i++) {\n      if (!options.start || row >= options.start) {\n        add(data[i]);\n      }\n      row++;\n    }\n    buff = data[l];\n  });\n  stream.on('close', function () {\n    if (buff) add(buff, true);\n    if (options.order === 'desc') {\n      results = results.reverse();\n    }\n    if (callback) callback(null, results);\n  });\n  function add(buff, attempt) {\n    try {\n      var log = JSON.parse(buff);\n      if (check(log)) push(log);\n    } catch (e) {\n      if (!attempt) {\n        stream.emit('error', e);\n      }\n    }\n  }\n  function push(log) {\n    if (options.rows && results.length >= options.rows && options.order != 'desc') {\n      if (stream.readable) {\n        stream.destroy();\n      }\n      return;\n    }\n    if (options.fields) {\n      var obj = {};\n      options.fields.forEach(function (key) {\n        obj[key] = log[key];\n      });\n      log = obj;\n    }\n    if (options.order === 'desc') {\n      if (results.length >= options.rows) {\n        results.shift();\n      }\n    }\n    results.push(log);\n  }\n  function check(log) {\n    if (!log) return;\n    if (typeof log !== 'object') return;\n    var time = new Date(log.timestamp);\n    if (options.from && time < options.from || options.until && time > options.until || options.level && options.level !== log.level) {\n      return;\n    }\n    return true;\n  }\n};\n\n//\n// ### function stream (options)\n// #### @options {Object} Stream options for this instance.\n// Returns a log stream for this transport. Options object is optional.\n//\nFile.prototype.stream = function (options) {\n  var file = path.join(this.dirname, this.filename),\n    options = options || {},\n    stream = new Stream();\n  var tail = {\n    file: file,\n    start: options.start\n  };\n  stream.destroy = common.tailFile(tail, function (err, line) {\n    if (err) {\n      return stream.emit('error', err);\n    }\n    try {\n      stream.emit('data', line);\n      line = JSON.parse(line);\n      stream.emit('log', line);\n    } catch (e) {\n      stream.emit('error', e);\n    }\n  });\n  return stream;\n};\n\n//\n// ### function open (callback)\n// #### @callback {function} Continuation to respond to when complete\n// Checks to see if a new file needs to be created based on the `maxsize`\n// (if any) and the current size of the file used.\n//\nFile.prototype.open = function (callback) {\n  if (this.opening) {\n    //\n    // If we are already attempting to open the next\n    // available file then respond with a value indicating\n    // that the message should be buffered.\n    //\n    return callback(true);\n  } else if (!this._stream || this.maxsize && this._size >= this.maxsize) {\n    //\n    // If we dont have a stream or have exceeded our size, then create\n    // the next stream and respond with a value indicating that\n    // the message should be buffered.\n    //\n    callback(true);\n    return this._createStream();\n  }\n  this._archive = this.zippedArchive ? this._stream.path : null;\n\n  //\n  // Otherwise we have a valid (and ready) stream.\n  //\n  callback();\n};\n\n//\n// ### function close ()\n// Closes the stream associated with this instance.\n//\nFile.prototype.close = function () {\n  var self = this;\n  if (this._stream) {\n    this._stream.end();\n    this._stream.destroySoon();\n    this._stream.once('finish', function () {\n      self.emit('flush');\n      self.emit('closed');\n    });\n  }\n};\n\n//\n// ### function flush ()\n// Flushes any buffered messages to the current `stream`\n// used by this instance.\n//\nFile.prototype.flush = function () {\n  var self = this;\n\n  // If nothing to flush, there will be no \"flush\" event from native stream\n  // Thus, the \"open\" event will never be fired (see _createStream.createAndFlush function)\n  // That means, self.opening will never set to false and no logs will be written to disk\n  if (!this._buffer.length) {\n    return self.emit('flush');\n  }\n\n  //\n  // Iterate over the `_buffer` of enqueued messaged\n  // and then write them to the newly created stream.\n  //\n  this._buffer.forEach(function (item) {\n    var str = item[0],\n      callback = item[1];\n    process.nextTick(function () {\n      self._write(str, callback);\n      self._size += str.length;\n    });\n  });\n\n  //\n  // Quickly truncate the `_buffer` once the write operations\n  // have been started\n  //\n  self._buffer.length = 0;\n\n  //\n  // When the stream has drained we have flushed\n  // our buffer.\n  //\n  self._stream.once('drain', function () {\n    self.emit('flush');\n    self.emit('logged');\n  });\n};\n\n//\n// ### @private function _createStream ()\n// Attempts to open the next appropriate file for this instance\n// based on the common state (such as `maxsize` and `_basename`).\n//\nFile.prototype._createStream = function () {\n  var self = this;\n  this.opening = true;\n  (function checkFile(target) {\n    var fullname = path.join(self.dirname, target);\n\n    //\n    // Creates the `WriteStream` and then flushes any\n    // buffered messages.\n    //\n    function createAndFlush(size) {\n      if (self._stream) {\n        self._stream.end();\n        self._stream.destroySoon();\n      }\n      self._size = size;\n      self.filename = target;\n      self._stream = fs.createWriteStream(fullname, self.options);\n      self._isStreams2 = isWritable(self._stream);\n      self._stream.on('error', function (error) {\n        if (self._failures < self.maxRetries) {\n          self._createStream();\n          self._failures++;\n        } else {\n          self.emit('error', error);\n        }\n      });\n      //\n      // We need to listen for drain events when\n      // write() returns false. This can make node\n      // mad at times.\n      //\n      self._stream.setMaxListeners(Infinity);\n\n      //\n      // When the current stream has finished flushing\n      // then we can be sure we have finished opening\n      // and thus can emit the `open` event.\n      //\n      self.once('flush', function () {\n        // Because \"flush\" event is based on native stream \"drain\" event,\n        // logs could be written inbetween \"self.flush()\" and here\n        // Therefore, we need to flush again to make sure everything is flushed\n        self.flush();\n        self.opening = false;\n        self.emit('open', fullname);\n      });\n      //\n      // Remark: It is possible that in the time it has taken to find the\n      // next logfile to be written more data than `maxsize` has been buffered,\n      // but for sensible limits (10s - 100s of MB) this seems unlikely in less\n      // than one second.\n      //\n      self.flush();\n      compressFile();\n    }\n    function compressFile() {\n      if (self._archive) {\n        var gzip = zlib.createGzip();\n        var inp = fs.createReadStream(String(self._archive));\n        var out = fs.createWriteStream(self._archive + '.gz');\n        inp.pipe(gzip).pipe(out);\n        fs.unlink(String(self._archive), function () {});\n        self._archive = '';\n      }\n    }\n    fs.stat(fullname, function (err, stats) {\n      if (err) {\n        if (err.code !== 'ENOENT') {\n          return self.emit('error', err);\n        }\n        return createAndFlush(0);\n      }\n      if (!stats || self.maxsize && stats.size >= self.maxsize) {\n        //\n        // If `stats.size` is greater than the `maxsize` for\n        // this instance then try again\n        //\n        return self._incFile(function () {\n          checkFile(self._getFile());\n        });\n      }\n      createAndFlush(stats.size);\n    });\n  })(this._getFile());\n};\nFile.prototype._incFile = function (callback) {\n  var ext = path.extname(this._basename),\n    basename = path.basename(this._basename, ext),\n    oldest,\n    target;\n  if (!this.tailable) {\n    this._created += 1;\n    this._checkMaxFilesIncrementing(ext, basename, callback);\n  } else {\n    this._checkMaxFilesTailable(ext, basename, callback);\n  }\n};\n\n//\n// ### @private function _getFile ()\n// Gets the next filename to use for this instance\n// in the case that log filesizes are being capped.\n//\nFile.prototype._getFile = function () {\n  var ext = path.extname(this._basename),\n    basename = path.basename(this._basename, ext);\n\n  //\n  // Caveat emptor (indexzero): rotationFormat() was broken by design\n  // when combined with max files because the set of files to unlink\n  // is never stored.\n  //\n  return !this.tailable && this._created ? basename + (this.rotationFormat ? this.rotationFormat() : this._created) + ext : basename + ext;\n};\n\n//\n// ### @private function _checkMaxFilesIncrementing ()\n// Increment the number of files created or\n// checked by this instance.\n//\nFile.prototype._checkMaxFilesIncrementing = function (ext, basename, callback) {\n  var oldest,\n    target,\n    self = this;\n  if (self.zippedArchive) {\n    self._archive = path.join(self.dirname, basename + (self._created === 1 ? '' : self._created - 1) + ext);\n  }\n\n  // Check for maxFiles option and delete file\n  if (!self.maxFiles || self._created < self.maxFiles) {\n    return callback();\n  }\n  oldest = self._created - self.maxFiles;\n  target = path.join(self.dirname, basename + (oldest !== 0 ? oldest : '') + ext + (self.zippedArchive ? '.gz' : ''));\n  fs.unlink(target, callback);\n};\n\n//\n// ### @private function _checkMaxFilesTailable ()\n//\n// Roll files forward based on integer, up to maxFiles.\n// e.g. if base if file.log and it becomes oversized, roll\n//    to file1.log, and allow file.log to be re-used. If\n//    file is oversized again, roll file1.log to file2.log,\n//    roll file.log to file1.log, and so on.\nFile.prototype._checkMaxFilesTailable = function (ext, basename, callback) {\n  var tasks = [],\n    self = this;\n  if (!this.maxFiles) return;\n  for (var x = this.maxFiles - 1; x > 0; x--) {\n    tasks.push(function (i) {\n      return function (cb) {\n        var tmppath = path.join(self.dirname, basename + (i - 1) + ext + (self.zippedArchive ? '.gz' : ''));\n        fs.exists(tmppath, function (exists) {\n          if (!exists) {\n            return cb(null);\n          }\n          fs.rename(tmppath, path.join(self.dirname, basename + i + ext + (self.zippedArchive ? '.gz' : '')), cb);\n        });\n      };\n    }(x));\n  }\n  if (self.zippedArchive) {\n    self._archive = path.join(self.dirname, basename + 1 + ext);\n  }\n  async.series(tasks, function (err) {\n    fs.rename(path.join(self.dirname, basename + ext), path.join(self.dirname, basename + 1 + ext), callback);\n  });\n};\n\n//\n// ### @private function _lazyDrain ()\n// Lazily attempts to emit the `logged` event when `this.stream` has\n// drained. This is really just a simple mutex that only works because\n// Node.js is single-threaded.\n//\nFile.prototype._lazyDrain = function () {\n  var self = this;\n  if (!this._draining && this._stream) {\n    this._draining = true;\n    this._stream.once('drain', function () {\n      self._draining = false;\n      self.emit('logged');\n    });\n  }\n};","map":{"version":3,"names":["events","require","fs","path","util","async","zlib","common","Transport","isWritable","Stream","os","File","exports","options","self","call","throwIf","target","Array","prototype","slice","arguments","forEach","name","Error","filename","dirname","_basename","basename","flags","highWaterMark","stream","_stream","_isStreams2","on","error","emit","setMaxListeners","Infinity","json","logstash","colorize","maxsize","rotationFormat","zippedArchive","maxFiles","prettyPrint","label","timestamp","eol","EOL","tailable","depth","showLevel","undefined","maxRetries","stringify","_size","_created","_buffer","_draining","_opening","_failures","_archive","inherits","log","level","msg","meta","callback","silent","output","message","formatter","humanReadableUnhandledException","_write","length","_lazyDrain","open","err","push","data","write","process","nextTick","ret","once","query","file","join","normalizeQuery","buff","results","row","createReadStream","encoding","readable","destroy","code","split","l","i","start","add","order","reverse","attempt","JSON","parse","check","e","rows","fields","obj","key","shift","time","Date","from","until","tail","tailFile","line","opening","_createStream","close","end","destroySoon","flush","item","str","checkFile","fullname","createAndFlush","size","createWriteStream","compressFile","gzip","createGzip","inp","String","out","pipe","unlink","stat","stats","_incFile","_getFile","ext","extname","oldest","_checkMaxFilesIncrementing","_checkMaxFilesTailable","tasks","x","cb","tmppath","exists","rename","series"],"sources":["/home/kty/workspace/seb41_pre_001/client/node_modules/winston/lib/winston/transports/file.js"],"sourcesContent":["/*\r\n * file.js: Transport for outputting to a local log file\r\n *\r\n * (C) 2010 Charlie Robbins\r\n * MIT LICENCE\r\n *\r\n */\r\n\r\nvar events = require('events'),\r\n    fs = require('fs'),\r\n    path = require('path'),\r\n    util = require('util'),\r\n    async = require('async'),\r\n    zlib = require('zlib'),\r\n    common = require('../common'),\r\n    Transport = require('./transport').Transport,\r\n    isWritable = require('isstream').isWritable,\r\n    Stream = require('stream').Stream,\r\n    os = require('os');\r\n\r\n//\r\n// ### function File (options)\r\n// #### @options {Object} Options for this instance.\r\n// Constructor function for the File transport object responsible\r\n// for persisting log messages and metadata to one or more files.\r\n//\r\nvar File = exports.File = function (options) {\r\n  var self = this;\r\n  Transport.call(this, options);\r\n\r\n  //\r\n  // Helper function which throws an `Error` in the event\r\n  // that any of the rest of the arguments is present in `options`.\r\n  //\r\n  function throwIf (target /*, illegal... */) {\r\n    Array.prototype.slice.call(arguments, 1).forEach(function (name) {\r\n      if (options[name]) {\r\n        throw new Error('Cannot set ' + name + ' and ' + target + 'together');\r\n      }\r\n    });\r\n  }\r\n\r\n  if (options.filename || options.dirname) {\r\n    throwIf('filename or dirname', 'stream');\r\n    this._basename = this.filename = options.filename\r\n      ? path.basename(options.filename)\r\n      : 'winston.log';\r\n\r\n    this.dirname = options.dirname || path.dirname(options.filename);\r\n    this.options = options.options || { flags: 'a' };\r\n\r\n    //\r\n    // \"24 bytes\" is maybe a good value for logging lines.\r\n    //\r\n    this.options.highWaterMark = this.options.highWaterMark || 24;\r\n  }\r\n  else if (options.stream) {\r\n    throwIf('stream', 'filename', 'maxsize');\r\n    this._stream = options.stream;\r\n    this._isStreams2 = isWritable(this._stream);\r\n    this._stream.on('error', function(error){\r\n      self.emit('error', error);\r\n    });\r\n    //\r\n    // We need to listen for drain events when\r\n    // write() returns false. This can make node\r\n    // mad at times.\r\n    //\r\n    this._stream.setMaxListeners(Infinity);\r\n  }\r\n  else {\r\n    throw new Error('Cannot log to file without filename or stream.');\r\n  }\r\n\r\n  this.json        = options.json !== false;\r\n  this.logstash    = options.logstash    || false;\r\n  this.colorize    = options.colorize    || false;\r\n  this.maxsize     = options.maxsize     || null;\r\n  this.rotationFormat = options.rotationFormat || false;\r\n  this.zippedArchive = options.zippedArchive || false;\r\n  this.maxFiles    = options.maxFiles    || null;\r\n  this.prettyPrint = options.prettyPrint || false;\r\n  this.label       = options.label       || null;\r\n  this.timestamp   = options.timestamp != null ? options.timestamp : true;\r\n  this.eol         = options.eol || os.EOL;\r\n  this.tailable    = options.tailable    || false;\r\n  this.depth       = options.depth       || null;\r\n  this.showLevel   = options.showLevel === undefined ? true : options.showLevel;\r\n  this.maxRetries  = options.maxRetries || 2;\r\n\r\n  if (this.json) {\r\n    this.stringify = options.stringify;\r\n  }\r\n\r\n  //\r\n  // Internal state variables representing the number\r\n  // of files this instance has created and the current\r\n  // size (in bytes) of the current logfile.\r\n  //\r\n  this._size     = 0;\r\n  this._created  = 0;\r\n  this._buffer   = [];\r\n  this._draining = false;\r\n  this._opening  = false;\r\n  this._failures = 0;\r\n  this._archive = null;\r\n};\r\n\r\n//\r\n// Inherit from `winston.Transport`.\r\n//\r\nutil.inherits(File, Transport);\r\n\r\n//\r\n// Expose the name of this Transport on the prototype\r\n//\r\nFile.prototype.name = 'file';\r\n\r\n//\r\n// ### function log (level, msg, [meta], callback)\r\n// #### @level {string} Level at which to log the message.\r\n// #### @msg {string} Message to log\r\n// #### @meta {Object} **Optional** Additional metadata to attach\r\n// #### @callback {function} Continuation to respond to when complete.\r\n// Core logging method exposed to Winston. Metadata is optional.\r\n//\r\nFile.prototype.log = function (level, msg, meta, callback) {\r\n  if (this.silent) {\r\n    return callback(null, true);\r\n  }\r\n\r\n  //\r\n  // If failures exceeds maxRetries then we can't access the\r\n  // stream. In this case we need to perform a noop and return\r\n  // an error.\r\n  //\r\n  if (this._failures >= this.maxRetries) {\r\n    return callback(new Error('Transport is in a failed state.'));\r\n  }\r\n\r\n  var self = this;\r\n\r\n  if (typeof msg !== 'string') {\r\n    msg = '' + msg;\r\n  }\r\n\r\n  var output = common.log({\r\n    level:       level,\r\n    message:     msg,\r\n    meta:        meta,\r\n    json:        this.json,\r\n    logstash:    this.logstash,\r\n    colorize:    this.colorize,\r\n    prettyPrint: this.prettyPrint,\r\n    timestamp:   this.timestamp,\r\n    showLevel:   this.showLevel,\r\n    stringify:   this.stringify,\r\n    label:       this.label,\r\n    depth:       this.depth,\r\n    formatter:   this.formatter,\r\n    humanReadableUnhandledException: this.humanReadableUnhandledException\r\n  });\r\n\r\n  if (typeof output === 'string') {\r\n    output += this.eol;\r\n  }\r\n\r\n  if (!this.filename) {\r\n    //\r\n    // If there is no `filename` on this instance then it was configured\r\n    // with a raw `WriteableStream` instance and we should not perform any\r\n    // size restrictions.\r\n    //\r\n    this._write(output, callback);\r\n    this._size += output.length;\r\n    this._lazyDrain();\r\n  }\r\n  else {\r\n    this.open(function (err) {\r\n      if (err) {\r\n        //\r\n        // If there was an error enqueue the message\r\n        //\r\n        return self._buffer.push([output, callback]);\r\n      }\r\n\r\n      self._write(output, callback);\r\n      self._size += output.length;\r\n      self._lazyDrain();\r\n    });\r\n  }\r\n};\r\n\r\n//\r\n// ### function _write (data, cb)\r\n// #### @data {String|Buffer} Data to write to the instance's stream.\r\n// #### @cb {function} Continuation to respond to when complete.\r\n// Write to the stream, ensure execution of a callback on completion.\r\n//\r\nFile.prototype._write = function(data, callback) {\r\n  if (this._isStreams2) {\r\n    this._stream.write(data);\r\n    return callback && process.nextTick(function () {\r\n      callback(null, true);\r\n    });\r\n  }\r\n\r\n  // If this is a file write stream, we could use the builtin\r\n  // callback functionality, however, the stream is not guaranteed\r\n  // to be an fs.WriteStream.\r\n  var ret = this._stream.write(data);\r\n  if (!callback) return;\r\n  if (ret === false) {\r\n    return this._stream.once('drain', function() {\r\n      callback(null, true);\r\n    });\r\n  }\r\n  process.nextTick(function () {\r\n    callback(null, true);\r\n  });\r\n};\r\n\r\n//\r\n// ### function query (options, callback)\r\n// #### @options {Object} Loggly-like query options for this instance.\r\n// #### @callback {function} Continuation to respond to when complete.\r\n// Query the transport. Options object is optional.\r\n//\r\nFile.prototype.query = function (options, callback) {\r\n  if (typeof options === 'function') {\r\n    callback = options;\r\n    options = {};\r\n  }\r\n\r\n  var file = path.join(this.dirname, this.filename),\r\n      options = this.normalizeQuery(options),\r\n      buff = '',\r\n      results = [],\r\n      row = 0;\r\n\r\n  var stream = fs.createReadStream(file, {\r\n    encoding: 'utf8'\r\n  });\r\n\r\n  stream.on('error', function (err) {\r\n    if (stream.readable) {\r\n      stream.destroy();\r\n    }\r\n    if (!callback) return;\r\n    return err.code !== 'ENOENT'\r\n      ? callback(err)\r\n      : callback(null, results);\r\n  });\r\n\r\n  stream.on('data', function (data) {\r\n    var data = (buff + data).split(/\\n+/),\r\n        l = data.length - 1,\r\n        i = 0;\r\n\r\n    for (; i < l; i++) {\r\n      if (!options.start || row >= options.start) {\r\n        add(data[i]);\r\n      }\r\n      row++;\r\n    }\r\n\r\n    buff = data[l];\r\n  });\r\n\r\n  stream.on('close', function () {\r\n    if (buff) add(buff, true);\r\n    if (options.order === 'desc') {\r\n      results = results.reverse();\r\n    }\r\n    if (callback) callback(null, results);\r\n  });\r\n\r\n  function add(buff, attempt) {\r\n    try {\r\n      var log = JSON.parse(buff);\r\n      if (check(log)) push(log);\r\n    } catch (e) {\r\n      if (!attempt) {\r\n        stream.emit('error', e);\r\n      }\r\n    }\r\n  }\r\n\r\n  function push(log) {\r\n    if (options.rows && results.length >= options.rows\r\n        && options.order != 'desc') {\r\n      if (stream.readable) {\r\n        stream.destroy();\r\n      }\r\n      return;\r\n    }\r\n\r\n    if (options.fields) {\r\n      var obj = {};\r\n      options.fields.forEach(function (key) {\r\n        obj[key] = log[key];\r\n      });\r\n      log = obj;\r\n    }\r\n\r\n    if (options.order === 'desc') {\r\n      if (results.length >= options.rows) {\r\n        results.shift();\r\n      }\r\n    }\r\n    results.push(log);\r\n  }\r\n\r\n  function check(log) {\r\n    if (!log) return;\r\n\r\n    if (typeof log !== 'object') return;\r\n\r\n    var time = new Date(log.timestamp);\r\n    if ((options.from && time < options.from)\r\n        || (options.until && time > options.until)\r\n        || (options.level && options.level !== log.level)) {\r\n      return;\r\n    }\r\n\r\n    return true;\r\n  }\r\n};\r\n\r\n//\r\n// ### function stream (options)\r\n// #### @options {Object} Stream options for this instance.\r\n// Returns a log stream for this transport. Options object is optional.\r\n//\r\nFile.prototype.stream = function (options) {\r\n  var file = path.join(this.dirname, this.filename),\r\n      options = options || {},\r\n      stream = new Stream;\r\n\r\n  var tail = {\r\n    file: file,\r\n    start: options.start\r\n  };\r\n\r\n  stream.destroy = common.tailFile(tail, function (err, line) {\r\n\r\n    if(err){\r\n      return stream.emit('error',err);\r\n    }\r\n\r\n    try {\r\n      stream.emit('data', line);\r\n      line = JSON.parse(line);\r\n      stream.emit('log', line);\r\n    } catch (e) {\r\n      stream.emit('error', e);\r\n    }\r\n  });\r\n\r\n  return stream;\r\n};\r\n\r\n//\r\n// ### function open (callback)\r\n// #### @callback {function} Continuation to respond to when complete\r\n// Checks to see if a new file needs to be created based on the `maxsize`\r\n// (if any) and the current size of the file used.\r\n//\r\nFile.prototype.open = function (callback) {\r\n  if (this.opening) {\r\n    //\r\n    // If we are already attempting to open the next\r\n    // available file then respond with a value indicating\r\n    // that the message should be buffered.\r\n    //\r\n    return callback(true);\r\n  }\r\n  else if (!this._stream || (this.maxsize && this._size >= this.maxsize)) {\r\n    //\r\n    // If we dont have a stream or have exceeded our size, then create\r\n    // the next stream and respond with a value indicating that\r\n    // the message should be buffered.\r\n    //\r\n    callback(true);\r\n    return this._createStream();\r\n  }\r\n\r\n  this._archive = this.zippedArchive ? this._stream.path : null;\r\n\r\n  //\r\n  // Otherwise we have a valid (and ready) stream.\r\n  //\r\n  callback();\r\n};\r\n\r\n//\r\n// ### function close ()\r\n// Closes the stream associated with this instance.\r\n//\r\nFile.prototype.close = function () {\r\n  var self = this;\r\n\r\n  if (this._stream) {\r\n    this._stream.end();\r\n    this._stream.destroySoon();\r\n\r\n    this._stream.once('finish', function () {\r\n      self.emit('flush');\r\n      self.emit('closed');\r\n    });\r\n  }\r\n};\r\n\r\n//\r\n// ### function flush ()\r\n// Flushes any buffered messages to the current `stream`\r\n// used by this instance.\r\n//\r\nFile.prototype.flush = function () {\r\n  var self = this;\r\n\r\n  // If nothing to flush, there will be no \"flush\" event from native stream\r\n  // Thus, the \"open\" event will never be fired (see _createStream.createAndFlush function)\r\n  // That means, self.opening will never set to false and no logs will be written to disk\r\n  if (!this._buffer.length) {\r\n    return self.emit('flush');\r\n  }\r\n\r\n  //\r\n  // Iterate over the `_buffer` of enqueued messaged\r\n  // and then write them to the newly created stream.\r\n  //\r\n  this._buffer.forEach(function (item) {\r\n    var str = item[0],\r\n        callback = item[1];\r\n\r\n    process.nextTick(function () {\r\n      self._write(str, callback);\r\n      self._size += str.length;\r\n    });\r\n  });\r\n\r\n  //\r\n  // Quickly truncate the `_buffer` once the write operations\r\n  // have been started\r\n  //\r\n  self._buffer.length = 0;\r\n\r\n  //\r\n  // When the stream has drained we have flushed\r\n  // our buffer.\r\n  //\r\n  self._stream.once('drain', function () {\r\n    self.emit('flush');\r\n    self.emit('logged');\r\n  });\r\n};\r\n\r\n//\r\n// ### @private function _createStream ()\r\n// Attempts to open the next appropriate file for this instance\r\n// based on the common state (such as `maxsize` and `_basename`).\r\n//\r\nFile.prototype._createStream = function () {\r\n  var self = this;\r\n  this.opening = true;\r\n\r\n  (function checkFile (target) {\r\n    var fullname = path.join(self.dirname, target);\r\n\r\n    //\r\n    // Creates the `WriteStream` and then flushes any\r\n    // buffered messages.\r\n    //\r\n    function createAndFlush (size) {\r\n      if (self._stream) {\r\n        self._stream.end();\r\n        self._stream.destroySoon();\r\n      }\r\n\r\n      self._size = size;\r\n      self.filename = target;\r\n      self._stream = fs.createWriteStream(fullname, self.options);\r\n      self._isStreams2 = isWritable(self._stream);\r\n      self._stream.on('error', function(error){\r\n        if (self._failures < self.maxRetries) {\r\n          self._createStream();\r\n          self._failures++;\r\n        }\r\n        else {\r\n          self.emit('error', error);\r\n        }\r\n      });\r\n      //\r\n      // We need to listen for drain events when\r\n      // write() returns false. This can make node\r\n      // mad at times.\r\n      //\r\n      self._stream.setMaxListeners(Infinity);\r\n\r\n      //\r\n      // When the current stream has finished flushing\r\n      // then we can be sure we have finished opening\r\n      // and thus can emit the `open` event.\r\n      //\r\n      self.once('flush', function () {\r\n        // Because \"flush\" event is based on native stream \"drain\" event,\r\n        // logs could be written inbetween \"self.flush()\" and here\r\n        // Therefore, we need to flush again to make sure everything is flushed\r\n        self.flush();\r\n\r\n        self.opening = false;\r\n        self.emit('open', fullname);\r\n      });\r\n      //\r\n      // Remark: It is possible that in the time it has taken to find the\r\n      // next logfile to be written more data than `maxsize` has been buffered,\r\n      // but for sensible limits (10s - 100s of MB) this seems unlikely in less\r\n      // than one second.\r\n      //\r\n      self.flush();\r\n      compressFile();\r\n    }\r\n\r\n    function compressFile() {\r\n      if (self._archive) {\r\n        var gzip = zlib.createGzip();\r\n\r\n        var inp = fs.createReadStream(String(self._archive));\r\n        var out = fs.createWriteStream(self._archive + '.gz');\r\n\r\n        inp.pipe(gzip).pipe(out);\r\n\r\n        fs.unlink(String(self._archive), function () {});\r\n        self._archive = '';\r\n      }\r\n    }\r\n\r\n    fs.stat(fullname, function (err, stats) {\r\n      if (err) {\r\n        if (err.code !== 'ENOENT') {\r\n          return self.emit('error', err);\r\n        }\r\n        return createAndFlush(0);\r\n      }\r\n\r\n      if (!stats || (self.maxsize && stats.size >= self.maxsize)) {\r\n        //\r\n        // If `stats.size` is greater than the `maxsize` for\r\n        // this instance then try again\r\n        //\r\n        return self._incFile(function() {\r\n          checkFile(self._getFile());\r\n        });\r\n      }\r\n\r\n      createAndFlush(stats.size);\r\n    });\r\n  })(this._getFile());\r\n};\r\n\r\n\r\nFile.prototype._incFile = function (callback) {\r\n  var ext = path.extname(this._basename),\r\n      basename = path.basename(this._basename, ext),\r\n      oldest,\r\n      target;\r\n\r\n  if (!this.tailable) {\r\n    this._created += 1;\r\n    this._checkMaxFilesIncrementing(ext, basename, callback);\r\n  }\r\n  else {\r\n    this._checkMaxFilesTailable(ext, basename, callback);\r\n  }\r\n};\r\n\r\n//\r\n// ### @private function _getFile ()\r\n// Gets the next filename to use for this instance\r\n// in the case that log filesizes are being capped.\r\n//\r\nFile.prototype._getFile = function () {\r\n  var ext = path.extname(this._basename),\r\n      basename = path.basename(this._basename, ext);\r\n\r\n  //\r\n  // Caveat emptor (indexzero): rotationFormat() was broken by design\r\n  // when combined with max files because the set of files to unlink\r\n  // is never stored.\r\n  //\r\n  return !this.tailable && this._created\r\n    ? basename + (this.rotationFormat ? this.rotationFormat() : this._created) + ext\r\n    : basename + ext;\r\n};\r\n\r\n//\r\n// ### @private function _checkMaxFilesIncrementing ()\r\n// Increment the number of files created or\r\n// checked by this instance.\r\n//\r\nFile.prototype._checkMaxFilesIncrementing = function (ext, basename, callback) {\r\n  var oldest, target,\r\n    self = this;\r\n\r\n  if (self.zippedArchive) {\r\n    self._archive = path.join(self.dirname, basename +\r\n        ((self._created === 1) ? '' : self._created-1) +\r\n        ext);\r\n  }\r\n\r\n\r\n  // Check for maxFiles option and delete file\r\n  if (!self.maxFiles || self._created < self.maxFiles) {\r\n    return callback();\r\n  }\r\n\r\n  oldest = self._created - self.maxFiles;\r\n  target = path.join(self.dirname, basename + (oldest !== 0 ? oldest : '') + ext +\r\n    (self.zippedArchive ? '.gz' : ''));\r\n  fs.unlink(target, callback);\r\n};\r\n\r\n//\r\n// ### @private function _checkMaxFilesTailable ()\r\n//\r\n// Roll files forward based on integer, up to maxFiles.\r\n// e.g. if base if file.log and it becomes oversized, roll\r\n//    to file1.log, and allow file.log to be re-used. If\r\n//    file is oversized again, roll file1.log to file2.log,\r\n//    roll file.log to file1.log, and so on.\r\nFile.prototype._checkMaxFilesTailable = function (ext, basename, callback) {\r\n  var tasks = [],\r\n      self = this;\r\n\r\n  if (!this.maxFiles)\r\n    return;\r\n\r\n  for (var x = this.maxFiles - 1; x > 0; x--) {\r\n    tasks.push(function (i) {\r\n      return function (cb) {\r\n        var tmppath = path.join(self.dirname, basename + (i - 1) + ext +\r\n          (self.zippedArchive ? '.gz' : ''));\r\n        fs.exists(tmppath, function (exists) {\r\n          if (!exists) {\r\n            return cb(null);\r\n          }\r\n\r\n          fs.rename(tmppath, path.join(self.dirname, basename + i + ext +\r\n            (self.zippedArchive ? '.gz' : '')), cb);\r\n        });\r\n      };\r\n    }(x));\r\n  }\r\n\r\n  if (self.zippedArchive) {\r\n    self._archive = path.join(self.dirname, basename + 1 + ext);\r\n  }\r\n  async.series(tasks, function (err) {\r\n    fs.rename(\r\n      path.join(self.dirname, basename + ext),\r\n      path.join(self.dirname, basename + 1 + ext),\r\n      callback\r\n    );\r\n  });\r\n};\r\n\r\n//\r\n// ### @private function _lazyDrain ()\r\n// Lazily attempts to emit the `logged` event when `this.stream` has\r\n// drained. This is really just a simple mutex that only works because\r\n// Node.js is single-threaded.\r\n//\r\nFile.prototype._lazyDrain = function () {\r\n  var self = this;\r\n\r\n  if (!this._draining && this._stream) {\r\n    this._draining = true;\r\n\r\n    this._stream.once('drain', function () {\r\n      self._draining = false;\r\n      self.emit('logged');\r\n    });\r\n  }\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
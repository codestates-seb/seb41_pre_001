{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding, markdownLineEndingOrSpace } from 'micromark-util-character';\n\n/** @type {Construct} */\nexport var codeFenced = {\n  name: 'codeFenced',\n  tokenize: tokenizeCodeFenced,\n  concrete: true\n};\n/** @type {Tokenizer} */\n\nfunction tokenizeCodeFenced(effects, ok, nok) {\n  var self = this;\n  /** @type {Construct} */\n\n  var closingFenceConstruct = {\n    tokenize: tokenizeClosingFence,\n    partial: true\n  };\n  /** @type {Construct} */\n\n  var nonLazyLine = {\n    tokenize: tokenizeNonLazyLine,\n    partial: true\n  };\n  var tail = this.events[this.events.length - 1];\n  var initialPrefix = tail && tail[1].type === 'linePrefix' ? tail[2].sliceSerialize(tail[1], true).length : 0;\n  var sizeOpen = 0;\n  /** @type {NonNullable<Code>} */\n\n  var marker;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('codeFenced');\n    effects.enter('codeFencedFence');\n    effects.enter('codeFencedFenceSequence');\n    marker = code;\n    return sequenceOpen(code);\n  }\n  /** @type {State} */\n\n  function sequenceOpen(code) {\n    if (code === marker) {\n      effects.consume(code);\n      sizeOpen++;\n      return sequenceOpen;\n    }\n    effects.exit('codeFencedFenceSequence');\n    return sizeOpen < 3 ? nok(code) : factorySpace(effects, infoOpen, 'whitespace')(code);\n  }\n  /** @type {State} */\n\n  function infoOpen(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return openAfter(code);\n    }\n    effects.enter('codeFencedFenceInfo');\n    effects.enter('chunkString', {\n      contentType: 'string'\n    });\n    return info(code);\n  }\n  /** @type {State} */\n\n  function info(code) {\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      effects.exit('chunkString');\n      effects.exit('codeFencedFenceInfo');\n      return factorySpace(effects, infoAfter, 'whitespace')(code);\n    }\n    if (code === 96 && code === marker) return nok(code);\n    effects.consume(code);\n    return info;\n  }\n  /** @type {State} */\n\n  function infoAfter(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return openAfter(code);\n    }\n    effects.enter('codeFencedFenceMeta');\n    effects.enter('chunkString', {\n      contentType: 'string'\n    });\n    return meta(code);\n  }\n  /** @type {State} */\n\n  function meta(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('chunkString');\n      effects.exit('codeFencedFenceMeta');\n      return openAfter(code);\n    }\n    if (code === 96 && code === marker) return nok(code);\n    effects.consume(code);\n    return meta;\n  }\n  /** @type {State} */\n\n  function openAfter(code) {\n    effects.exit('codeFencedFence');\n    return self.interrupt ? ok(code) : contentStart(code);\n  }\n  /** @type {State} */\n\n  function contentStart(code) {\n    if (code === null) {\n      return after(code);\n    }\n    if (markdownLineEnding(code)) {\n      return effects.attempt(nonLazyLine, effects.attempt(closingFenceConstruct, after, initialPrefix ? factorySpace(effects, contentStart, 'linePrefix', initialPrefix + 1) : contentStart), after)(code);\n    }\n    effects.enter('codeFlowValue');\n    return contentContinue(code);\n  }\n  /** @type {State} */\n\n  function contentContinue(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('codeFlowValue');\n      return contentStart(code);\n    }\n    effects.consume(code);\n    return contentContinue;\n  }\n  /** @type {State} */\n\n  function after(code) {\n    effects.exit('codeFenced');\n    return ok(code);\n  }\n  /** @type {Tokenizer} */\n\n  function tokenizeNonLazyLine(effects, ok, nok) {\n    var self = this;\n    return start;\n    /** @type {State} */\n\n    function start(code) {\n      effects.enter('lineEnding');\n      effects.consume(code);\n      effects.exit('lineEnding');\n      return lineStart;\n    }\n    /** @type {State} */\n\n    function lineStart(code) {\n      return self.parser.lazy[self.now().line] ? nok(code) : ok(code);\n    }\n  }\n  /** @type {Tokenizer} */\n\n  function tokenizeClosingFence(effects, ok, nok) {\n    var size = 0;\n    return factorySpace(effects, closingSequenceStart, 'linePrefix', this.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4);\n    /** @type {State} */\n\n    function closingSequenceStart(code) {\n      effects.enter('codeFencedFence');\n      effects.enter('codeFencedFenceSequence');\n      return closingSequence(code);\n    }\n    /** @type {State} */\n\n    function closingSequence(code) {\n      if (code === marker) {\n        effects.consume(code);\n        size++;\n        return closingSequence;\n      }\n      if (size < sizeOpen) return nok(code);\n      effects.exit('codeFencedFenceSequence');\n      return factorySpace(effects, closingSequenceEnd, 'whitespace')(code);\n    }\n    /** @type {State} */\n\n    function closingSequenceEnd(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit('codeFencedFence');\n        return ok(code);\n      }\n      return nok(code);\n    }\n  }\n}","map":{"version":3,"names":["factorySpace","markdownLineEnding","markdownLineEndingOrSpace","codeFenced","name","tokenize","tokenizeCodeFenced","concrete","effects","ok","nok","self","closingFenceConstruct","tokenizeClosingFence","partial","nonLazyLine","tokenizeNonLazyLine","tail","events","length","initialPrefix","type","sliceSerialize","sizeOpen","marker","start","code","enter","sequenceOpen","consume","exit","infoOpen","openAfter","contentType","info","infoAfter","meta","interrupt","contentStart","after","attempt","contentContinue","lineStart","parser","lazy","now","line","size","closingSequenceStart","constructs","disable","null","includes","undefined","closingSequence","closingSequenceEnd"],"sources":["/home/kty/workspace/seb41_pre_001/client/node_modules/micromark-core-commonmark/lib/code-fenced.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace\n} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const codeFenced = {\n  name: 'codeFenced',\n  tokenize: tokenizeCodeFenced,\n  concrete: true\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeCodeFenced(effects, ok, nok) {\n  const self = this\n  /** @type {Construct} */\n\n  const closingFenceConstruct = {\n    tokenize: tokenizeClosingFence,\n    partial: true\n  }\n  /** @type {Construct} */\n\n  const nonLazyLine = {\n    tokenize: tokenizeNonLazyLine,\n    partial: true\n  }\n  const tail = this.events[this.events.length - 1]\n  const initialPrefix =\n    tail && tail[1].type === 'linePrefix'\n      ? tail[2].sliceSerialize(tail[1], true).length\n      : 0\n  let sizeOpen = 0\n  /** @type {NonNullable<Code>} */\n\n  let marker\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('codeFenced')\n    effects.enter('codeFencedFence')\n    effects.enter('codeFencedFenceSequence')\n    marker = code\n    return sequenceOpen(code)\n  }\n  /** @type {State} */\n\n  function sequenceOpen(code) {\n    if (code === marker) {\n      effects.consume(code)\n      sizeOpen++\n      return sequenceOpen\n    }\n\n    effects.exit('codeFencedFenceSequence')\n    return sizeOpen < 3\n      ? nok(code)\n      : factorySpace(effects, infoOpen, 'whitespace')(code)\n  }\n  /** @type {State} */\n\n  function infoOpen(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return openAfter(code)\n    }\n\n    effects.enter('codeFencedFenceInfo')\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return info(code)\n  }\n  /** @type {State} */\n\n  function info(code) {\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      effects.exit('chunkString')\n      effects.exit('codeFencedFenceInfo')\n      return factorySpace(effects, infoAfter, 'whitespace')(code)\n    }\n\n    if (code === 96 && code === marker) return nok(code)\n    effects.consume(code)\n    return info\n  }\n  /** @type {State} */\n\n  function infoAfter(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return openAfter(code)\n    }\n\n    effects.enter('codeFencedFenceMeta')\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return meta(code)\n  }\n  /** @type {State} */\n\n  function meta(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('chunkString')\n      effects.exit('codeFencedFenceMeta')\n      return openAfter(code)\n    }\n\n    if (code === 96 && code === marker) return nok(code)\n    effects.consume(code)\n    return meta\n  }\n  /** @type {State} */\n\n  function openAfter(code) {\n    effects.exit('codeFencedFence')\n    return self.interrupt ? ok(code) : contentStart(code)\n  }\n  /** @type {State} */\n\n  function contentStart(code) {\n    if (code === null) {\n      return after(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.attempt(\n        nonLazyLine,\n        effects.attempt(\n          closingFenceConstruct,\n          after,\n          initialPrefix\n            ? factorySpace(\n                effects,\n                contentStart,\n                'linePrefix',\n                initialPrefix + 1\n              )\n            : contentStart\n        ),\n        after\n      )(code)\n    }\n\n    effects.enter('codeFlowValue')\n    return contentContinue(code)\n  }\n  /** @type {State} */\n\n  function contentContinue(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('codeFlowValue')\n      return contentStart(code)\n    }\n\n    effects.consume(code)\n    return contentContinue\n  }\n  /** @type {State} */\n\n  function after(code) {\n    effects.exit('codeFenced')\n    return ok(code)\n  }\n  /** @type {Tokenizer} */\n\n  function tokenizeNonLazyLine(effects, ok, nok) {\n    const self = this\n    return start\n    /** @type {State} */\n\n    function start(code) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return lineStart\n    }\n    /** @type {State} */\n\n    function lineStart(code) {\n      return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n    }\n  }\n  /** @type {Tokenizer} */\n\n  function tokenizeClosingFence(effects, ok, nok) {\n    let size = 0\n    return factorySpace(\n      effects,\n      closingSequenceStart,\n      'linePrefix',\n      this.parser.constructs.disable.null.includes('codeIndented')\n        ? undefined\n        : 4\n    )\n    /** @type {State} */\n\n    function closingSequenceStart(code) {\n      effects.enter('codeFencedFence')\n      effects.enter('codeFencedFenceSequence')\n      return closingSequence(code)\n    }\n    /** @type {State} */\n\n    function closingSequence(code) {\n      if (code === marker) {\n        effects.consume(code)\n        size++\n        return closingSequence\n      }\n\n      if (size < sizeOpen) return nok(code)\n      effects.exit('codeFencedFenceSequence')\n      return factorySpace(effects, closingSequenceEnd, 'whitespace')(code)\n    }\n    /** @type {State} */\n\n    function closingSequenceEnd(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit('codeFencedFence')\n        return ok(code)\n      }\n\n      return nok(code)\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"/**\n * See <https://tools.ietf.org/html/rfc4647#section-3.1>\n * for more info on the algorithms.\n */\n\n/**\n * @typedef {string} Tag\n *   BCP-47 tag.\n * @typedef {Array<Tag>} Tags\n *   List of BCP-47 tags.\n * @typedef {string} Range\n *   RFC 4647 range.\n * @typedef {Array<Range>} Ranges\n *   List of RFC 4647 range.\n *\n * @callback Check\n *   An internal check.\n * @param {Tag} tag\n *   BCP-47 tag.\n * @param {Range} range\n *   RFC 4647 range.\n * @returns {boolean}\n *   Whether the range matches the tag.\n *\n * @typedef {FilterOrLookup<true>} Filter\n *   Filter: yields all tags that match a range.\n * @typedef {FilterOrLookup<false>} Lookup\n *   Lookup: yields the best tag that matches a range.\n */\n\n/**\n * @template {boolean} IsFilter\n *   Whether to filter or perform a lookup.\n * @callback FilterOrLookup\n *   A check.\n * @param {Tag|Tags} tags\n *   One or more BCP-47 tags.\n * @param {Range|Ranges|undefined} [ranges='*']\n *   One or more RFC 4647 ranges.\n * @returns {IsFilter extends true ? Tags : Tag|undefined}\n *   Result.\n */\n\n/**\n * Factory to perform a filter or a lookup.\n *\n * This factory creates a function that accepts a list of tags and a list of\n * ranges, and contains logic to exit early for lookups.\n * `check` just has to deal with one tag and one range.\n * This match function iterates over ranges, and for each range,\n * iterates over tags.\n * That way, earlier ranges matching any tag have precedence over later ranges.\n *\n * @template {boolean} IsFilter\n * @param {Check} check\n *   A check.\n * @param {IsFilter} filter\n *   Whether to filter or perform a lookup.\n * @returns {FilterOrLookup<IsFilter>}\n *   Filter or lookup.\n */\nfunction factory(check, filter) {\n  /**\n   * @param {Tag|Tags} tags\n   *   One or more BCP-47 tags.\n   * @param {Range|Ranges|undefined} [ranges='*']\n   *   One or more RFC 4647 ranges.\n   * @returns {IsFilter extends true ? Tags : Tag|undefined}\n   *   Result.\n   */\n  return function (tags, ranges) {\n    var left = cast(tags, 'tag');\n    var right = cast(ranges === null || ranges === undefined ? '*' : ranges, 'range');\n    /** @type {Tags} */\n    var matches = [];\n    var rightIndex = -1;\n    while (++rightIndex < right.length) {\n      var range = right[rightIndex].toLowerCase();\n\n      // Ignore wildcards in lookup mode.\n      if (!filter && range === '*') continue;\n      var leftIndex = -1;\n      /** @type {Tags} */\n      var next = [];\n      while (++leftIndex < left.length) {\n        if (check(left[leftIndex].toLowerCase(), range)) {\n          // Exit if this is a lookup and we have a match.\n          if (!filter) {\n            return (/** @type {IsFilter extends true ? Tags : Tag|undefined} */\n              left[leftIndex]\n            );\n          }\n          matches.push(left[leftIndex]);\n        } else {\n          next.push(left[leftIndex]);\n        }\n      }\n      left = next;\n    }\n\n    // If this is a filter, return the list.  If it’s a lookup, we didn’t find\n    // a match, so return `undefined`.\n    return (/** @type {IsFilter extends true ? Tags : Tag|undefined} */\n      filter ? matches : undefined\n    );\n  };\n}\n\n/**\n * Basic Filtering (Section 3.3.1) matches a language priority list consisting\n * of basic language ranges (Section 2.1) to sets of language tags.\n *\n * @param {Tag|Tags} tags\n *   One or more BCP-47 tags.\n * @param {Range|Ranges|undefined} [ranges='*']\n *   One or more RFC 4647 ranges.\n * @returns {Tags}\n *   List of BCP-47 tags.\n */\nexport var basicFilter = factory(function (tag, range) {\n  return range === '*' || tag === range || tag.includes(range + '-');\n}, true);\n\n/**\n * Extended Filtering (Section 3.3.2) matches a language priority list\n * consisting of extended language ranges (Section 2.2) to sets of language\n * tags.\n *\n * @param {Tag|Tags} tags\n *   One or more BCP-47 tags.\n * @param {Range|Ranges|undefined} [ranges='*']\n *   One or more RFC 4647 ranges.\n * @returns {Tags}\n *   List of BCP-47 tags.\n */\nexport var extendedFilter = factory(function (tag, range) {\n  // 3.3.2.1\n  var left = tag.split('-');\n  var right = range.split('-');\n  var leftIndex = 0;\n  var rightIndex = 0;\n\n  // 3.3.2.2\n  if (right[rightIndex] !== '*' && left[leftIndex] !== right[rightIndex]) {\n    return false;\n  }\n  leftIndex++;\n  rightIndex++;\n\n  // 3.3.2.3\n  while (rightIndex < right.length) {\n    // 3.3.2.3.A\n    if (right[rightIndex] === '*') {\n      rightIndex++;\n      continue;\n    }\n\n    // 3.3.2.3.B\n    if (!left[leftIndex]) return false;\n\n    // 3.3.2.3.C\n    if (left[leftIndex] === right[rightIndex]) {\n      leftIndex++;\n      rightIndex++;\n      continue;\n    }\n\n    // 3.3.2.3.D\n    if (left[leftIndex].length === 1) return false;\n\n    // 3.3.2.3.E\n    leftIndex++;\n  }\n\n  // 3.3.2.4\n  return true;\n}, true);\n\n/**\n * Lookup (Section 3.4) matches a language priority list consisting of basic\n * language ranges to sets of language tags to find the one exact language tag\n * that best matches the range.\n *\n * @param {Tag|Tags} tags\n *   One or more BCP-47 tags.\n * @param {Range|Ranges|undefined} [ranges='*']\n *   One or more RFC 4647 ranges.\n * @returns {Tag|undefined}\n *   BCP-47 tag.\n */\nexport var lookup = factory(function (tag, range) {\n  var right = range;\n\n  /* eslint-disable-next-line no-constant-condition */\n  while (true) {\n    if (right === '*' || tag === right) return true;\n    var index = right.lastIndexOf('-');\n    if (index < 0) return false;\n    if (right.charAt(index - 2) === '-') index -= 2;\n    right = right.slice(0, index);\n  }\n}, false);\n\n/**\n * Validate tags or ranges, and cast them to arrays.\n *\n * @param {string|Array<string>} values\n * @param {string} name\n * @returns {Array<string>}\n */\nfunction cast(values, name) {\n  var value = values && typeof values === 'string' ? [values] : values;\n  if (!value || typeof value !== 'object' || !('length' in value)) {\n    throw new Error('Invalid ' + name + ' `' + value + '`, expected non-empty string');\n  }\n  return value;\n}","map":{"version":3,"names":["factory","check","filter","tags","ranges","left","cast","right","undefined","matches","rightIndex","length","range","toLowerCase","leftIndex","next","push","basicFilter","tag","includes","extendedFilter","split","lookup","index","lastIndexOf","charAt","slice","values","name","value","Error"],"sources":["/home/kty/workspace/seb41_pre_001/client/node_modules/bcp-47-match/index.js"],"sourcesContent":["/**\n * See <https://tools.ietf.org/html/rfc4647#section-3.1>\n * for more info on the algorithms.\n */\n\n/**\n * @typedef {string} Tag\n *   BCP-47 tag.\n * @typedef {Array<Tag>} Tags\n *   List of BCP-47 tags.\n * @typedef {string} Range\n *   RFC 4647 range.\n * @typedef {Array<Range>} Ranges\n *   List of RFC 4647 range.\n *\n * @callback Check\n *   An internal check.\n * @param {Tag} tag\n *   BCP-47 tag.\n * @param {Range} range\n *   RFC 4647 range.\n * @returns {boolean}\n *   Whether the range matches the tag.\n *\n * @typedef {FilterOrLookup<true>} Filter\n *   Filter: yields all tags that match a range.\n * @typedef {FilterOrLookup<false>} Lookup\n *   Lookup: yields the best tag that matches a range.\n */\n\n/**\n * @template {boolean} IsFilter\n *   Whether to filter or perform a lookup.\n * @callback FilterOrLookup\n *   A check.\n * @param {Tag|Tags} tags\n *   One or more BCP-47 tags.\n * @param {Range|Ranges|undefined} [ranges='*']\n *   One or more RFC 4647 ranges.\n * @returns {IsFilter extends true ? Tags : Tag|undefined}\n *   Result.\n */\n\n/**\n * Factory to perform a filter or a lookup.\n *\n * This factory creates a function that accepts a list of tags and a list of\n * ranges, and contains logic to exit early for lookups.\n * `check` just has to deal with one tag and one range.\n * This match function iterates over ranges, and for each range,\n * iterates over tags.\n * That way, earlier ranges matching any tag have precedence over later ranges.\n *\n * @template {boolean} IsFilter\n * @param {Check} check\n *   A check.\n * @param {IsFilter} filter\n *   Whether to filter or perform a lookup.\n * @returns {FilterOrLookup<IsFilter>}\n *   Filter or lookup.\n */\nfunction factory(check, filter) {\n  /**\n   * @param {Tag|Tags} tags\n   *   One or more BCP-47 tags.\n   * @param {Range|Ranges|undefined} [ranges='*']\n   *   One or more RFC 4647 ranges.\n   * @returns {IsFilter extends true ? Tags : Tag|undefined}\n   *   Result.\n   */\n  return function (tags, ranges) {\n    let left = cast(tags, 'tag')\n    const right = cast(\n      ranges === null || ranges === undefined ? '*' : ranges,\n      'range'\n    )\n    /** @type {Tags} */\n    const matches = []\n    let rightIndex = -1\n\n    while (++rightIndex < right.length) {\n      const range = right[rightIndex].toLowerCase()\n\n      // Ignore wildcards in lookup mode.\n      if (!filter && range === '*') continue\n\n      let leftIndex = -1\n      /** @type {Tags} */\n      const next = []\n\n      while (++leftIndex < left.length) {\n        if (check(left[leftIndex].toLowerCase(), range)) {\n          // Exit if this is a lookup and we have a match.\n          if (!filter) {\n            return /** @type {IsFilter extends true ? Tags : Tag|undefined} */ (\n              left[leftIndex]\n            )\n          }\n\n          matches.push(left[leftIndex])\n        } else {\n          next.push(left[leftIndex])\n        }\n      }\n\n      left = next\n    }\n\n    // If this is a filter, return the list.  If it’s a lookup, we didn’t find\n    // a match, so return `undefined`.\n    return /** @type {IsFilter extends true ? Tags : Tag|undefined} */ (\n      filter ? matches : undefined\n    )\n  }\n}\n\n/**\n * Basic Filtering (Section 3.3.1) matches a language priority list consisting\n * of basic language ranges (Section 2.1) to sets of language tags.\n *\n * @param {Tag|Tags} tags\n *   One or more BCP-47 tags.\n * @param {Range|Ranges|undefined} [ranges='*']\n *   One or more RFC 4647 ranges.\n * @returns {Tags}\n *   List of BCP-47 tags.\n */\nexport const basicFilter = factory(function (tag, range) {\n  return range === '*' || tag === range || tag.includes(range + '-')\n}, true)\n\n/**\n * Extended Filtering (Section 3.3.2) matches a language priority list\n * consisting of extended language ranges (Section 2.2) to sets of language\n * tags.\n *\n * @param {Tag|Tags} tags\n *   One or more BCP-47 tags.\n * @param {Range|Ranges|undefined} [ranges='*']\n *   One or more RFC 4647 ranges.\n * @returns {Tags}\n *   List of BCP-47 tags.\n */\nexport const extendedFilter = factory(function (tag, range) {\n  // 3.3.2.1\n  const left = tag.split('-')\n  const right = range.split('-')\n  let leftIndex = 0\n  let rightIndex = 0\n\n  // 3.3.2.2\n  if (right[rightIndex] !== '*' && left[leftIndex] !== right[rightIndex]) {\n    return false\n  }\n\n  leftIndex++\n  rightIndex++\n\n  // 3.3.2.3\n  while (rightIndex < right.length) {\n    // 3.3.2.3.A\n    if (right[rightIndex] === '*') {\n      rightIndex++\n      continue\n    }\n\n    // 3.3.2.3.B\n    if (!left[leftIndex]) return false\n\n    // 3.3.2.3.C\n    if (left[leftIndex] === right[rightIndex]) {\n      leftIndex++\n      rightIndex++\n      continue\n    }\n\n    // 3.3.2.3.D\n    if (left[leftIndex].length === 1) return false\n\n    // 3.3.2.3.E\n    leftIndex++\n  }\n\n  // 3.3.2.4\n  return true\n}, true)\n\n/**\n * Lookup (Section 3.4) matches a language priority list consisting of basic\n * language ranges to sets of language tags to find the one exact language tag\n * that best matches the range.\n *\n * @param {Tag|Tags} tags\n *   One or more BCP-47 tags.\n * @param {Range|Ranges|undefined} [ranges='*']\n *   One or more RFC 4647 ranges.\n * @returns {Tag|undefined}\n *   BCP-47 tag.\n */\nexport const lookup = factory(function (tag, range) {\n  let right = range\n\n  /* eslint-disable-next-line no-constant-condition */\n  while (true) {\n    if (right === '*' || tag === right) return true\n\n    let index = right.lastIndexOf('-')\n\n    if (index < 0) return false\n\n    if (right.charAt(index - 2) === '-') index -= 2\n\n    right = right.slice(0, index)\n  }\n}, false)\n\n/**\n * Validate tags or ranges, and cast them to arrays.\n *\n * @param {string|Array<string>} values\n * @param {string} name\n * @returns {Array<string>}\n */\nfunction cast(values, name) {\n  const value = values && typeof values === 'string' ? [values] : values\n\n  if (!value || typeof value !== 'object' || !('length' in value)) {\n    throw new Error(\n      'Invalid ' + name + ' `' + value + '`, expected non-empty string'\n    )\n  }\n\n  return value\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
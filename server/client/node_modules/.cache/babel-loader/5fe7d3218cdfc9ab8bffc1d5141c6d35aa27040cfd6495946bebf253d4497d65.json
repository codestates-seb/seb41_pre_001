{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n */\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding } from 'micromark-util-character';\n\n/** @type {Construct} */\nexport var codeIndented = {\n  name: 'codeIndented',\n  tokenize: tokenizeCodeIndented\n};\n/** @type {Construct} */\n\nvar indentedContent = {\n  tokenize: tokenizeIndentedContent,\n  partial: true\n};\n/** @type {Tokenizer} */\n\nfunction tokenizeCodeIndented(effects, ok, nok) {\n  var self = this;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('codeIndented');\n    return factorySpace(effects, afterStartPrefix, 'linePrefix', 4 + 1)(code);\n  }\n  /** @type {State} */\n\n  function afterStartPrefix(code) {\n    var tail = self.events[self.events.length - 1];\n    return tail && tail[1].type === 'linePrefix' && tail[2].sliceSerialize(tail[1], true).length >= 4 ? afterPrefix(code) : nok(code);\n  }\n  /** @type {State} */\n\n  function afterPrefix(code) {\n    if (code === null) {\n      return after(code);\n    }\n    if (markdownLineEnding(code)) {\n      return effects.attempt(indentedContent, afterPrefix, after)(code);\n    }\n    effects.enter('codeFlowValue');\n    return content(code);\n  }\n  /** @type {State} */\n\n  function content(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('codeFlowValue');\n      return afterPrefix(code);\n    }\n    effects.consume(code);\n    return content;\n  }\n  /** @type {State} */\n\n  function after(code) {\n    effects.exit('codeIndented');\n    return ok(code);\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeIndentedContent(effects, ok, nok) {\n  var self = this;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    // If this is a lazy line, it can’t be code.\n    if (self.parser.lazy[self.now().line]) {\n      return nok(code);\n    }\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding');\n      effects.consume(code);\n      effects.exit('lineEnding');\n      return start;\n    }\n    return factorySpace(effects, afterPrefix, 'linePrefix', 4 + 1)(code);\n  }\n  /** @type {State} */\n\n  function afterPrefix(code) {\n    var tail = self.events[self.events.length - 1];\n    return tail && tail[1].type === 'linePrefix' && tail[2].sliceSerialize(tail[1], true).length >= 4 ? ok(code) : markdownLineEnding(code) ? start(code) : nok(code);\n  }\n}","map":{"version":3,"names":["factorySpace","markdownLineEnding","codeIndented","name","tokenize","tokenizeCodeIndented","indentedContent","tokenizeIndentedContent","partial","effects","ok","nok","self","start","code","enter","afterStartPrefix","tail","events","length","type","sliceSerialize","afterPrefix","after","attempt","content","exit","consume","parser","lazy","now","line"],"sources":["/home/kty/workspace/seb41_pre_001/client/node_modules/micromark-core-commonmark/lib/code-indented.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const codeIndented = {\n  name: 'codeIndented',\n  tokenize: tokenizeCodeIndented\n}\n/** @type {Construct} */\n\nconst indentedContent = {\n  tokenize: tokenizeIndentedContent,\n  partial: true\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeCodeIndented(effects, ok, nok) {\n  const self = this\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('codeIndented')\n    return factorySpace(effects, afterStartPrefix, 'linePrefix', 4 + 1)(code)\n  }\n  /** @type {State} */\n\n  function afterStartPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return tail &&\n      tail[1].type === 'linePrefix' &&\n      tail[2].sliceSerialize(tail[1], true).length >= 4\n      ? afterPrefix(code)\n      : nok(code)\n  }\n  /** @type {State} */\n\n  function afterPrefix(code) {\n    if (code === null) {\n      return after(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.attempt(indentedContent, afterPrefix, after)(code)\n    }\n\n    effects.enter('codeFlowValue')\n    return content(code)\n  }\n  /** @type {State} */\n\n  function content(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('codeFlowValue')\n      return afterPrefix(code)\n    }\n\n    effects.consume(code)\n    return content\n  }\n  /** @type {State} */\n\n  function after(code) {\n    effects.exit('codeIndented')\n    return ok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeIndentedContent(effects, ok, nok) {\n  const self = this\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    // If this is a lazy line, it can’t be code.\n    if (self.parser.lazy[self.now().line]) {\n      return nok(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return start\n    }\n\n    return factorySpace(effects, afterPrefix, 'linePrefix', 4 + 1)(code)\n  }\n  /** @type {State} */\n\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return tail &&\n      tail[1].type === 'linePrefix' &&\n      tail[2].sliceSerialize(tail[1], true).length >= 4\n      ? ok(code)\n      : markdownLineEnding(code)\n      ? start(code)\n      : nok(code)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
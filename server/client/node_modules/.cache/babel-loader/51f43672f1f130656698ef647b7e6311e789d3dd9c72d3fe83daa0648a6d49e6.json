{"ast":null,"code":"import axios from 'axios';\nimport { getToken, logout } from './tokenHelper';\nconst instance = axios.create({\n  baseURL: process.env.REACT_APP_BASEURL\n});\ninstance.interceptors.request.use(config => {\n  const accessToken = getToken();\n  if (!accessToken) {\n    return config;\n  } else {\n    config.headers['Authorization'] = 'Bearer ' + accessToken;\n  }\n}, error => Promise.reject(error));\ninstance.interceptors.response.use(response => {\n  // Any status code that lie within the range of 2xx cause this function to trigger\n  // Do something with response data\n  return response;\n}, async error => {\n  // Any status codes that falls outside the range of 2xx cause this function to trigger\n  // Do something with response error\n  const {\n    response: errorResponse\n  } = error;\n  const originalRequest = error.config;\n  console.log(originalRequest);\n\n  //인증 에러 발생시\n  if (errorResponse.status === 401) {\n    logout();\n    //return await resetTokenAndReattemptRequest(error);\n    return false;\n  }\n  alert(errorResponse.status);\n  return Promise.reject(error);\n});\n\n//TODO 서버단 Refresh Token 구현X\n/* let isAlreadyFetchingAccessToken = false;\nlet subscribers = [];\n\nasync function resetTokenAndReattemptRequest(error) {\n  try {\n    const { response: errorResponse } = error;\n\n    // subscribers에 access token을 받은 이후 재요청할 함수 추가 (401로 실패했던)\n    // retryOriginalRequest는 pending 상태로 있다가\n    // access token을 받은 이후 onAccessTokenFetched가 호출될 때\n    // access token을 넘겨 다시 axios로 요청하고\n    // 결과값을 처음 요청했던 promise의 resolve로 settle시킨다.\n    const retryOriginalRequest = new Promise((resolve, reject) => {\n      addSubscriber(async (accessToken) => {\n        try {\n          errorResponse.config.headers['Authorization'] =\n            'Bearer ' + accessToken;\n          resolve(instance(errorResponse.config));\n        } catch (err) {\n          reject(err);\n        }\n      });\n    });\n\n    // refresh token을 이용해서 access token 요청\n    if (!isAlreadyFetchingAccessToken) {\n      isAlreadyFetchingAccessToken = true; // 문닫기 (한 번만 요청)\n\n      //const { data } = await postRefresh();\n      setToken(data.access);\n      //storeUserToken('refresh', data.refresh);\n\n      isAlreadyFetchingAccessToken = false; // 문열기 (초기화)\n\n      onAccessTokenFetched(data.access);\n    }\n\n    return retryOriginalRequest; // pending 됐다가 onAccessTokenFetched가 호출될 때 resolve\n  } catch (error) {\n    signOut();\n    return Promise.reject(error);\n  }\n}\n\nfunction addSubscriber(callback) {\n  subscribers.push(callback);\n}\n\nfunction onAccessTokenFetched(accessToken) {\n  subscribers.forEach((callback) => callback(accessToken));\n  subscribers = [];\n}\n */\n\nexport default instance;","map":{"version":3,"names":["axios","getToken","logout","instance","create","baseURL","process","env","REACT_APP_BASEURL","interceptors","request","use","config","accessToken","headers","error","Promise","reject","response","errorResponse","originalRequest","console","log","status","alert"],"sources":["/home/kty/workspace/seb41_pre_001/client/src/util/axiosHelper.js"],"sourcesContent":["import axios from 'axios';\nimport { getToken, logout } from './tokenHelper';\n\nconst instance = axios.create({\n  baseURL: process.env.REACT_APP_BASEURL,\n});\n\ninstance.interceptors.request.use(\n  (config) => {\n    const accessToken = getToken();\n    if (!accessToken) {\n      return config;\n    } else {\n      config.headers['Authorization'] = 'Bearer ' + accessToken;\n    }\n  },\n  (error) => Promise.reject(error)\n);\n\ninstance.interceptors.response.use(\n  (response) => {\n    // Any status code that lie within the range of 2xx cause this function to trigger\n    // Do something with response data\n    return response;\n  },\n  async (error) => {\n    // Any status codes that falls outside the range of 2xx cause this function to trigger\n    // Do something with response error\n    const { response: errorResponse } = error;\n\n    const originalRequest = error.config;\n    console.log(originalRequest);\n\n    //인증 에러 발생시\n    if (errorResponse.status === 401) {\n      logout();\n      //return await resetTokenAndReattemptRequest(error);\n      return false;\n    }\n\n    alert(errorResponse.status);\n    return Promise.reject(error);\n  }\n);\n\n//TODO 서버단 Refresh Token 구현X\n/* let isAlreadyFetchingAccessToken = false;\nlet subscribers = [];\n\nasync function resetTokenAndReattemptRequest(error) {\n  try {\n    const { response: errorResponse } = error;\n\n    // subscribers에 access token을 받은 이후 재요청할 함수 추가 (401로 실패했던)\n    // retryOriginalRequest는 pending 상태로 있다가\n    // access token을 받은 이후 onAccessTokenFetched가 호출될 때\n    // access token을 넘겨 다시 axios로 요청하고\n    // 결과값을 처음 요청했던 promise의 resolve로 settle시킨다.\n    const retryOriginalRequest = new Promise((resolve, reject) => {\n      addSubscriber(async (accessToken) => {\n        try {\n          errorResponse.config.headers['Authorization'] =\n            'Bearer ' + accessToken;\n          resolve(instance(errorResponse.config));\n        } catch (err) {\n          reject(err);\n        }\n      });\n    });\n\n    // refresh token을 이용해서 access token 요청\n    if (!isAlreadyFetchingAccessToken) {\n      isAlreadyFetchingAccessToken = true; // 문닫기 (한 번만 요청)\n\n      //const { data } = await postRefresh();\n      setToken(data.access);\n      //storeUserToken('refresh', data.refresh);\n\n      isAlreadyFetchingAccessToken = false; // 문열기 (초기화)\n\n      onAccessTokenFetched(data.access);\n    }\n\n    return retryOriginalRequest; // pending 됐다가 onAccessTokenFetched가 호출될 때 resolve\n  } catch (error) {\n    signOut();\n    return Promise.reject(error);\n  }\n}\n\nfunction addSubscriber(callback) {\n  subscribers.push(callback);\n}\n\nfunction onAccessTokenFetched(accessToken) {\n  subscribers.forEach((callback) => callback(accessToken));\n  subscribers = [];\n}\n */\n\nexport default instance;\n"],"mappings":"AAAA,OAAOA,KAAK,MAAM,OAAO;AACzB,SAASC,QAAQ,EAAEC,MAAM,QAAQ,eAAe;AAEhD,MAAMC,QAAQ,GAAGH,KAAK,CAACI,MAAM,CAAC;EAC5BC,OAAO,EAAEC,OAAO,CAACC,GAAG,CAACC;AACvB,CAAC,CAAC;AAEFL,QAAQ,CAACM,YAAY,CAACC,OAAO,CAACC,GAAG,CAC9BC,MAAM,IAAK;EACV,MAAMC,WAAW,GAAGZ,QAAQ,EAAE;EAC9B,IAAI,CAACY,WAAW,EAAE;IAChB,OAAOD,MAAM;EACf,CAAC,MAAM;IACLA,MAAM,CAACE,OAAO,CAAC,eAAe,CAAC,GAAG,SAAS,GAAGD,WAAW;EAC3D;AACF,CAAC,EACAE,KAAK,IAAKC,OAAO,CAACC,MAAM,CAACF,KAAK,CAAC,CACjC;AAEDZ,QAAQ,CAACM,YAAY,CAACS,QAAQ,CAACP,GAAG,CAC/BO,QAAQ,IAAK;EACZ;EACA;EACA,OAAOA,QAAQ;AACjB,CAAC,EACD,MAAOH,KAAK,IAAK;EACf;EACA;EACA,MAAM;IAAEG,QAAQ,EAAEC;EAAc,CAAC,GAAGJ,KAAK;EAEzC,MAAMK,eAAe,GAAGL,KAAK,CAACH,MAAM;EACpCS,OAAO,CAACC,GAAG,CAACF,eAAe,CAAC;;EAE5B;EACA,IAAID,aAAa,CAACI,MAAM,KAAK,GAAG,EAAE;IAChCrB,MAAM,EAAE;IACR;IACA,OAAO,KAAK;EACd;EAEAsB,KAAK,CAACL,aAAa,CAACI,MAAM,CAAC;EAC3B,OAAOP,OAAO,CAACC,MAAM,CAACF,KAAK,CAAC;AAC9B,CAAC,CACF;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAeZ,QAAQ"},"metadata":{},"sourceType":"module","externalDependencies":[]}
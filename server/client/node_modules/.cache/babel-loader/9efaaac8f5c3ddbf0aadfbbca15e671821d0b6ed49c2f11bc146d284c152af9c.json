{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\nimport { factoryDestination } from 'micromark-factory-destination';\nimport { factoryLabel } from 'micromark-factory-label';\nimport { factorySpace } from 'micromark-factory-space';\nimport { factoryTitle } from 'micromark-factory-title';\nimport { factoryWhitespace } from 'micromark-factory-whitespace';\nimport { normalizeIdentifier } from 'micromark-util-normalize-identifier';\nimport { markdownLineEnding, markdownLineEndingOrSpace } from 'micromark-util-character';\n\n/** @type {Construct} */\nexport var definition = {\n  name: 'definition',\n  tokenize: tokenizeDefinition\n};\n/** @type {Construct} */\n\nvar titleConstruct = {\n  tokenize: tokenizeTitle,\n  partial: true\n};\n/** @type {Tokenizer} */\n\nfunction tokenizeDefinition(effects, ok, nok) {\n  var self = this;\n  /** @type {string} */\n\n  var identifier;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('definition');\n    return factoryLabel.call(self, effects, labelAfter, nok, 'definitionLabel', 'definitionLabelMarker', 'definitionLabelString')(code);\n  }\n  /** @type {State} */\n\n  function labelAfter(code) {\n    identifier = normalizeIdentifier(self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1));\n    if (code === 58) {\n      effects.enter('definitionMarker');\n      effects.consume(code);\n      effects.exit('definitionMarker'); // Note: blank lines can’t exist in content.\n\n      return factoryWhitespace(effects, factoryDestination(effects, effects.attempt(titleConstruct, factorySpace(effects, after, 'whitespace'), factorySpace(effects, after, 'whitespace')), nok, 'definitionDestination', 'definitionDestinationLiteral', 'definitionDestinationLiteralMarker', 'definitionDestinationRaw', 'definitionDestinationString'));\n    }\n    return nok(code);\n  }\n  /** @type {State} */\n\n  function after(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('definition');\n      if (!self.parser.defined.includes(identifier)) {\n        self.parser.defined.push(identifier);\n      }\n      return ok(code);\n    }\n    return nok(code);\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeTitle(effects, ok, nok) {\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, before)(code) : nok(code);\n  }\n  /** @type {State} */\n\n  function before(code) {\n    if (code === 34 || code === 39 || code === 40) {\n      return factoryTitle(effects, factorySpace(effects, after, 'whitespace'), nok, 'definitionTitle', 'definitionTitleMarker', 'definitionTitleString')(code);\n    }\n    return nok(code);\n  }\n  /** @type {State} */\n\n  function after(code) {\n    return code === null || markdownLineEnding(code) ? ok(code) : nok(code);\n  }\n}","map":{"version":3,"names":["factoryDestination","factoryLabel","factorySpace","factoryTitle","factoryWhitespace","normalizeIdentifier","markdownLineEnding","markdownLineEndingOrSpace","definition","name","tokenize","tokenizeDefinition","titleConstruct","tokenizeTitle","partial","effects","ok","nok","self","identifier","start","code","enter","call","labelAfter","sliceSerialize","events","length","slice","consume","exit","attempt","after","parser","defined","includes","push","before"],"sources":["/home/kty/workspace/seb41_pre_001/client/node_modules/micromark-core-commonmark/lib/definition.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\nimport {factoryDestination} from 'micromark-factory-destination'\nimport {factoryLabel} from 'micromark-factory-label'\nimport {factorySpace} from 'micromark-factory-space'\nimport {factoryTitle} from 'micromark-factory-title'\nimport {factoryWhitespace} from 'micromark-factory-whitespace'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace\n} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const definition = {\n  name: 'definition',\n  tokenize: tokenizeDefinition\n}\n/** @type {Construct} */\n\nconst titleConstruct = {\n  tokenize: tokenizeTitle,\n  partial: true\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeDefinition(effects, ok, nok) {\n  const self = this\n  /** @type {string} */\n\n  let identifier\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('definition')\n    return factoryLabel.call(\n      self,\n      effects,\n      labelAfter,\n      nok,\n      'definitionLabel',\n      'definitionLabelMarker',\n      'definitionLabelString'\n    )(code)\n  }\n  /** @type {State} */\n\n  function labelAfter(code) {\n    identifier = normalizeIdentifier(\n      self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)\n    )\n\n    if (code === 58) {\n      effects.enter('definitionMarker')\n      effects.consume(code)\n      effects.exit('definitionMarker') // Note: blank lines can’t exist in content.\n\n      return factoryWhitespace(\n        effects,\n        factoryDestination(\n          effects,\n          effects.attempt(\n            titleConstruct,\n            factorySpace(effects, after, 'whitespace'),\n            factorySpace(effects, after, 'whitespace')\n          ),\n          nok,\n          'definitionDestination',\n          'definitionDestinationLiteral',\n          'definitionDestinationLiteralMarker',\n          'definitionDestinationRaw',\n          'definitionDestinationString'\n        )\n      )\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function after(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('definition')\n\n      if (!self.parser.defined.includes(identifier)) {\n        self.parser.defined.push(identifier)\n      }\n\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeTitle(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, before)(code)\n      : nok(code)\n  }\n  /** @type {State} */\n\n  function before(code) {\n    if (code === 34 || code === 39 || code === 40) {\n      return factoryTitle(\n        effects,\n        factorySpace(effects, after, 'whitespace'),\n        nok,\n        'definitionTitle',\n        'definitionTitleMarker',\n        'definitionTitleString'\n      )(code)\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function after(code) {\n    return code === null || markdownLineEnding(code) ? ok(code) : nok(code)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
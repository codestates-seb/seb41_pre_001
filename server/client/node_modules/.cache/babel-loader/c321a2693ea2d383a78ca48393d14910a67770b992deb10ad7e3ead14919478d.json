{"ast":null,"code":"// @ts-nocheck\n\n// This is a slimmed down version of `prism-core.js`, to remove globals,\n// document, workers, `util.encode`, `Token.stringify`\n\n// Private helper vars\nvar lang = /(?:^|\\s)lang(?:uage)?-([\\w-]+)(?=\\s|$)/i;\nvar uniqueId = 0;\n\n// The grammar object for plaintext\nvar plainTextGrammar = {};\nvar _ = {\n  /**\n   * A namespace for utility methods.\n   *\n   * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may\n   * change or disappear at any time.\n   *\n   * @namespace\n   * @memberof Prism\n   */\n  util: {\n    /**\n     * Returns the name of the type of the given value.\n     *\n     * @param {any} o\n     * @returns {string}\n     * @example\n     * type(null)      === 'Null'\n     * type(undefined) === 'Undefined'\n     * type(123)       === 'Number'\n     * type('foo')     === 'String'\n     * type(true)      === 'Boolean'\n     * type([1, 2])    === 'Array'\n     * type({})        === 'Object'\n     * type(String)    === 'Function'\n     * type(/abc+/)    === 'RegExp'\n     */\n    type: function (o) {\n      return Object.prototype.toString.call(o).slice(8, -1);\n    },\n    /**\n     * Returns a unique number for the given object. Later calls will still return the same number.\n     *\n     * @param {Object} obj\n     * @returns {number}\n     */\n    objId: function (obj) {\n      if (!obj['__id']) {\n        Object.defineProperty(obj, '__id', {\n          value: ++uniqueId\n        });\n      }\n      return obj['__id'];\n    },\n    /**\n     * Creates a deep clone of the given object.\n     *\n     * The main intended use of this function is to clone language definitions.\n     *\n     * @param {T} o\n     * @param {Record<number, any>} [visited]\n     * @returns {T}\n     * @template T\n     */\n    clone: function deepClone(o, visited) {\n      visited = visited || {};\n      var clone;\n      var id;\n      switch (_.util.type(o)) {\n        case 'Object':\n          id = _.util.objId(o);\n          if (visited[id]) {\n            return visited[id];\n          }\n          clone = /** @type {Record<string, any>} */{};\n          visited[id] = clone;\n          for (var key in o) {\n            if (o.hasOwnProperty(key)) {\n              clone[key] = deepClone(o[key], visited);\n            }\n          }\n          return (/** @type {any} */clone\n          );\n        case 'Array':\n          id = _.util.objId(o);\n          if (visited[id]) {\n            return visited[id];\n          }\n          clone = [];\n          visited[id] = clone;\n          o.forEach(function (v, i) {\n            clone[i] = deepClone(v, visited);\n          });\n          return (/** @type {any} */clone\n          );\n        default:\n          return o;\n      }\n    }\n  },\n  /**\n   * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.\n   *\n   * @namespace\n   * @memberof Prism\n   * @public\n   */\n  languages: {\n    /**\n     * The grammar for plain, unformatted text.\n     */\n    plain: plainTextGrammar,\n    plaintext: plainTextGrammar,\n    text: plainTextGrammar,\n    txt: plainTextGrammar,\n    /**\n     * Creates a deep copy of the language with the given id and appends the given tokens.\n     *\n     * If a token in `redef` also appears in the copied language, then the existing token in the copied language\n     * will be overwritten at its original position.\n     *\n     * ## Best practices\n     *\n     * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)\n     * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to\n     * understand the language definition because, normally, the order of tokens matters in Prism grammars.\n     *\n     * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.\n     * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.\n     *\n     * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.\n     * @param {Grammar} redef The new tokens to append.\n     * @returns {Grammar} The new language created.\n     * @public\n     * @example\n     * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {\n     *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token\n     *     // at its original position\n     *     'comment': { ... },\n     *     // CSS doesn't have a 'color' token, so this token will be appended\n     *     'color': /\\b(?:red|green|blue)\\b/\n     * });\n     */\n    extend: function (id, redef) {\n      var lang = _.util.clone(_.languages[id]);\n      for (var key in redef) {\n        lang[key] = redef[key];\n      }\n      return lang;\n    },\n    /**\n     * Inserts tokens _before_ another token in a language definition or any other grammar.\n     *\n     * ## Usage\n     *\n     * This helper method makes it easy to modify existing languages. For example, the CSS language definition\n     * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded\n     * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the\n     * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do\n     * this:\n     *\n     * ```js\n     * Prism.languages.markup.style = {\n     *     // token\n     * };\n     * ```\n     *\n     * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens\n     * before existing tokens. For the CSS example above, you would use it like this:\n     *\n     * ```js\n     * Prism.languages.insertBefore('markup', 'cdata', {\n     *     'style': {\n     *         // token\n     *     }\n     * });\n     * ```\n     *\n     * ## Special cases\n     *\n     * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar\n     * will be ignored.\n     *\n     * This behavior can be used to insert tokens after `before`:\n     *\n     * ```js\n     * Prism.languages.insertBefore('markup', 'comment', {\n     *     'comment': Prism.languages.markup.comment,\n     *     // tokens after 'comment'\n     * });\n     * ```\n     *\n     * ## Limitations\n     *\n     * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object\n     * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave\n     * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily\n     * deleting properties which is necessary to insert at arbitrary positions.\n     *\n     * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.\n     * Instead, it will create a new object and replace all references to the target object with the new one. This\n     * can be done without temporarily deleting properties, so the iteration order is well-defined.\n     *\n     * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if\n     * you hold the target object in a variable, then the value of the variable will not change.\n     *\n     * ```js\n     * var oldMarkup = Prism.languages.markup;\n     * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });\n     *\n     * assert(oldMarkup !== Prism.languages.markup);\n     * assert(newMarkup === Prism.languages.markup);\n     * ```\n     *\n     * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the\n     * object to be modified.\n     * @param {string} before The key to insert before.\n     * @param {Grammar} insert An object containing the key-value pairs to be inserted.\n     * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the\n     * object to be modified.\n     *\n     * Defaults to `Prism.languages`.\n     * @returns {Grammar} The new grammar object.\n     * @public\n     */\n    insertBefore: function (inside, before, insert, root) {\n      root = root || /** @type {any} */_.languages;\n      var grammar = root[inside];\n      /** @type {Grammar} */\n      var ret = {};\n      for (var token in grammar) {\n        if (grammar.hasOwnProperty(token)) {\n          if (token == before) {\n            for (var newToken in insert) {\n              if (insert.hasOwnProperty(newToken)) {\n                ret[newToken] = insert[newToken];\n              }\n            }\n          }\n\n          // Do not insert token which also occur in insert. See #1525\n          if (!insert.hasOwnProperty(token)) {\n            ret[token] = grammar[token];\n          }\n        }\n      }\n      var old = root[inside];\n      root[inside] = ret;\n\n      // Update references in other language definitions\n      _.languages.DFS(_.languages, function (key, value) {\n        if (value === old && key != inside) {\n          this[key] = ret;\n        }\n      });\n      return ret;\n    },\n    // Traverse a language definition with Depth First Search\n    DFS: function DFS(o, callback, type, visited) {\n      visited = visited || {};\n      var objId = _.util.objId;\n      for (var i in o) {\n        if (o.hasOwnProperty(i)) {\n          callback.call(o, i, o[i], type || i);\n          var property = o[i];\n          var propertyType = _.util.type(property);\n          if (propertyType === 'Object' && !visited[objId(property)]) {\n            visited[objId(property)] = true;\n            DFS(property, callback, null, visited);\n          } else if (propertyType === 'Array' && !visited[objId(property)]) {\n            visited[objId(property)] = true;\n            DFS(property, callback, i, visited);\n          }\n        }\n      }\n    }\n  },\n  plugins: {},\n  /**\n   * Low-level function, only use if you know what you’re doing. It accepts a string of text as input\n   * and the language definitions to use, and returns a string with the HTML produced.\n   *\n   * The following hooks will be run:\n   * 1. `before-tokenize`\n   * 2. `after-tokenize`\n   * 3. `wrap`: On each {@link Token}.\n   *\n   * @param {string} text A string with the code to be highlighted.\n   * @param {Grammar} grammar An object containing the tokens to use.\n   *\n   * Usually a language definition like `Prism.languages.markup`.\n   * @param {string} language The name of the language definition passed to `grammar`.\n   * @returns {string} The highlighted HTML.\n   * @memberof Prism\n   * @public\n   * @example\n   * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');\n   */\n  highlight: function (text, grammar, language) {\n    var env = {\n      code: text,\n      grammar: grammar,\n      language: language\n    };\n    _.hooks.run('before-tokenize', env);\n    if (!env.grammar) {\n      throw new Error('The language \"' + env.language + '\" has no grammar.');\n    }\n    env.tokens = _.tokenize(env.code, env.grammar);\n    _.hooks.run('after-tokenize', env);\n    return Token.stringify(_.util.encode(env.tokens), env.language);\n  },\n  /**\n   * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input\n   * and the language definitions to use, and returns an array with the tokenized code.\n   *\n   * When the language definition includes nested tokens, the function is called recursively on each of these tokens.\n   *\n   * This method could be useful in other contexts as well, as a very crude parser.\n   *\n   * @param {string} text A string with the code to be highlighted.\n   * @param {Grammar} grammar An object containing the tokens to use.\n   *\n   * Usually a language definition like `Prism.languages.markup`.\n   * @returns {TokenStream} An array of strings and tokens, a token stream.\n   * @memberof Prism\n   * @public\n   * @example\n   * let code = `var foo = 0;`;\n   * let tokens = Prism.tokenize(code, Prism.languages.javascript);\n   * tokens.forEach(token => {\n   *     if (token instanceof Prism.Token && token.type === 'number') {\n   *         console.log(`Found numeric literal: ${token.content}`);\n   *     }\n   * });\n   */\n  tokenize: function (text, grammar) {\n    var rest = grammar.rest;\n    if (rest) {\n      for (var token in rest) {\n        grammar[token] = rest[token];\n      }\n      delete grammar.rest;\n    }\n    var tokenList = new LinkedList();\n    addAfter(tokenList, tokenList.head, text);\n    matchGrammar(text, tokenList, grammar, tokenList.head, 0);\n    return toArray(tokenList);\n  },\n  /**\n   * @namespace\n   * @memberof Prism\n   * @public\n   */\n  hooks: {\n    all: {},\n    /**\n     * Adds the given callback to the list of callbacks for the given hook.\n     *\n     * The callback will be invoked when the hook it is registered for is run.\n     * Hooks are usually directly run by a highlight function but you can also run hooks yourself.\n     *\n     * One callback function can be registered to multiple hooks and the same hook multiple times.\n     *\n     * @param {string} name The name of the hook.\n     * @param {HookCallback} callback The callback function which is given environment variables.\n     * @public\n     */\n    add: function (name, callback) {\n      var hooks = _.hooks.all;\n      hooks[name] = hooks[name] || [];\n      hooks[name].push(callback);\n    },\n    /**\n     * Runs a hook invoking all registered callbacks with the given environment variables.\n     *\n     * Callbacks will be invoked synchronously and in the order in which they were registered.\n     *\n     * @param {string} name The name of the hook.\n     * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.\n     * @public\n     */\n    run: function (name, env) {\n      var callbacks = _.hooks.all[name];\n      if (!callbacks || !callbacks.length) {\n        return;\n      }\n      for (var i = 0, callback; callback = callbacks[i++];) {\n        callback(env);\n      }\n    }\n  },\n  Token: Token\n};\n\n// Typescript note:\n// The following can be used to import the Token type in JSDoc:\n//\n//   @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n\n/**\n * Creates a new token.\n *\n * @param {string} type See {@link Token#type type}\n * @param {string | TokenStream} content See {@link Token#content content}\n * @param {string|string[]} [alias] The alias(es) of the token.\n * @param {string} [matchedStr=\"\"] A copy of the full string this token was created from.\n * @class\n * @global\n * @public\n */\nfunction Token(type, content, alias, matchedStr) {\n  /**\n   * The type of the token.\n   *\n   * This is usually the key of a pattern in a {@link Grammar}.\n   *\n   * @type {string}\n   * @see GrammarToken\n   * @public\n   */\n  this.type = type;\n  /**\n   * The strings or tokens contained by this token.\n   *\n   * This will be a token stream if the pattern matched also defined an `inside` grammar.\n   *\n   * @type {string | TokenStream}\n   * @public\n   */\n  this.content = content;\n  /**\n   * The alias(es) of the token.\n   *\n   * @type {string|string[]}\n   * @see GrammarToken\n   * @public\n   */\n  this.alias = alias;\n  // Copy of the full string this token was created from\n  this.length = (matchedStr || '').length | 0;\n}\n\n/**\n * A token stream is an array of strings and {@link Token Token} objects.\n *\n * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process\n * them.\n *\n * 1. No adjacent strings.\n * 2. No empty strings.\n *\n *    The only exception here is the token stream that only contains the empty string and nothing else.\n *\n * @typedef {Array<string | Token>} TokenStream\n * @global\n * @public\n */\n\n/**\n * @param {RegExp} pattern\n * @param {number} pos\n * @param {string} text\n * @param {boolean} lookbehind\n * @returns {RegExpExecArray | null}\n */\nfunction matchPattern(pattern, pos, text, lookbehind) {\n  pattern.lastIndex = pos;\n  var match = pattern.exec(text);\n  if (match && lookbehind && match[1]) {\n    // change the match to remove the text matched by the Prism lookbehind group\n    var lookbehindLength = match[1].length;\n    match.index += lookbehindLength;\n    match[0] = match[0].slice(lookbehindLength);\n  }\n  return match;\n}\n\n/**\n * @param {string} text\n * @param {LinkedList<string | Token>} tokenList\n * @param {any} grammar\n * @param {LinkedListNode<string | Token>} startNode\n * @param {number} startPos\n * @param {RematchOptions} [rematch]\n * @returns {void}\n * @private\n *\n * @typedef RematchOptions\n * @property {string} cause\n * @property {number} reach\n */\nfunction matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {\n  for (var token in grammar) {\n    if (!grammar.hasOwnProperty(token) || !grammar[token]) {\n      continue;\n    }\n    var patterns = grammar[token];\n    patterns = Array.isArray(patterns) ? patterns : [patterns];\n    for (var j = 0; j < patterns.length; ++j) {\n      if (rematch && rematch.cause == token + ',' + j) {\n        return;\n      }\n      var patternObj = patterns[j];\n      var inside = patternObj.inside;\n      var lookbehind = !!patternObj.lookbehind;\n      var greedy = !!patternObj.greedy;\n      var alias = patternObj.alias;\n      if (greedy && !patternObj.pattern.global) {\n        // Without the global flag, lastIndex won't work\n        var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];\n        patternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');\n      }\n\n      /** @type {RegExp} */\n      var pattern = patternObj.pattern || patternObj;\n      for (\n      // iterate the token list and keep track of the current token/string position\n      var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {\n        if (rematch && pos >= rematch.reach) {\n          break;\n        }\n        var str = currentNode.value;\n        if (tokenList.length > text.length) {\n          // Something went terribly wrong, ABORT, ABORT!\n          return;\n        }\n        if (str instanceof Token) {\n          continue;\n        }\n        var removeCount = 1; // this is the to parameter of removeBetween\n        var match;\n        if (greedy) {\n          match = matchPattern(pattern, pos, text, lookbehind);\n          if (!match || match.index >= text.length) {\n            break;\n          }\n          var from = match.index;\n          var to = match.index + match[0].length;\n          var p = pos;\n\n          // find the node that contains the match\n          p += currentNode.value.length;\n          while (from >= p) {\n            currentNode = currentNode.next;\n            p += currentNode.value.length;\n          }\n          // adjust pos (and p)\n          p -= currentNode.value.length;\n          pos = p;\n\n          // the current node is a Token, then the match starts inside another Token, which is invalid\n          if (currentNode.value instanceof Token) {\n            continue;\n          }\n\n          // find the last node which is affected by this match\n          for (var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === 'string'); k = k.next) {\n            removeCount++;\n            p += k.value.length;\n          }\n          removeCount--;\n\n          // replace with the new match\n          str = text.slice(pos, p);\n          match.index -= pos;\n        } else {\n          match = matchPattern(pattern, 0, str, lookbehind);\n          if (!match) {\n            continue;\n          }\n        }\n\n        // eslint-disable-next-line no-redeclare\n        var from = match.index;\n        var matchStr = match[0];\n        var before = str.slice(0, from);\n        var after = str.slice(from + matchStr.length);\n        var reach = pos + str.length;\n        if (rematch && reach > rematch.reach) {\n          rematch.reach = reach;\n        }\n        var removeFrom = currentNode.prev;\n        if (before) {\n          removeFrom = addAfter(tokenList, removeFrom, before);\n          pos += before.length;\n        }\n        removeRange(tokenList, removeFrom, removeCount);\n        var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);\n        currentNode = addAfter(tokenList, removeFrom, wrapped);\n        if (after) {\n          addAfter(tokenList, currentNode, after);\n        }\n        if (removeCount > 1) {\n          // at least one Token object was removed, so we have to do some rematching\n          // this can only happen if the current pattern is greedy\n\n          /** @type {RematchOptions} */\n          var nestedRematch = {\n            cause: token + ',' + j,\n            reach: reach\n          };\n          matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);\n\n          // the reach might have been extended because of the rematching\n          if (rematch && nestedRematch.reach > rematch.reach) {\n            rematch.reach = nestedRematch.reach;\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * @typedef LinkedListNode\n * @property {T} value\n * @property {LinkedListNode<T> | null} prev The previous node.\n * @property {LinkedListNode<T> | null} next The next node.\n * @template T\n * @private\n */\n\n/**\n * @template T\n * @private\n */\nfunction LinkedList() {\n  /** @type {LinkedListNode<T>} */\n  var head = {\n    value: null,\n    prev: null,\n    next: null\n  };\n  /** @type {LinkedListNode<T>} */\n  var tail = {\n    value: null,\n    prev: head,\n    next: null\n  };\n  head.next = tail;\n\n  /** @type {LinkedListNode<T>} */\n  this.head = head;\n  /** @type {LinkedListNode<T>} */\n  this.tail = tail;\n  this.length = 0;\n}\n\n/**\n * Adds a new node with the given value to the list.\n *\n * @param {LinkedList<T>} list\n * @param {LinkedListNode<T>} node\n * @param {T} value\n * @returns {LinkedListNode<T>} The added node.\n * @template T\n */\nfunction addAfter(list, node, value) {\n  // assumes that node != list.tail && values.length >= 0\n  var next = node.next;\n  var newNode = {\n    value: value,\n    prev: node,\n    next: next\n  };\n  node.next = newNode;\n  next.prev = newNode;\n  list.length++;\n  return newNode;\n}\n/**\n * Removes `count` nodes after the given node. The given node will not be removed.\n *\n * @param {LinkedList<T>} list\n * @param {LinkedListNode<T>} node\n * @param {number} count\n * @template T\n */\nfunction removeRange(list, node, count) {\n  var next = node.next;\n  for (var i = 0; i < count && next !== list.tail; i++) {\n    next = next.next;\n  }\n  node.next = next;\n  next.prev = node;\n  list.length -= i;\n}\n/**\n * @param {LinkedList<T>} list\n * @returns {T[]}\n * @template T\n */\nfunction toArray(list) {\n  var array = [];\n  var node = list.head.next;\n  while (node !== list.tail) {\n    array.push(node.value);\n    node = node.next;\n  }\n  return array;\n}\nexport const Prism = _;\n\n// some additional documentation/types\n\n/**\n * The expansion of a simple `RegExp` literal to support additional properties.\n *\n * @typedef GrammarToken\n * @property {RegExp} pattern The regular expression of the token.\n * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)\n * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.\n * @property {boolean} [greedy=false] Whether the token is greedy.\n * @property {string|string[]} [alias] An optional alias or list of aliases.\n * @property {Grammar} [inside] The nested grammar of this token.\n *\n * The `inside` grammar will be used to tokenize the text value of each token of this kind.\n *\n * This can be used to make nested and even recursive language definitions.\n *\n * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into\n * each another.\n * @global\n * @public\n */\n\n/**\n * @typedef Grammar\n * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}\n * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.\n * @global\n * @public\n */\n\n/**\n * A function which will invoked after an element was successfully highlighted.\n *\n * @callback HighlightCallback\n * @param {Element} element The element successfully highlighted.\n * @returns {void}\n * @global\n * @public\n */\n\n/**\n * @callback HookCallback\n * @param {Object<string, any>} env The environment variables of the hook.\n * @returns {void}\n * @global\n * @public\n */","map":{"version":3,"names":["lang","uniqueId","plainTextGrammar","_","util","type","o","Object","prototype","toString","call","slice","objId","obj","defineProperty","value","clone","deepClone","visited","id","key","hasOwnProperty","forEach","v","i","languages","plain","plaintext","text","txt","extend","redef","insertBefore","inside","before","insert","root","grammar","ret","token","newToken","old","DFS","callback","property","propertyType","plugins","highlight","language","env","code","hooks","run","Error","tokens","tokenize","Token","stringify","encode","rest","tokenList","LinkedList","addAfter","head","matchGrammar","toArray","all","add","name","push","callbacks","length","content","alias","matchedStr","matchPattern","pattern","pos","lookbehind","lastIndex","match","exec","lookbehindLength","index","startNode","startPos","rematch","patterns","Array","isArray","j","cause","patternObj","greedy","global","flags","RegExp","source","currentNode","next","tail","reach","str","removeCount","from","to","p","k","matchStr","after","removeFrom","prev","removeRange","wrapped","nestedRematch","list","node","newNode","count","array","Prism"],"sources":["/home/kty/workspace/seb41_pre_001/client/node_modules/refractor/lib/prism-core.js"],"sourcesContent":["// @ts-nocheck\n\n// This is a slimmed down version of `prism-core.js`, to remove globals,\n// document, workers, `util.encode`, `Token.stringify`\n\n// Private helper vars\nvar lang = /(?:^|\\s)lang(?:uage)?-([\\w-]+)(?=\\s|$)/i\nvar uniqueId = 0\n\n// The grammar object for plaintext\nvar plainTextGrammar = {}\n\nvar _ = {\n  /**\n   * A namespace for utility methods.\n   *\n   * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may\n   * change or disappear at any time.\n   *\n   * @namespace\n   * @memberof Prism\n   */\n  util: {\n    /**\n     * Returns the name of the type of the given value.\n     *\n     * @param {any} o\n     * @returns {string}\n     * @example\n     * type(null)      === 'Null'\n     * type(undefined) === 'Undefined'\n     * type(123)       === 'Number'\n     * type('foo')     === 'String'\n     * type(true)      === 'Boolean'\n     * type([1, 2])    === 'Array'\n     * type({})        === 'Object'\n     * type(String)    === 'Function'\n     * type(/abc+/)    === 'RegExp'\n     */\n    type: function (o) {\n      return Object.prototype.toString.call(o).slice(8, -1)\n    },\n\n    /**\n     * Returns a unique number for the given object. Later calls will still return the same number.\n     *\n     * @param {Object} obj\n     * @returns {number}\n     */\n    objId: function (obj) {\n      if (!obj['__id']) {\n        Object.defineProperty(obj, '__id', {value: ++uniqueId})\n      }\n      return obj['__id']\n    },\n\n    /**\n     * Creates a deep clone of the given object.\n     *\n     * The main intended use of this function is to clone language definitions.\n     *\n     * @param {T} o\n     * @param {Record<number, any>} [visited]\n     * @returns {T}\n     * @template T\n     */\n    clone: function deepClone(o, visited) {\n      visited = visited || {}\n\n      var clone\n      var id\n      switch (_.util.type(o)) {\n        case 'Object':\n          id = _.util.objId(o)\n          if (visited[id]) {\n            return visited[id]\n          }\n          clone = /** @type {Record<string, any>} */ ({})\n          visited[id] = clone\n\n          for (var key in o) {\n            if (o.hasOwnProperty(key)) {\n              clone[key] = deepClone(o[key], visited)\n            }\n          }\n\n          return /** @type {any} */ (clone)\n\n        case 'Array':\n          id = _.util.objId(o)\n          if (visited[id]) {\n            return visited[id]\n          }\n          clone = []\n          visited[id] = clone\n\n          o.forEach(function (v, i) {\n            clone[i] = deepClone(v, visited)\n          })\n\n          return /** @type {any} */ (clone)\n\n        default:\n          return o\n      }\n    }\n  },\n\n  /**\n   * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.\n   *\n   * @namespace\n   * @memberof Prism\n   * @public\n   */\n  languages: {\n    /**\n     * The grammar for plain, unformatted text.\n     */\n    plain: plainTextGrammar,\n    plaintext: plainTextGrammar,\n    text: plainTextGrammar,\n    txt: plainTextGrammar,\n\n    /**\n     * Creates a deep copy of the language with the given id and appends the given tokens.\n     *\n     * If a token in `redef` also appears in the copied language, then the existing token in the copied language\n     * will be overwritten at its original position.\n     *\n     * ## Best practices\n     *\n     * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)\n     * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to\n     * understand the language definition because, normally, the order of tokens matters in Prism grammars.\n     *\n     * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.\n     * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.\n     *\n     * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.\n     * @param {Grammar} redef The new tokens to append.\n     * @returns {Grammar} The new language created.\n     * @public\n     * @example\n     * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {\n     *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token\n     *     // at its original position\n     *     'comment': { ... },\n     *     // CSS doesn't have a 'color' token, so this token will be appended\n     *     'color': /\\b(?:red|green|blue)\\b/\n     * });\n     */\n    extend: function (id, redef) {\n      var lang = _.util.clone(_.languages[id])\n\n      for (var key in redef) {\n        lang[key] = redef[key]\n      }\n\n      return lang\n    },\n\n    /**\n     * Inserts tokens _before_ another token in a language definition or any other grammar.\n     *\n     * ## Usage\n     *\n     * This helper method makes it easy to modify existing languages. For example, the CSS language definition\n     * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded\n     * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the\n     * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do\n     * this:\n     *\n     * ```js\n     * Prism.languages.markup.style = {\n     *     // token\n     * };\n     * ```\n     *\n     * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens\n     * before existing tokens. For the CSS example above, you would use it like this:\n     *\n     * ```js\n     * Prism.languages.insertBefore('markup', 'cdata', {\n     *     'style': {\n     *         // token\n     *     }\n     * });\n     * ```\n     *\n     * ## Special cases\n     *\n     * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar\n     * will be ignored.\n     *\n     * This behavior can be used to insert tokens after `before`:\n     *\n     * ```js\n     * Prism.languages.insertBefore('markup', 'comment', {\n     *     'comment': Prism.languages.markup.comment,\n     *     // tokens after 'comment'\n     * });\n     * ```\n     *\n     * ## Limitations\n     *\n     * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object\n     * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave\n     * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily\n     * deleting properties which is necessary to insert at arbitrary positions.\n     *\n     * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.\n     * Instead, it will create a new object and replace all references to the target object with the new one. This\n     * can be done without temporarily deleting properties, so the iteration order is well-defined.\n     *\n     * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if\n     * you hold the target object in a variable, then the value of the variable will not change.\n     *\n     * ```js\n     * var oldMarkup = Prism.languages.markup;\n     * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });\n     *\n     * assert(oldMarkup !== Prism.languages.markup);\n     * assert(newMarkup === Prism.languages.markup);\n     * ```\n     *\n     * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the\n     * object to be modified.\n     * @param {string} before The key to insert before.\n     * @param {Grammar} insert An object containing the key-value pairs to be inserted.\n     * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the\n     * object to be modified.\n     *\n     * Defaults to `Prism.languages`.\n     * @returns {Grammar} The new grammar object.\n     * @public\n     */\n    insertBefore: function (inside, before, insert, root) {\n      root = root || /** @type {any} */ (_.languages)\n      var grammar = root[inside]\n      /** @type {Grammar} */\n      var ret = {}\n\n      for (var token in grammar) {\n        if (grammar.hasOwnProperty(token)) {\n          if (token == before) {\n            for (var newToken in insert) {\n              if (insert.hasOwnProperty(newToken)) {\n                ret[newToken] = insert[newToken]\n              }\n            }\n          }\n\n          // Do not insert token which also occur in insert. See #1525\n          if (!insert.hasOwnProperty(token)) {\n            ret[token] = grammar[token]\n          }\n        }\n      }\n\n      var old = root[inside]\n      root[inside] = ret\n\n      // Update references in other language definitions\n      _.languages.DFS(_.languages, function (key, value) {\n        if (value === old && key != inside) {\n          this[key] = ret\n        }\n      })\n\n      return ret\n    },\n\n    // Traverse a language definition with Depth First Search\n    DFS: function DFS(o, callback, type, visited) {\n      visited = visited || {}\n\n      var objId = _.util.objId\n\n      for (var i in o) {\n        if (o.hasOwnProperty(i)) {\n          callback.call(o, i, o[i], type || i)\n\n          var property = o[i]\n          var propertyType = _.util.type(property)\n\n          if (propertyType === 'Object' && !visited[objId(property)]) {\n            visited[objId(property)] = true\n            DFS(property, callback, null, visited)\n          } else if (propertyType === 'Array' && !visited[objId(property)]) {\n            visited[objId(property)] = true\n            DFS(property, callback, i, visited)\n          }\n        }\n      }\n    }\n  },\n\n  plugins: {},\n\n  /**\n   * Low-level function, only use if you know what you’re doing. It accepts a string of text as input\n   * and the language definitions to use, and returns a string with the HTML produced.\n   *\n   * The following hooks will be run:\n   * 1. `before-tokenize`\n   * 2. `after-tokenize`\n   * 3. `wrap`: On each {@link Token}.\n   *\n   * @param {string} text A string with the code to be highlighted.\n   * @param {Grammar} grammar An object containing the tokens to use.\n   *\n   * Usually a language definition like `Prism.languages.markup`.\n   * @param {string} language The name of the language definition passed to `grammar`.\n   * @returns {string} The highlighted HTML.\n   * @memberof Prism\n   * @public\n   * @example\n   * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');\n   */\n  highlight: function (text, grammar, language) {\n    var env = {\n      code: text,\n      grammar: grammar,\n      language: language\n    }\n    _.hooks.run('before-tokenize', env)\n    if (!env.grammar) {\n      throw new Error('The language \"' + env.language + '\" has no grammar.')\n    }\n    env.tokens = _.tokenize(env.code, env.grammar)\n    _.hooks.run('after-tokenize', env)\n    return Token.stringify(_.util.encode(env.tokens), env.language)\n  },\n\n  /**\n   * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input\n   * and the language definitions to use, and returns an array with the tokenized code.\n   *\n   * When the language definition includes nested tokens, the function is called recursively on each of these tokens.\n   *\n   * This method could be useful in other contexts as well, as a very crude parser.\n   *\n   * @param {string} text A string with the code to be highlighted.\n   * @param {Grammar} grammar An object containing the tokens to use.\n   *\n   * Usually a language definition like `Prism.languages.markup`.\n   * @returns {TokenStream} An array of strings and tokens, a token stream.\n   * @memberof Prism\n   * @public\n   * @example\n   * let code = `var foo = 0;`;\n   * let tokens = Prism.tokenize(code, Prism.languages.javascript);\n   * tokens.forEach(token => {\n   *     if (token instanceof Prism.Token && token.type === 'number') {\n   *         console.log(`Found numeric literal: ${token.content}`);\n   *     }\n   * });\n   */\n  tokenize: function (text, grammar) {\n    var rest = grammar.rest\n    if (rest) {\n      for (var token in rest) {\n        grammar[token] = rest[token]\n      }\n\n      delete grammar.rest\n    }\n\n    var tokenList = new LinkedList()\n    addAfter(tokenList, tokenList.head, text)\n\n    matchGrammar(text, tokenList, grammar, tokenList.head, 0)\n\n    return toArray(tokenList)\n  },\n\n  /**\n   * @namespace\n   * @memberof Prism\n   * @public\n   */\n  hooks: {\n    all: {},\n\n    /**\n     * Adds the given callback to the list of callbacks for the given hook.\n     *\n     * The callback will be invoked when the hook it is registered for is run.\n     * Hooks are usually directly run by a highlight function but you can also run hooks yourself.\n     *\n     * One callback function can be registered to multiple hooks and the same hook multiple times.\n     *\n     * @param {string} name The name of the hook.\n     * @param {HookCallback} callback The callback function which is given environment variables.\n     * @public\n     */\n    add: function (name, callback) {\n      var hooks = _.hooks.all\n\n      hooks[name] = hooks[name] || []\n\n      hooks[name].push(callback)\n    },\n\n    /**\n     * Runs a hook invoking all registered callbacks with the given environment variables.\n     *\n     * Callbacks will be invoked synchronously and in the order in which they were registered.\n     *\n     * @param {string} name The name of the hook.\n     * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.\n     * @public\n     */\n    run: function (name, env) {\n      var callbacks = _.hooks.all[name]\n\n      if (!callbacks || !callbacks.length) {\n        return\n      }\n\n      for (var i = 0, callback; (callback = callbacks[i++]); ) {\n        callback(env)\n      }\n    }\n  },\n\n  Token: Token\n}\n\n// Typescript note:\n// The following can be used to import the Token type in JSDoc:\n//\n//   @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n\n/**\n * Creates a new token.\n *\n * @param {string} type See {@link Token#type type}\n * @param {string | TokenStream} content See {@link Token#content content}\n * @param {string|string[]} [alias] The alias(es) of the token.\n * @param {string} [matchedStr=\"\"] A copy of the full string this token was created from.\n * @class\n * @global\n * @public\n */\nfunction Token(type, content, alias, matchedStr) {\n  /**\n   * The type of the token.\n   *\n   * This is usually the key of a pattern in a {@link Grammar}.\n   *\n   * @type {string}\n   * @see GrammarToken\n   * @public\n   */\n  this.type = type\n  /**\n   * The strings or tokens contained by this token.\n   *\n   * This will be a token stream if the pattern matched also defined an `inside` grammar.\n   *\n   * @type {string | TokenStream}\n   * @public\n   */\n  this.content = content\n  /**\n   * The alias(es) of the token.\n   *\n   * @type {string|string[]}\n   * @see GrammarToken\n   * @public\n   */\n  this.alias = alias\n  // Copy of the full string this token was created from\n  this.length = (matchedStr || '').length | 0\n}\n\n/**\n * A token stream is an array of strings and {@link Token Token} objects.\n *\n * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process\n * them.\n *\n * 1. No adjacent strings.\n * 2. No empty strings.\n *\n *    The only exception here is the token stream that only contains the empty string and nothing else.\n *\n * @typedef {Array<string | Token>} TokenStream\n * @global\n * @public\n */\n\n/**\n * @param {RegExp} pattern\n * @param {number} pos\n * @param {string} text\n * @param {boolean} lookbehind\n * @returns {RegExpExecArray | null}\n */\nfunction matchPattern(pattern, pos, text, lookbehind) {\n  pattern.lastIndex = pos\n  var match = pattern.exec(text)\n  if (match && lookbehind && match[1]) {\n    // change the match to remove the text matched by the Prism lookbehind group\n    var lookbehindLength = match[1].length\n    match.index += lookbehindLength\n    match[0] = match[0].slice(lookbehindLength)\n  }\n  return match\n}\n\n/**\n * @param {string} text\n * @param {LinkedList<string | Token>} tokenList\n * @param {any} grammar\n * @param {LinkedListNode<string | Token>} startNode\n * @param {number} startPos\n * @param {RematchOptions} [rematch]\n * @returns {void}\n * @private\n *\n * @typedef RematchOptions\n * @property {string} cause\n * @property {number} reach\n */\nfunction matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {\n  for (var token in grammar) {\n    if (!grammar.hasOwnProperty(token) || !grammar[token]) {\n      continue\n    }\n\n    var patterns = grammar[token]\n    patterns = Array.isArray(patterns) ? patterns : [patterns]\n\n    for (var j = 0; j < patterns.length; ++j) {\n      if (rematch && rematch.cause == token + ',' + j) {\n        return\n      }\n\n      var patternObj = patterns[j]\n      var inside = patternObj.inside\n      var lookbehind = !!patternObj.lookbehind\n      var greedy = !!patternObj.greedy\n      var alias = patternObj.alias\n\n      if (greedy && !patternObj.pattern.global) {\n        // Without the global flag, lastIndex won't work\n        var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0]\n        patternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g')\n      }\n\n      /** @type {RegExp} */\n      var pattern = patternObj.pattern || patternObj\n\n      for (\n        // iterate the token list and keep track of the current token/string position\n        var currentNode = startNode.next, pos = startPos;\n        currentNode !== tokenList.tail;\n        pos += currentNode.value.length, currentNode = currentNode.next\n      ) {\n        if (rematch && pos >= rematch.reach) {\n          break\n        }\n\n        var str = currentNode.value\n\n        if (tokenList.length > text.length) {\n          // Something went terribly wrong, ABORT, ABORT!\n          return\n        }\n\n        if (str instanceof Token) {\n          continue\n        }\n\n        var removeCount = 1 // this is the to parameter of removeBetween\n        var match\n\n        if (greedy) {\n          match = matchPattern(pattern, pos, text, lookbehind)\n          if (!match || match.index >= text.length) {\n            break\n          }\n\n          var from = match.index\n          var to = match.index + match[0].length\n          var p = pos\n\n          // find the node that contains the match\n          p += currentNode.value.length\n          while (from >= p) {\n            currentNode = currentNode.next\n            p += currentNode.value.length\n          }\n          // adjust pos (and p)\n          p -= currentNode.value.length\n          pos = p\n\n          // the current node is a Token, then the match starts inside another Token, which is invalid\n          if (currentNode.value instanceof Token) {\n            continue\n          }\n\n          // find the last node which is affected by this match\n          for (\n            var k = currentNode;\n            k !== tokenList.tail && (p < to || typeof k.value === 'string');\n            k = k.next\n          ) {\n            removeCount++\n            p += k.value.length\n          }\n          removeCount--\n\n          // replace with the new match\n          str = text.slice(pos, p)\n          match.index -= pos\n        } else {\n          match = matchPattern(pattern, 0, str, lookbehind)\n          if (!match) {\n            continue\n          }\n        }\n\n        // eslint-disable-next-line no-redeclare\n        var from = match.index\n        var matchStr = match[0]\n        var before = str.slice(0, from)\n        var after = str.slice(from + matchStr.length)\n\n        var reach = pos + str.length\n        if (rematch && reach > rematch.reach) {\n          rematch.reach = reach\n        }\n\n        var removeFrom = currentNode.prev\n\n        if (before) {\n          removeFrom = addAfter(tokenList, removeFrom, before)\n          pos += before.length\n        }\n\n        removeRange(tokenList, removeFrom, removeCount)\n\n        var wrapped = new Token(\n          token,\n          inside ? _.tokenize(matchStr, inside) : matchStr,\n          alias,\n          matchStr\n        )\n        currentNode = addAfter(tokenList, removeFrom, wrapped)\n\n        if (after) {\n          addAfter(tokenList, currentNode, after)\n        }\n\n        if (removeCount > 1) {\n          // at least one Token object was removed, so we have to do some rematching\n          // this can only happen if the current pattern is greedy\n\n          /** @type {RematchOptions} */\n          var nestedRematch = {\n            cause: token + ',' + j,\n            reach: reach\n          }\n          matchGrammar(\n            text,\n            tokenList,\n            grammar,\n            currentNode.prev,\n            pos,\n            nestedRematch\n          )\n\n          // the reach might have been extended because of the rematching\n          if (rematch && nestedRematch.reach > rematch.reach) {\n            rematch.reach = nestedRematch.reach\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * @typedef LinkedListNode\n * @property {T} value\n * @property {LinkedListNode<T> | null} prev The previous node.\n * @property {LinkedListNode<T> | null} next The next node.\n * @template T\n * @private\n */\n\n/**\n * @template T\n * @private\n */\nfunction LinkedList() {\n  /** @type {LinkedListNode<T>} */\n  var head = {value: null, prev: null, next: null}\n  /** @type {LinkedListNode<T>} */\n  var tail = {value: null, prev: head, next: null}\n  head.next = tail\n\n  /** @type {LinkedListNode<T>} */\n  this.head = head\n  /** @type {LinkedListNode<T>} */\n  this.tail = tail\n  this.length = 0\n}\n\n/**\n * Adds a new node with the given value to the list.\n *\n * @param {LinkedList<T>} list\n * @param {LinkedListNode<T>} node\n * @param {T} value\n * @returns {LinkedListNode<T>} The added node.\n * @template T\n */\nfunction addAfter(list, node, value) {\n  // assumes that node != list.tail && values.length >= 0\n  var next = node.next\n\n  var newNode = {value: value, prev: node, next: next}\n  node.next = newNode\n  next.prev = newNode\n  list.length++\n\n  return newNode\n}\n/**\n * Removes `count` nodes after the given node. The given node will not be removed.\n *\n * @param {LinkedList<T>} list\n * @param {LinkedListNode<T>} node\n * @param {number} count\n * @template T\n */\nfunction removeRange(list, node, count) {\n  var next = node.next\n  for (var i = 0; i < count && next !== list.tail; i++) {\n    next = next.next\n  }\n  node.next = next\n  next.prev = node\n  list.length -= i\n}\n/**\n * @param {LinkedList<T>} list\n * @returns {T[]}\n * @template T\n */\nfunction toArray(list) {\n  var array = []\n  var node = list.head.next\n  while (node !== list.tail) {\n    array.push(node.value)\n    node = node.next\n  }\n  return array\n}\n\nexport const Prism = _\n\n// some additional documentation/types\n\n/**\n * The expansion of a simple `RegExp` literal to support additional properties.\n *\n * @typedef GrammarToken\n * @property {RegExp} pattern The regular expression of the token.\n * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)\n * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.\n * @property {boolean} [greedy=false] Whether the token is greedy.\n * @property {string|string[]} [alias] An optional alias or list of aliases.\n * @property {Grammar} [inside] The nested grammar of this token.\n *\n * The `inside` grammar will be used to tokenize the text value of each token of this kind.\n *\n * This can be used to make nested and even recursive language definitions.\n *\n * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into\n * each another.\n * @global\n * @public\n */\n\n/**\n * @typedef Grammar\n * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}\n * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.\n * @global\n * @public\n */\n\n/**\n * A function which will invoked after an element was successfully highlighted.\n *\n * @callback HighlightCallback\n * @param {Element} element The element successfully highlighted.\n * @returns {void}\n * @global\n * @public\n */\n\n/**\n * @callback HookCallback\n * @param {Object<string, any>} env The environment variables of the hook.\n * @returns {void}\n * @global\n * @public\n */\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}